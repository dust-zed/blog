<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Jni-Rust on zed的博客</title><link>https://www.dust-zed.site/categories/jni-rust/</link><description>Recent content in Jni-Rust on zed的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 15 Oct 2025 11:55:59 +0800</lastBuildDate><atom:link href="https://www.dust-zed.site/categories/jni-rust/index.xml" rel="self" type="application/rss+xml"/><item><title>Android_rust混合开发入门</title><link>https://www.dust-zed.site/android-develop/android_rust%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</link><pubDate>Wed, 15 Oct 2025 11:55:59 +0800</pubDate><guid>https://www.dust-zed.site/android-develop/android_rust%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</guid><description>&lt;h4 id="什么是ndk">什么是NDK?
&lt;/h4>&lt;p>&lt;strong>NDK = Native Development Kit(原生开发工具包)&lt;/strong>&lt;/p>
&lt;p>&lt;strong>一句话解释&lt;/strong>&lt;/p>
&lt;p>NDK 是 Android 提供的工具集,让你能用 &lt;strong>C/C++/Rust&lt;/strong> 等原生语言开发 Android 应用的一部分&lt;/p>
&lt;hr>
&lt;h4 id="android应用的两种开发方式">Android应用的两种开发方式
&lt;/h4>&lt;pre tabindex="0">&lt;code>┌─────────────────────────────────────────┐
│ Android 应用 │
├─────────────────────────────────────────┤
│ │
│ 方式 1: Java/Kotlin (Android SDK) │
│ ┌──────────────────────────────────┐ │
│ │ Kotlin/Java 代码 │ │
│ │ ↓ │ │
│ │ 编译为 DEX 字节码 │ │
│ │ ↓ │ │
│ │ 在 Dalvik/ART 虚拟机运行 │ │
│ └──────────────────────────────────┘ │
│ │
│ 方式 2: C/C++/Rust (Android NDK) │
│ ┌──────────────────────────────────┐ │
│ │ C/C++/Rust 代码 │ │
│ │ ↓ │ │
│ │ 编译为 .so 文件 (机器码) │ │
│ │ ↓ │ │
│ │ 直接在 CPU 上运行 (无虚拟机) │ │
│ └──────────────────────────────────┘ │
│ │
│ 两者通过 JNI 桥接 │
└─────────────────────────────────────────┘
&lt;/code>&lt;/pre>&lt;h4 id="为什么需要ndk">为什么需要NDK？
&lt;/h4>&lt;h5 id="对比理解">对比理解
&lt;/h5>&lt;p>纯 &lt;strong>Java/Kotlin(SDK):&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>优点:
✅ 开发简单
✅ 跨设备兼容好
✅ 调试方便
缺点:
❌ 性能有限 (虚拟机开销)
❌ 某些功能无法实现
❌ 无法复用 C/C++ 库
&lt;/code>&lt;/pre>&lt;p>&lt;strong>NDK(C/C++/Rust)&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code>优点:
✅ 性能极高 (接近机器码)
✅ 可以复用现有 C/C++ 库
✅ 直接访问硬件
✅ 跨平台代码复用
缺点:
❌ 开发复杂
❌ 调试困难
❌ 需要为不同 CPU 编译
&lt;/code>&lt;/pre>&lt;hr>
&lt;h4 id="ndk工作原理">NDK工作原理
&lt;/h4>&lt;h5 id="完整流程">完整流程
&lt;/h5>&lt;pre tabindex="0">&lt;code>第 1 步: 写 Rust 代码
┌────────────────────────┐
│ // Rust 代码 │
│ pub fn add(a: i32, b: i32) -&amp;gt; i32 {
│ a + b │
│ } │
└────────────────────────┘
↓
第 2 步: NDK 编译
┌────────────────────────┐
│ NDK 工具链编译 │
│ - 交叉编译 │
│ - 针对 ARM/x86 CPU │
└────────────────────────┘
↓
第 3 步: 生成 .so 文件
┌────────────────────────┐
│ librust_lib.so │
│ (机器码,可直接运行) │
└────────────────────────┘
↓
第 4 步: Android 加载
┌────────────────────────┐
│ System.loadLibrary(&amp;#34;rust_lib&amp;#34;)
│ │
│ external fun add(a: Int, b: Int): Int
└────────────────────────┘
↓
第 5 步: JNI 调用
┌────────────────────────┐
│ Kotlin → JNI → Rust │
│ val result = add(5, 3) │
│ // result = 8 │
└────────────────────────┘
&lt;/code>&lt;/pre>&lt;hr>
&lt;h4 id="ndk包含什么">NDK包含什么？
&lt;/h4>&lt;h5 id="ndk工具集">NDK工具集
&lt;/h5>&lt;pre tabindex="0">&lt;code>$ANDROID_NDK_HOME/
├── build/ # 构建脚本
├── toolchains/ # 编译器工具链
│ ├── aarch64-linux-android/ # ARM64 编译器
│ ├── arm-linux-androideabi/ # ARM32 编译器
│ ├── x86/ # x86 编译器
│ └── x86_64/ # x86_64 编译器
├── platforms/ # Android API 级别的头文件
├── sources/ # 示例代码
└── sysroot/ # 系统库
&lt;/code>&lt;/pre>&lt;h5 id="编译器">编译器
&lt;/h5>&lt;pre tabindex="0">&lt;code>NDK 提供了针对不同 CPU 架构的编译器:
ARM64 (arm64-v8a): 现代手机 (主流)
ARM32 (armeabi-v7a): 老手机
x86: 模拟器
x86_64: 模拟器
&lt;/code>&lt;/pre>&lt;hr>
&lt;h4 id="so文件是什么">.so文件是什么？
&lt;/h4>&lt;h5 id="理解so文件">理解.so文件
&lt;/h5>&lt;pre tabindex="0">&lt;code>.so = Shared Object (共享对象)
类似于:
- Windows 的 .dll 文件
- macOS 的 .dylib 文件
作用:
- 包含编译后的机器码
- 可以被多个程序共享使用
&lt;/code>&lt;/pre>&lt;h5 id="so文件示例">.so文件示例
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看 .so 文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ls android/app/src/main/jniLibs/arm64-v8a/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># librust_lib.so ← 这就是编译后的 Rust 代码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看文件信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>file librust_lib.so
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># librust_lib.so: ELF 64-bit LSB shared object, ARM aarch64, ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 查看导出的函数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nm -D librust_lib.so | grep Java
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Java_com_example_rustdemo_RustBridge_add&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Java_com_example_rustdemo_RustBridge_reverseString&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h4 id="ndk开发流程">NDK开发流程
&lt;/h4>&lt;h5 id="完整开发流程">完整开发流程
&lt;/h5>&lt;pre tabindex="0">&lt;code>1. 安装 NDK
↓
Android Studio → SDK Manager → SDK Tools → NDK
2. 配置环境
↓
export ANDROID_NDK_HOME=/path/to/ndk
3. 编写原生代码 (C/C++/Rust)
↓
例如: add.c, image.cpp, search.rs
4. 使用 NDK 编译
↓
ndk-build (C/C++)
cargo-ndk (Rust)
5. 生成 .so 文件
↓
libmylib.so
6. 放入 jniLibs 目录
↓
app/src/main/jniLibs/arm64-v8a/libmylib.so
7. Kotlin 加载和调用
↓
System.loadLibrary(&amp;#34;mylib&amp;#34;)
external fun add(a: Int, b: Int): Int
&lt;/code>&lt;/pre>&lt;hr>
&lt;h4 id="ndk核心概念">NDK核心概念
&lt;/h4>&lt;h5 id="jnijava-native-interface">JNI(Java Native Interface)
&lt;/h5>&lt;p>&lt;strong>JNI&lt;/strong>是桥梁:&lt;/p>
&lt;pre tabindex="0">&lt;code>┌──────────────┐ ┌──────────────┐
│ Kotlin │ JNI │ Rust │
│ (虚拟机) │ ◄─────► │ (原生码) │
└──────────────┘ └──────────────┘
数据传递:
Kotlin Int ↔ Rust i32
Kotlin String ↔ Rust String
Kotlin IntArray ↔ Rust &amp;amp;[i32]
&lt;/code>&lt;/pre>&lt;h5 id="交叉编译">交叉编译
&lt;/h5>&lt;p>什么是交叉编译?&lt;/p>
&lt;pre tabindex="0">&lt;code>你在 x86_64 电脑上开发
↓
但手机是 ARM64 架构
↓
需要&amp;#34;交叉编译&amp;#34;: 在 x86_64 上编译出 ARM64 代码
↓
NDK 提供了交叉编译工具链
&lt;/code>&lt;/pre>&lt;h5 id="abiapplication-binary-interface">ABI(Application Binary Interface)
&lt;/h5>&lt;p>不同&lt;strong>CPU&lt;/strong>需要不同的**.so**文件:&lt;/p>
&lt;pre tabindex="0">&lt;code>arm64-v8a/libmylib.so → ARM64 手机
armeabi-v7a/libmylib.so → ARM32 手机
x86/libmylib.so → x86 模拟器
x86_64/libmylib.so → x86_64 模拟器
&lt;/code>&lt;/pre>&lt;hr>
&lt;h4 id="什么时候用ndk">什么时候用NDK?
&lt;/h4>&lt;h5 id="应该用ndk的场景">应该用NDK的场景
&lt;/h5>&lt;pre tabindex="0">&lt;code>1. 性能关键代码
- 图像/视频处理
- 音频处理
- 大量数学计算
- 加密/解密
2. 复用现有代码
- 已有 C/C++ 库
- 跨平台代码 (iOS/Android 共享)
3. 保护核心算法
- 防止反编译
- 商业逻辑保护
4. 访问底层功能
- 硬件控制
- 系统调用
&lt;/code>&lt;/pre>&lt;h5 id="不应该用ndk的场景">不应该用NDK的场景
&lt;/h5>&lt;pre tabindex="0">&lt;code>1. 简单业务逻辑
- 按钮点击
- 数据展示
- 网络请求
2. 快速开发
- 原型验证
- MVP 阶段
3. 团队不熟悉 C/C++/Rust
- 维护成本高
- Bug 难以调试
&lt;/code>&lt;/pre>&lt;hr>
&lt;h4 id="ndk开发工具">NDK开发工具
&lt;/h4>&lt;h5 id="必备工具">必备工具
&lt;/h5>&lt;pre tabindex="0">&lt;code>1. Android NDK
- 下载: Android Studio SDK Manager
2. CMake (C/C++) 或 cargo-ndk (Rust)
- cargo install cargo-ndk
3. LLDB (调试器)
- Android Studio 内置
&lt;/code>&lt;/pre>&lt;h5 id="辅助工具">辅助工具
&lt;/h5>&lt;pre tabindex="0">&lt;code># 查看 .so 文件信息
readelf -h libmylib.so
# 查看导出的函数
nm -D libmylib.so
# 反汇编 (调试用)
objdump -d libmylib.so
&lt;/code>&lt;/pre>&lt;hr>
&lt;h4 id="总结">总结
&lt;/h4>&lt;h5 id="ndk是什么">NDK是什么？
&lt;/h5>&lt;pre tabindex="0">&lt;code>NDK = 让你用 C/C++/Rust 开发 Android 的工具包
作用:
1. 提供交叉编译工具链
2. 编译出 .so 机器码文件
3. 通过 JNI 与 Kotlin 交互
4. 获得原生性能
适用场景:
- 高性能计算
- 复用 C/C++ 库
- 跨平台开发
&lt;/code>&lt;/pre>&lt;h5 id="关键概念">关键概念
&lt;/h5>&lt;pre tabindex="0">&lt;code>NDK: 工具包
JNI: 桥梁 (Kotlin ↔ 原生代码)
.so: 编译后的机器码
ABI: 不同 CPU 架构
流程:
Rust 代码 → NDK 编译 → .so 文件 → JNI 调用 → Kotlin 使用
&lt;/code>&lt;/pre></description></item></channel></rss>