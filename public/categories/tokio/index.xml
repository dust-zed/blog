<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Tokio on zed的博客</title>
        <link>http://localhost:1313/categories/tokio/</link>
        <description>Recent content in Tokio on zed的博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Fri, 19 Sep 2025 13:50:29 +0800</lastBuildDate><atom:link href="http://localhost:1313/categories/tokio/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Tokio核心模型解析</title>
        <link>http://localhost:1313/rust/tokio/tokio%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%90/</link>
        <pubDate>Fri, 19 Sep 2025 13:50:29 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/tokio/tokio%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%90/</guid>
        <description>&lt;h1 id=&#34;tokio-核心模型解析&#34;&gt;Tokio 核心模型解析
&lt;/h1&gt;&lt;p&gt;让我们从顶层设计开始，逐步深入 Tokio 的异步运行时模型。&lt;/p&gt;
&lt;h2 id=&#34;1-核心抽象模型&#34;&gt;1. 核心抽象模型
&lt;/h2&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;+-------------------------------------------------+
|                Runtime (运行时)                  |
|  +-------------------------------------------+  |
|  |              Reactor (反应器)              |  |
|  |  - I/O 多路复用 (epoll/kqueue/IOCP)        |  |
|  |  - 处理 I/O 事件通知                        |  |
|  +-------------------------------------------+  |
|                                                 |
|  +-------------------------------------------+  |
|  |              Scheduler (调度器)            |  |
|  |  - 多线程工作窃取调度                      |  |
|  |  - 任务队列管理                            |  |
|  +-------------------------------------------+  |
|                                                 |
|  +-------------------------------------------+  |
|  |               Timer (定时器)               |  |
|  |  - 管理定时任务                            |  |
|  |  - 基于时间轮的定时器实现                   |  |
|  +-------------------------------------------+  |
+-------------------------------------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;2-任务生命周期模型&#34;&gt;2. 任务生命周期模型
&lt;/h2&gt;&lt;h3 id=&#34;21-任务状态机&#34;&gt;2.1 任务状态机
&lt;/h3&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;stateDiagram-v2
    [*] --&amp;gt; Created: 创建
    Created --&amp;gt; Scheduled: 调度
    Scheduled --&amp;gt; Running: 执行
    Running --&amp;gt; Pending: 等待I/O
    Pending --&amp;gt; Scheduled: I/O就绪
    Running --&amp;gt; Complete: 完成
    Running --&amp;gt; Panicked: 恐慌
    Running --&amp;gt; Cancelled: 取消
    Pending --&amp;gt; Cancelled: 取消
    Panicked --&amp;gt; [*]
    Complete --&amp;gt; [*]
    Cancelled --&amp;gt; [*]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;22-状态位表示&#34;&gt;2.2 状态位表示
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 状态位域
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;RUNNING&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b0001&lt;/span&gt;;      &lt;span style=&#34;color:#75715e&#34;&gt;// 任务正在执行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;COMPLETE&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b0010&lt;/span&gt;;     &lt;span style=&#34;color:#75715e&#34;&gt;// 任务已完成
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOTIFIED&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b0100&lt;/span&gt;;     &lt;span style=&#34;color:#75715e&#34;&gt;// 任务已通知调度器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;JOIN_INTEREST&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b1000&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 有任务在等待Join
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;JOIN_WAKER&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b1_0000&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;// 已设置Join Waker
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CANCELLED&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0b10_0000&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;// 任务已取消
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;3-核心数据结构&#34;&gt;3. 核心数据结构
&lt;/h2&gt;&lt;h3 id=&#34;31-任务结构-rawtask&#34;&gt;3.1 任务结构 (RawTask)
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;RawTask&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    header: &lt;span style=&#34;color:#a6e22e&#34;&gt;Header&lt;/span&gt;,          &lt;span style=&#34;color:#75715e&#34;&gt;// 任务头信息
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    scheduler: &lt;span style=&#34;color:#a6e22e&#34;&gt;Scheduler&lt;/span&gt;,    &lt;span style=&#34;color:#75715e&#34;&gt;// 调度器
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    state: &lt;span style=&#34;color:#a6e22e&#34;&gt;State&lt;/span&gt;,           &lt;span style=&#34;color:#75715e&#34;&gt;// 任务状态
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    future: &lt;span style=&#34;color:#a6e22e&#34;&gt;Future&lt;/span&gt;,         &lt;span style=&#34;color:#75715e&#34;&gt;// 要执行的Future
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    output: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Output&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, &lt;span style=&#34;color:#75715e&#34;&gt;// Future的输出
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;32-调度器模型&#34;&gt;3.2 调度器模型
&lt;/h3&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;+----------------+     +----------------+     +----------------+
|   Local Queue  | &amp;lt;-&amp;gt; | Global Queue  | &amp;lt;-&amp;gt; | Worker Threads |
+----------------+     +----------------+     +----------------+
        ^                     ^                       ^
        |                     |                       |
        v                     v                       v
+----------------+     +----------------+     +----------------+
| Task Producer  |     | Work Stealing  |     | Task Consumer  |
| (spawn)        |     | (负载均衡)      |     | (poll)         |
+----------------+     +----------------+     +----------------+
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;4-执行流程&#34;&gt;4. 执行流程
&lt;/h2&gt;&lt;h3 id=&#34;41-任务创建与调度&#34;&gt;4.1 任务创建与调度
&lt;/h3&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;sequenceDiagram
    participant A as 用户代码
    participant B as Runtime
    participant C as 调度器
    participant D as 工作线程
    
    A-&amp;gt;&amp;gt;B: spawn(future)
    B-&amp;gt;&amp;gt;C: 创建任务并加入队列
    C-&amp;gt;&amp;gt;D: 工作线程窃取任务
    D-&amp;gt;&amp;gt;D: 执行future.poll()
    alt Future返回Pending
        D-&amp;gt;&amp;gt;B: 注册Waker
    else Future返回Ready
        D-&amp;gt;&amp;gt;B: 设置输出结果
    end
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;42-io-就绪处理&#34;&gt;4.2 I/O 就绪处理
&lt;/h3&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;sequenceDiagram
    participant A as Reactor
    participant B as 调度器
    participant C as 任务
    
    A-&amp;gt;&amp;gt;B: I/O 就绪事件
    B-&amp;gt;&amp;gt;C: 唤醒关联的Waker
    C-&amp;gt;&amp;gt;B: 将任务加入就绪队列
    B-&amp;gt;&amp;gt;C: 调度执行
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;5-关键优化技术&#34;&gt;5. 关键优化技术
&lt;/h2&gt;&lt;h3 id=&#34;51-无锁队列&#34;&gt;5.1 无锁队列
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 使用crossbeam的无锁队列
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TaskQueue&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; crossbeam_deque::Worker&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Arc&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Task&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;52-工作窃取&#34;&gt;5.2 工作窃取
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 工作线程尝试从其他队列窃取任务
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;steal_work&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;self) -&amp;gt; Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Task&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 随机选择受害者队列
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self.workers.len();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; start &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self.rng.&lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; idx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (start &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; i) &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; len;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; Some(task) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self.workers[idx].steal() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Some(task);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    None
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;53-零成本抽象&#34;&gt;5.3 零成本抽象
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 使用泛型和编译期多态
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;spawn&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;F, T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(future: &lt;span style=&#34;color:#a6e22e&#34;&gt;F&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;JoinHandle&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;where&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    F: &lt;span style=&#34;color:#a6e22e&#34;&gt;Future&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Output &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; Send &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &amp;#39;static,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    T: Send &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &amp;#39;static,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 编译时生成特定类型的代码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;6-内存模型&#34;&gt;6. 内存模型
&lt;/h2&gt;&lt;h3 id=&#34;61-任务分配&#34;&gt;6.1 任务分配
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 自定义内存分配器优化
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; layout &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Layout::new::&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Header&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .extend(Layout::new::&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Scheduler&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;())&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .extend(Layout::new::&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;())&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; ptr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; alloc(layout);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;62-引用计数&#34;&gt;6.2 引用计数
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 使用原子引用计数管理任务生命周期
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Task&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    header: &lt;span style=&#34;color:#a6e22e&#34;&gt;Arc&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Header&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Drop &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; Task {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;drop&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; self) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; Arc::strong_count(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;self.header) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 最后一个引用，释放资源
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;7-调试与追踪&#34;&gt;7. 调试与追踪
&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#[cfg(tokio_unstable)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TaskMeta&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    name: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&amp;#39;static &lt;span style=&#34;color:#66d9ef&#34;&gt;str&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    location: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&amp;#39;static &lt;span style=&#34;color:#a6e22e&#34;&gt;std&lt;/span&gt;::panic::Location&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&amp;#39;static&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;8-使用模型&#34;&gt;8. 使用模型
&lt;/h2&gt;&lt;h3 id=&#34;81-基本使用&#34;&gt;8.1 基本使用
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#[tokio::main]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 创建任务
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; handle &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; tokio::spawn(&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 异步代码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello, Tokio!&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 等待任务完成
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; handle.&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt;.unwrap();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;println!&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, result);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;82-任务间通信&#34;&gt;8.2 任务间通信
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 使用通道进行任务间通信
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (tx, &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; rx) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; tokio::sync::mpsc::channel(&lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 生产者任务
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;tokio::spawn(&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;move&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    tx.send(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello&amp;#34;&lt;/span&gt;).&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt;.unwrap();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 消费者任务
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;tokio::spawn(&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;move&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; Some(message) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rx.recv().&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;println!&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;received: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, message);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;9-性能考量&#34;&gt;9. 性能考量
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;任务大小&lt;/strong&gt;：保持任务小巧高效&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;避免阻塞&lt;/strong&gt;：不要在异步上下文中执行阻塞操作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;批量处理&lt;/strong&gt;：合并小的I/O操作为批量操作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;合理使用spawn&lt;/strong&gt;：避免创建过多任务&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;10-调试技巧&#34;&gt;10. 调试技巧
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;启用 &lt;code&gt;tokio_unstable&lt;/code&gt; 特性获取更多调试信息&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;tracing&lt;/code&gt; 进行分布式追踪&lt;/li&gt;
&lt;li&gt;监控运行时指标（任务数、队列长度等）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个模型展示了 Tokio 如何高效地管理异步任务。理解这些核心概念后，您可以更深入地研究特定组件的实现细节。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Tokio任务系统解析</title>
        <link>http://localhost:1313/rust/tokio/tokio%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E8%A7%A3%E6%9E%90/</link>
        <pubDate>Fri, 19 Sep 2025 12:38:14 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/tokio/tokio%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E8%A7%A3%E6%9E%90/</guid>
        <description>&lt;p&gt;Tokio的任务系统是其异步运行时的核心，它负责调度和执行异步任务。让我们深入分析其设计和实现。&lt;/p&gt;
&lt;h3 id=&#34;1-核心组件&#34;&gt;1. 核心组件
&lt;/h3&gt;&lt;h4 id=&#34;11-任务表示&#34;&gt;1.1 任务表示
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;crate&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Task&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;S: &amp;#39;static&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  raw: &lt;span style=&#34;color:#a6e22e&#34;&gt;RawTask&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  _p: &lt;span style=&#34;color:#a6e22e&#34;&gt;PhantomData&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RawTask&lt;/code&gt;：实际的任务数据，包含任务状态、调度器等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PhantomData&amp;lt;S&amp;gt;&lt;/code&gt;：关联调度器类型，用于类型安全&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;12-任务头header&#34;&gt;1.2 任务头(Header)
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;crate&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Header&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    state: &lt;span style=&#34;color:#a6e22e&#34;&gt;State&lt;/span&gt;,                   &lt;span style=&#34;color:#75715e&#34;&gt;// 任务状态
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    queue_next: &lt;span style=&#34;color:#a6e22e&#34;&gt;UnsafeCell&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;..&lt;/span&gt;.&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,    &lt;span style=&#34;color:#75715e&#34;&gt;// 任务队列指针
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    vtable: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&amp;#39;static &lt;span style=&#34;color:#a6e22e&#34;&gt;Vtable&lt;/span&gt;,        &lt;span style=&#34;color:#75715e&#34;&gt;// 虚函数表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    owner_id: &lt;span style=&#34;color:#a6e22e&#34;&gt;UnsafeCell&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;..&lt;/span&gt;.&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,      &lt;span style=&#34;color:#75715e&#34;&gt;// 任务所有者ID
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;2-任务生命周期&#34;&gt;2. 任务生命周期
&lt;/h4&gt;&lt;h4 id=&#34;21-创建任务&#34;&gt;2.1 创建任务
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;new_task&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T, S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(task: &lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt;, scheduler: &lt;span style=&#34;color:#a6e22e&#34;&gt;S&lt;/span&gt;, id: &lt;span style=&#34;color:#a6e22e&#34;&gt;Id&lt;/span&gt;) -&amp;gt; (Task&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, Notified&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, JoinHandle&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T::Output&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;where&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    T: &lt;span style=&#34;color:#a6e22e&#34;&gt;Future&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &amp;#39;static,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    S: &lt;span style=&#34;color:#a6e22e&#34;&gt;Schedule&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; raw &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; RawTask::new::&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T, S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(task, scheduler, id, spawned_at);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 创建三种句柄
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; task &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Task { raw, _p: &lt;span style=&#34;color:#a6e22e&#34;&gt;PhantomData&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; notified &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Notified(Task { raw, _p: &lt;span style=&#34;color:#a6e22e&#34;&gt;PhantomData&lt;/span&gt; });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; join &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; JoinHandle::new(raw);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (task, notified, join)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;RawTask&lt;/code&gt;实现了Copy，故这里可以这样做，同时我们需要知道&lt;code&gt;RawTask&lt;/code&gt;的初始引用计数状态。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;super&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;new&lt;/span&gt;() -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;State&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  State {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    val: &lt;span style=&#34;color:#a6e22e&#34;&gt;AtomicUsize&lt;/span&gt;::new(&lt;span style=&#34;color:#66d9ef&#34;&gt;INTIAL_STATE&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;初始状态设置为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;INITIAL_STATE&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;REF_ONE&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;JOIN_INTEREST&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOTIFIED&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这意味着：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始引用计数是&lt;code&gt;REF_ONE * 3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;同时设置了 &lt;code&gt;JOIN_INTEREST&lt;/code&gt; 和 &lt;code&gt;NOTIFIED&lt;/code&gt; 标志位&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一个任务创建会返回三个句柄：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Task&lt;/code&gt;：用于取消或释放任务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Notified&lt;/code&gt;：表示任务已准备好执行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JoinHandle&lt;/code&gt;：用于等待任务完成并获取结果&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-核心机制&#34;&gt;3. 核心机制
&lt;/h3&gt;&lt;h4 id=&#34;31-任务调度&#34;&gt;3.1 任务调度
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 在调度器中的执行循环
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;loop&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; task &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self.next_task();  &lt;span style=&#34;color:#75715e&#34;&gt;// 获取下一个就绪任务
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    task.run();                  &lt;span style=&#34;color:#75715e&#34;&gt;// 执行任务
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;32-唤醒机制&#34;&gt;3.2 唤醒机制
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Waker 实现
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Waker&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    header: &lt;span style=&#34;color:#a6e22e&#34;&gt;NonNull&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Header&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; std::task::Wake &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; Waker {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;wake&lt;/span&gt;(self) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self.wake_by_ref();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;wake_by_ref&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;self) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 将任务标记为就绪并重新调度
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;unsafe&lt;/span&gt; { (self.header.as_ref().vtable.schedule)(self.header) };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;4-内存管理&#34;&gt;4. 内存管理
&lt;/h3&gt;&lt;h4 id=&#34;41-任务分配&#34;&gt;4.1 任务分配
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T: &lt;span style=&#34;color:#a6e22e&#34;&gt;Future&lt;/span&gt;, S: &lt;span style=&#34;color:#a6e22e&#34;&gt;Schedule&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; RawTask&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T, S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;new&lt;/span&gt;(future: &lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt;, scheduler: &lt;span style=&#34;color:#a6e22e&#34;&gt;S&lt;/span&gt;, id: &lt;span style=&#34;color:#a6e22e&#34;&gt;Id&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;NonNull&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Header&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 1. 计算内存布局
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 2. 分配内存
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 3. 初始化 Header 和 Future
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 4. 返回指向 Header 的指针
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;42-内存布局&#34;&gt;4.2 内存布局
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+-------------------+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;      Header       &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 包含任务元数据和虚函数表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+-------------------+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;   Scheduler (S)   &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 调度器实例
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+-------------------+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;   Future (T)      &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 实际的 Future
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+-------------------+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;   Output Slot     &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 存储 Future 的输出
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+-------------------+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;   Traces          &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 调试和跟踪信息
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+-------------------+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;5-并发控制&#34;&gt;5. 并发控制
&lt;/h3&gt;&lt;h4 id=&#34;51-状态管理&#34;&gt;5.1 状态管理
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;State&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 使用原子操作管理状态
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// - 运行中标志
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// - 完成标志
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// - 取消标志
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// - 引用计数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    value: &lt;span style=&#34;color:#a6e22e&#34;&gt;AtomicUsize&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;具体来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高位的比特位用于引用计数(&lt;code&gt;REF_COUNT_MASK&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;低位的比特位用于任务状态(&lt;code&gt;STATE_MASK&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;52-锁优化&#34;&gt;5.2 锁优化
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 使用无锁算法优化热点路径
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;transition_to_running&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;self) -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TransitionToRunning&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 使用原子操作更新状态
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 避免使用互斥锁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;7-设计模式&#34;&gt;7. 设计模式
&lt;/h3&gt;&lt;h4 id=&#34;71-类型擦除&#34;&gt;7.1 类型擦除
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 使用虚函数表实现类型擦除
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Vtable&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    poll: &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt;(NonNull&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Header&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dealloc: &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt;(NonNull&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Header&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;72-零成本抽象&#34;&gt;7.2 零成本抽象
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 使用泛型和编译期多态
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T, S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; Task&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T, S&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 零成本抽象
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>时间轮算法</title>
        <link>http://localhost:1313/rust/tokio/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95/</link>
        <pubDate>Thu, 11 Sep 2025 21:51:21 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/tokio/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95/</guid>
        <description>&lt;p&gt;时间轮(Time Wheel)是Tokio定时器实现的核心算法，它通过分层的方式高效管理大量定时器。&lt;/p&gt;
&lt;h3 id=&#34;1-基本概念&#34;&gt;1. 基本概念
&lt;/h3&gt;&lt;h4 id=&#34;11-wheel结构与层级关系&#34;&gt;1.1 Wheel结构与层级关系
&lt;/h4&gt;&lt;h5 id=&#34;111-时间轮结构&#34;&gt;1.1.1 时间轮结构
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;crate&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Wheel&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#e6db74&#34;&gt;///当前时间轮已过去的时间
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;  elapsed: &lt;span style=&#34;color:#66d9ef&#34;&gt;u64&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#e6db74&#34;&gt;///时间轮的分层
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;  levels: Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;[Level; &lt;span style=&#34;color:#66d9ef&#34;&gt;NUM_LEVELS&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#e6db74&#34;&gt;///Entries queued for firing
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;  pending: &lt;span style=&#34;color:#a6e22e&#34;&gt;EntryList&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;112-层级&#34;&gt;1.1.2 层级
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Level&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  slot: [EntryList; &lt;span style=&#34;color:#66d9ef&#34;&gt;LEVEL_MULT&lt;/span&gt;],		&lt;span style=&#34;color:#75715e&#34;&gt;//槽位数组
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  level: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  occupied: &lt;span style=&#34;color:#66d9ef&#34;&gt;u64&lt;/span&gt;,										&lt;span style=&#34;color:#75715e&#34;&gt;// bit field指示slot是否占用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;113-槽位&#34;&gt;1.1.3 槽位
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Slot&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  head: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;NonNull&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;TimerShared&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;12-分层设计&#34;&gt;1.2 分层设计
&lt;/h4&gt;&lt;p&gt;Tokio使用多级时间轮（通常为6级），每级包含固定数量的槽位，每级包含固定数量的槽位(slots)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第0级：64个槽位，每个64^0毫秒&lt;/li&gt;
&lt;li&gt;第1级：64个槽位，每个64^1毫秒&lt;/li&gt;
&lt;li&gt;第2级：32个槽位，每个64^2毫秒&lt;/li&gt;
&lt;li&gt;第3级：32个槽位，每个64^3毫秒&lt;/li&gt;
&lt;li&gt;第4级：32个槽位，每个64^4毫秒&lt;/li&gt;
&lt;li&gt;第5级：32个槽位，每个64^5毫秒&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;时间轮的工作流程&#34;&gt;时间轮的工作流程
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;添加一个500ms后触发的定时器&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;第0级：500 &amp;gt; 64ms → 不适用&lt;/li&gt;
&lt;li&gt;第1级：500 / 64 = 7.8 → 放入第7个槽位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;时间推进&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;每毫秒检查第0级&lt;/li&gt;
&lt;li&gt;每64ms检查第1级&lt;/li&gt;
&lt;li&gt;依此类推&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;降级&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;当高层级的时间轮转动时，将定时器重新分配到更精确的层级&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种多级设计使得tokio能够：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;精确处理短期定时器(毫秒级)&lt;/li&gt;
&lt;li&gt;高效管理长期定时器( 年)&lt;/li&gt;
&lt;li&gt;保持较低的内存占用和计算开销&lt;/li&gt;
&lt;li&gt;根据&lt;code&gt;elapsed&lt;/code&gt;确定需要检查的时间轮层级和槽位&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;时间轮和时英钟（时针、分针、秒针）可以进行类比理解。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Time的阅读学习记录</title>
        <link>http://localhost:1313/rust/tokio/time%E7%9A%84%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</link>
        <pubDate>Thu, 11 Sep 2025 16:20:08 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/tokio/time%E7%9A%84%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</guid>
        <description>&lt;h4 id=&#34;sourcers&#34;&gt;source.rs
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;用于管理时间戳转换&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start_time&lt;/code&gt;记录运行时启动的绝对时间点&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;entryrs&#34;&gt;entry.rs
&lt;/h4&gt;&lt;h5 id=&#34;1-核心数据结构&#34;&gt;1. 核心数据结构
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TimerEntry&lt;/code&gt;：表示一个定时器条目&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TimerShared&lt;/code&gt;：定时器的共享状态，包含并发控制逻辑&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StateCell&lt;/code&gt;：管理定时器状态的原子操作封装&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2-主要功能&#34;&gt;2. 主要功能
&lt;/h5&gt;&lt;h6 id=&#34;定时器状态管理&#34;&gt;定时器状态管理
&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;使用原子操作实现无锁状态转换&lt;/li&gt;
&lt;li&gt;支持定时器的注册、取消和触发&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StateCell&lt;/code&gt;有三种状态
&lt;ul&gt;
&lt;li&gt;具体的过期时间戳（定时器已调度，待触发）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;STATE_PENDING_FIRE&lt;/code&gt;（定时器已到期，正准备触发）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;STATE_DEREGISTERED&lt;/code&gt;(已取消/完成)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;已调度&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;时间到&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;-&amp;gt; [&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;待触发&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;触发完成&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;-&amp;gt; [&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;已取消&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;                                          &lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;                                          &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#f92672&#34;&gt;+------------------&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;取消&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-------------------+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TimerShared&lt;/code&gt;负责管理定时器的共享状态和并发安全，分离了定时器的注册时间，用于时间轮调度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TimerEntry&lt;/code&gt;是用户可见的句柄，包含完整的生命周期管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;modrs&#34;&gt;mod.rs
&lt;/h4&gt;&lt;p&gt;负责管理所有与时间相关的功能&lt;/p&gt;
&lt;h5 id=&#34;核心结构&#34;&gt;核心结构
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;Driver结构体，时间驱动的主要实现，负责
&lt;ul&gt;
&lt;li&gt;管理时间轮（time wheel）实例&lt;/li&gt;
&lt;li&gt;处理定时器的注册、取消和触发&lt;/li&gt;
&lt;li&gt;与I/O驱动协同工作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Inner&lt;/code&gt;和&lt;code&gt;InnerState&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;包含时间轮实例&lt;/li&gt;
&lt;li&gt;管理驱动状态（如是否已关闭）&lt;/li&gt;
&lt;li&gt;提供线程安全的内部状态访问&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;关键方法&#34;&gt;关键方法
&lt;/h5&gt;&lt;p&gt;process_at_time方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理当前时间点所有到期的定时器&lt;/li&gt;
&lt;li&gt;处理系统时间回退的情况&lt;/li&gt;
&lt;li&gt;批量唤醒等待的任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;reregister方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重新注册定时器到新的时间点&lt;/li&gt;
&lt;li&gt;线程安全的更新定时器&lt;/li&gt;
&lt;li&gt;处理驱动关闭的情况&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Park 线程挂起的实现</title>
        <link>http://localhost:1313/rust/tokio/park-%E7%BA%BF%E7%A8%8B%E6%8C%82%E8%B5%B7%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
        <pubDate>Wed, 10 Sep 2025 10:04:26 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/tokio/park-%E7%BA%BF%E7%A8%8B%E6%8C%82%E8%B5%B7%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
        <description>&lt;p&gt;&lt;code&gt;park.rs&lt;/code&gt;是Tokio运行时中用于线程挂起和恢复的核心。&lt;/p&gt;
&lt;h4 id=&#34;核心结构&#34;&gt;核心结构
&lt;/h4&gt;&lt;h5 id=&#34;parkthread-和-unparkthread&#34;&gt;ParkThread 和 UnParkThread
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;crate&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ParkThread&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  inner: &lt;span style=&#34;color:#a6e22e&#34;&gt;Arc&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Inner&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;crate&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;UnParkThread&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  inner: &lt;span style=&#34;color:#a6e22e&#34;&gt;Arc&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Inner&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;乍一看，这两根本就是相同的结构，但是它们是用在不同地方的，以及impl块有区别。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;tokio_thread_local!&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CURRENT_PARKER&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;ParkThread&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ParkThread::new();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是最重要的区别，&lt;code&gt;ParkThread&lt;/code&gt;用在了线程局部变量上，而&lt;code&gt;UnParkThread&lt;/code&gt;没有线程局部限制，另外&lt;code&gt;UnParkThread&lt;/code&gt;只实现了&lt;code&gt;unpark&lt;/code&gt;方法，目的是让其他线程只能唤醒。&lt;/p&gt;
&lt;h5 id=&#34;inner&#34;&gt;Inner
&lt;/h5&gt;&lt;p&gt;&lt;code&gt;Inner&lt;/code&gt;结构体使用原子操作管理线程状态，这种状态管理是构建无锁并发原语的基础。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;EMPTY&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;			&lt;span style=&#34;color:#75715e&#34;&gt;//初始状态或unpark状态
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;PARKED&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;		&lt;span style=&#34;color:#75715e&#34;&gt;//线程已挂起
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NOTIFIED&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;	&lt;span style=&#34;color:#75715e&#34;&gt;//线程已被通知唤醒
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Inner&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  state: &lt;span style=&#34;color:#a6e22e&#34;&gt;AtomicUsize&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  mutex: &lt;span style=&#34;color:#a6e22e&#34;&gt;Mutex&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;()&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  condvar: &lt;span style=&#34;color:#a6e22e&#34;&gt;Condvar&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;为什么直接用&lt;code&gt;Mutex&amp;lt;Usize&amp;gt;&lt;/code&gt;而是多用了一个&lt;code&gt;AtomicUsize&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AtomicUsize&lt;/code&gt;是无锁的，比获取 &lt;code&gt;Mutex&lt;/code&gt;快&lt;/li&gt;
&lt;li&gt;内存顺序保证&lt;/li&gt;
&lt;li&gt;状态更新使用原子操作，减少锁的持有时间&lt;/li&gt;
&lt;li&gt;锁粒度控制，&lt;code&gt;Mutex&lt;/code&gt;只保护条件变量的等待/通知时机&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;具体功能的实现&#34;&gt;具体功能的实现
&lt;/h4&gt;&lt;h5 id=&#34;park&#34;&gt;park()
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;park&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;self) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; self
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  		.state
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  		.compare_exchange(&lt;span style=&#34;color:#66d9ef&#34;&gt;NOTIFIED&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;EMPTY&lt;/span&gt;, SeqCst, SeqCst)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  		.is_ok() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// “虚假唤醒”保护，另一个线程unpark，此线程又park，避免了没必要的线程挂起和唤醒操作
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 获取锁,并修改状态至parked
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; m: &lt;span style=&#34;color:#a6e22e&#34;&gt;std&lt;/span&gt;::sync::MutexGuard&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&amp;#39;_, ()&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self.mutex.lock();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt; self.state.compare_exchange(&lt;span style=&#34;color:#66d9ef&#34;&gt;EMPTY&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;PARKED&lt;/span&gt;, SeqCst, SeqCst) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Ok(_) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Err(&lt;span style=&#34;color:#66d9ef&#34;&gt;NOTIFIED&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; old &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self.state.swap(&lt;span style=&#34;color:#66d9ef&#34;&gt;EMPTY&lt;/span&gt;, SeqCst);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;debug_assert_eq!&lt;/span&gt;(old, &lt;span style=&#34;color:#66d9ef&#34;&gt;NOTIFIED&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;park state changed unexpectedly&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Err(actual) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;panic!&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;inconsistent park state; actual = &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{actual}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;loop&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self.condvar.wait(m).unwrap(); &lt;span style=&#34;color:#75715e&#34;&gt;//释放锁并挂起线程等待notify
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; self
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    		.state
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    		.compare_exchange(&lt;span style=&#34;color:#66d9ef&#34;&gt;NOTIFIED&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;EMPTY&lt;/span&gt;, SeqCst, SeqCst)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    		.is_ok() 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;//确保有效唤醒，NOTIFIED -&amp;gt; EMPTY,忽略错误唤醒
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h6 id=&#34;双重检查模式&#34;&gt;双重检查模式
&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;第一次检查避免不必要的锁获取&lt;/li&gt;
&lt;li&gt;第二次检查处理竞态条件&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;虚假唤醒处理&#34;&gt;虚假唤醒处理
&lt;/h6&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;loop&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; self.condvar.wait(m).unwrap();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; self.state.compare_exchange(&lt;span style=&#34;color:#66d9ef&#34;&gt;NOTIFIED&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;EMPTY&lt;/span&gt;, SeqCst, SeqCst).is_ok() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个循环确保只有收到真正的通知才会返回，处理了条件变量的虚假唤醒问题。&lt;/p&gt;
&lt;h5 id=&#34;unpark&#34;&gt;unpark
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unpark&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;self) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;//无论什么状态都置为NOTIFIED
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt; self.state.swap(&lt;span style=&#34;color:#66d9ef&#34;&gt;NOTIFIED&lt;/span&gt;, SeqCst) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;EMPTY&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;NOTIFIED&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;PARKED&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    _ &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;panic!&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;inconsistent state in unpark&amp;#34;&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;//通过lock确保目标线程已经是PARKED了
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  drop(self.mutex.lock());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  self.condvar.notify_one();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过控制ParkThread和UnParkThread的方法，完成了功能分离，配合之前的&lt;code&gt;ThreadLocal&lt;/code&gt;,完成了线程自己挂起，然后其他线程可以唤醒此线程的功能。同时UnParkThread也可以转为&lt;code&gt;Waker&lt;/code&gt;。&lt;/p&gt;
&lt;h5 id=&#34;shutdown&#34;&gt;shutdown
&lt;/h5&gt;&lt;p&gt;通知线程该醒了，具体的shutdown操作由调用者处理。&lt;/p&gt;
&lt;h5 id=&#34;cachedparkthread&#34;&gt;CachedParkThread
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;缓存&lt;code&gt;Waker&lt;/code&gt;避免重复分配&lt;/li&gt;
&lt;li&gt;提供&lt;code&gt;block_on&lt;/code&gt;方法，这是运行时执行future的基础&lt;/li&gt;
&lt;li&gt;通过线程局部存储管理每个线程的parker&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_anchor: PhantomData&amp;lt;Rc&amp;lt;()&amp;gt;&amp;gt;&lt;/code&gt;隐含了&lt;code&gt;!Send + !Sync&lt;/code&gt;，CachedParkThread 不可跨线程。&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>Runtime逐文件阅读学习记录</title>
        <link>http://localhost:1313/rust/tokio/runtime%E9%80%90%E6%96%87%E4%BB%B6%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</link>
        <pubDate>Tue, 09 Sep 2025 00:20:36 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/tokio/runtime%E9%80%90%E6%96%87%E4%BB%B6%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</guid>
        <description>&lt;h4 id=&#34;thread_idrs&#34;&gt;thread_id.rs
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;主要类&lt;code&gt;ThreadId&lt;/code&gt;，其功能是为线程生成不重复的线程id&lt;/li&gt;
&lt;li&gt;主要学习到的内容
&lt;ul&gt;
&lt;li&gt;内存排序，Atomic类不仅是原子操作，还有内存排序的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;task_hooksrs&#34;&gt;task_hooks.rs
&lt;/h3&gt;&lt;h4 id=&#34;1-核心类型&#34;&gt;1. 核心类型
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;TaskCallback&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;crate&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TaskCallback&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std::sync::Arc&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;dyn&lt;/span&gt; Fn(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;TaskMeta&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&amp;#39;_&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; Send &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; Sync&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;表示一个任务回调函数&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;Arc&lt;/code&gt;实现引用计数，支持多线程共享&lt;/li&gt;
&lt;li&gt;接收&lt;code&gt;&amp;amp;TaskMeta&amp;lt;&#39;_&amp;gt;&lt;/code&gt;作为参数，包含任务元数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;TaskMeta&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TaskMeta&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;&amp;#39;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id: &lt;span style=&#34;color:#a6e22e&#34;&gt;super&lt;/span&gt;::task::Id,         &lt;span style=&#34;color:#75715e&#34;&gt;// 任务ID
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    spawned_at: &lt;span style=&#34;color:#a6e22e&#34;&gt;SpawnedAt&lt;/span&gt;,       &lt;span style=&#34;color:#75715e&#34;&gt;// 任务创建位置
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    _p: &lt;span style=&#34;color:#a6e22e&#34;&gt;std&lt;/span&gt;::marker::PhantomData&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;&amp;#39;a&lt;/span&gt; ()&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;包含任务的基本数据&lt;/li&gt;
&lt;li&gt;使用生命周期参数&lt;code&gt;&#39;a&lt;/code&gt;确保引用的有效性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;TaskHooks&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;crate&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TaskHooks&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;crate&lt;/span&gt;) task_spawn_callback: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;TaskCallback&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,  &lt;span style=&#34;color:#75715e&#34;&gt;//任务生成
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;crate&lt;/span&gt;) task_terminate_callback: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;TaskCallback&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, &lt;span style=&#34;color:#75715e&#34;&gt;//任务结束
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;#[cfg(tokio_unstable)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;crate&lt;/span&gt;) before_poll_callback: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;TaskCallback&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;#[cfg(tokio_unstable)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;crate&lt;/span&gt;) after_poll_callback: Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;TaskCallback&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;在任务不同的状态回调&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;processrs&#34;&gt;process.rs
&lt;/h4&gt;&lt;p&gt;主要解决Unix系统上孤儿进程回收问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过&lt;code&gt;GlobalOrphanQueue&lt;/code&gt;管理需要回收的进程&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;SignalDriver&lt;/code&gt;监听&lt;code&gt;SIGCHLD&lt;/code&gt;信号&lt;/li&gt;
&lt;li&gt;非阻塞地检查子进程状态&lt;/li&gt;
&lt;li&gt;孤儿进程指父进程已经终止或退出，但子进程仍在运行的进程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SIGCHLD&lt;/code&gt;是用于通知父进程其子进程状态发生变化的信号。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;parkrs&#34;&gt;park.rs
&lt;/h4&gt;&lt;p&gt;实现线程的挂起与唤醒&lt;/p&gt;
&lt;h4 id=&#34;driverrs&#34;&gt;driver.rs
&lt;/h4&gt;&lt;p&gt;在tokio运行时中扮演着聚合和管理不同I/O和系统事件驱动器的角色。主要处理线程的挂起和唤醒机制。&lt;/p&gt;
&lt;h5 id=&#34;1-驱动器聚合&#34;&gt;1. 驱动器聚合
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;它聚合了多种底层驱动器，包括I/O驱动器(&lt;code&gt;IoDriver&lt;/code&gt;)，信号驱动器(&lt;code&gt;SingalDriver&lt;/code&gt;)和事件驱动器(&lt;code&gt;TimeDriver&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2-唤醒挂起支持&#34;&gt;2. 唤醒/挂起支持
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;提供了&lt;code&gt;park()&lt;/code&gt;和&lt;code&gt;unpark()&lt;/code&gt;方法用于线程的挂起和唤醒&lt;/li&gt;
&lt;li&gt;&lt;code&gt;park()&lt;/code&gt;方法会使当前线程进入休眠状态，等待事件发生&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unpark()&lt;/code&gt;方法用于唤醒被挂起的线程&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;3-多模式支持&#34;&gt;3. 多模式支持
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;支持启用或禁用特定功能(如I/O驱动)的不同运行时配置&lt;/li&gt;
&lt;li&gt;例如，&lt;code&gt;IoStack&lt;/code&gt;枚举有&lt;code&gt;Enabled&lt;/code&gt;和&lt;code&gt;Disabled&lt;/code&gt;两种变体，分别对应启用和禁用I/O驱动的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;4-超时支持&#34;&gt;4. 超时支持
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;提供了&lt;code&gt;park_timeout()&lt;/code&gt;方法，允许线程唤醒在指定的超时后自动唤醒&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;5-优秀设计&#34;&gt;5. 优秀设计
&lt;/h5&gt;&lt;p&gt;关注点分离，&lt;code&gt;IoStack&lt;/code&gt;关注于parking,&lt;code&gt;IoHandle&lt;/code&gt;关注于unparking&lt;/p&gt;
&lt;h5 id=&#34;configrs&#34;&gt;config.rs
&lt;/h5&gt;&lt;p&gt;runtime命令配置，用于定制运行时行为。以下是各字段的详细说明&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;global_queue_interval: Option&amp;lt;u32&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制从全局/远程任务队列拉取任务的频率&lt;/li&gt;
&lt;li&gt;&lt;code&gt;None&lt;/code&gt;表示每次检查全局队列&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Some(n)&lt;/code&gt;表示每n个tick检查一次全局队列&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;event_interval: u32&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行定时器和I/O事件检查的频率&lt;/li&gt;
&lt;li&gt;较小的值提高响应性，但可能增加CPU使用率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;before_park: Option&amp;lt;Callback&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;工作线程挂起前执行的回调&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用于执行线程特定的清理或状态保存&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;after_unpark: Option&amp;lt;Callback&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;工作线程唤醒后执行的回调&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用于恢复线程特定状态或执行初始化&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;before_spawn: Option&amp;lt;TaskCallback&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个任务生成前执行的回调&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用于任务级别的监控或初始化&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;after_termination: Option&amp;lt;TaskCallback&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个任务终止后执行的回调&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用于资源清理或统计信息收集&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;before_poll: Option&amp;lt;TaskCallback&amp;gt;&lt;/code&gt;&lt;/strong&gt; (仅限 unstable 特性)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次 poll 操作前执行的回调&lt;/li&gt;
&lt;li&gt;用于性能分析或调试&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;after_poll: Option&amp;lt;TaskCallback&amp;gt;&lt;/code&gt;&lt;/strong&gt; (仅限 unstable 特性)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每次 poll 操作后执行的回调&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通常与 &lt;code&gt;before_poll&lt;/code&gt; 配对使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;LIFO 插槽相关配置&lt;/strong&gt;（代码片段中未完全显示）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用于优化任务调度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特别适用于消息传递等模式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;builderrs&#34;&gt;builder.rs
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Runtime&lt;/code&gt;核心构建配置&lt;/p&gt;
&lt;h5 id=&#34;io驱动&#34;&gt;&lt;strong&gt;I/O驱动&lt;code&gt;enable_io&lt;/code&gt;和&lt;code&gt;nevents&lt;/code&gt;&lt;/strong&gt;
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;enable_io&lt;/code&gt;：是否启用I/O驱动
&lt;ul&gt;
&lt;li&gt;启用时：支持异步I/O操作（如TCP/UDP套接字、文件I/O等）&lt;/li&gt;
&lt;li&gt;禁用时：相关API将不可用，减少运行时开销&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nevents&lt;/code&gt;： 每次轮询时处理的最大事件数
&lt;ul&gt;
&lt;li&gt;影响I/O吞吐量和响应性&lt;/li&gt;
&lt;li&gt;值越大，吞吐量可能越高，但延迟可能增加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;事件驱动enable_time&#34;&gt;事件驱动(&lt;code&gt;enable_time&lt;/code&gt;)
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;控制是否启用时间相关的功能&lt;/li&gt;
&lt;li&gt;启用时：
&lt;ul&gt;
&lt;li&gt;支持&lt;code&gt;tokio::time&lt;/code&gt;模块（如&lt;code&gt;sleep&lt;/code&gt;、&lt;code&gt;timeout&lt;/code&gt;等）&lt;/li&gt;
&lt;li&gt;允许使用定时器和时间相关的异步操作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;禁用时：
&lt;ul&gt;
&lt;li&gt;减少运行时开销&lt;/li&gt;
&lt;li&gt;事件相关&lt;code&gt;API&lt;/code&gt;将不可用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;时钟控制start_paused&#34;&gt;时钟控制(&lt;code&gt;start_paused&lt;/code&gt;)
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;控制运行时时钟的初始状态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;true&lt;/code&gt;：时钟从暂停状态开始
&lt;ul&gt;
&lt;li&gt;时间不会自动推进&lt;/li&gt;
&lt;li&gt;适用于测试，可以精确控制时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;false&lt;/code&gt;(默认)：使用系统时钟
&lt;ul&gt;
&lt;li&gt;时间正常流逝&lt;/li&gt;
&lt;li&gt;适用于生产环境&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;时间驱动time-wheel实现&#34;&gt;时间驱动(Time Wheel)实现
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;使用多级时间轮管理定时器&lt;/li&gt;
&lt;li&gt;每个时间轮有不同的精度，形成层级结构
&lt;ul&gt;
&lt;li&gt;第一级：毫秒级精度&lt;/li&gt;
&lt;li&gt;第二级：秒级精度&lt;/li&gt;
&lt;li&gt;更高层：分钟/小时级精度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优点：O(1) 时间复杂度插入/删除定时器&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;系统调用&#34;&gt;系统调用
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;主要使用 &lt;code&gt;timerfd&lt;/code&gt; (Linux) 或 &lt;code&gt;kqueue&lt;/code&gt; (macOS) 等系统级定时器&lt;/li&gt;
&lt;li&gt;与 I/O 多路复用集成，统一事件循环&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;与io驱动的集成&#34;&gt;与I/O驱动的集成
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 简化的时间轮结构
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TimeWheel&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 不同精度的时间轮
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    wheels: [Wheel; &lt;span style=&#34;color:#66d9ef&#34;&gt;LEVELS&lt;/span&gt;],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 当前时间
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    now: &lt;span style=&#34;color:#66d9ef&#34;&gt;u64&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>Runtime的核心概念</title>
        <link>http://localhost:1313/rust/tokio/runtime%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</link>
        <pubDate>Sat, 06 Sep 2025 18:53:34 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/tokio/runtime%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</guid>
        <description>&lt;h4 id=&#34;1-runtime基本架构&#34;&gt;1. Runtime基本架构
&lt;/h4&gt;&lt;p&gt;Tokio的runtime是异步应用的核心，主要负责：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任务调度&lt;/li&gt;
&lt;li&gt;I/O事件循环&lt;/li&gt;
&lt;li&gt;定时器管理&lt;/li&gt;
&lt;li&gt;线程池管理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;让我们看看runtime的主要组件：&lt;/p&gt;
&lt;h5 id=&#34;11-runtime结构体&#34;&gt;1.1 Runtime结构体
&lt;/h5&gt;&lt;p&gt;&lt;code&gt;Runtime&lt;/code&gt;结构体是整个异步运行时的入口点。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Runtime&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#e6db74&#34;&gt;/// Task scheduler
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;  scheduler: &lt;span style=&#34;color:#a6e22e&#34;&gt;Scheduler&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#e6db74&#34;&gt;/// handles to runtime, also contains driver handles
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;  handle: &lt;span style=&#34;color:#a6e22e&#34;&gt;Handle&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#e6db74&#34;&gt;/// Blocking pool handle, used to signal shutdown
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;  blocking_pool: &lt;span style=&#34;color:#a6e22e&#34;&gt;BlockingPool&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;2-核心组件&#34;&gt;2. 核心组件
&lt;/h4&gt;&lt;h5 id=&#34;21-scheduler&#34;&gt;2.1 scheduler
&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负责任务的调度和执行&lt;/li&gt;
&lt;li&gt;管理任务队列和任务状态&lt;/li&gt;
&lt;li&gt;决定任务的执行顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;设计原因&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将调度逻辑与运行时其他部分解耦&lt;/li&gt;
&lt;li&gt;支持不同的调度策略（单线程/多线程）&lt;/li&gt;
&lt;li&gt;使调度器可以独立测试和优化&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;22-handle&#34;&gt;2.2 handle
&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供对运行时的轻量级引用&lt;/li&gt;
&lt;li&gt;允许在运行时外部分发任务&lt;/li&gt;
&lt;li&gt;包含对I/O驱动、定时器等组件的访问&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;设计原因&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免直接暴露&lt;code&gt;Runtime&lt;/code&gt;的所有权&lt;/li&gt;
&lt;li&gt;允许多个地方持有对运行时的引用&lt;/li&gt;
&lt;li&gt;支持跨线程发送任务&lt;/li&gt;
&lt;li&gt;便于在异步代码中获取当前运行时&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;23-blockingpool&#34;&gt;2.3 BlockingPool
&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管理阻塞操作的工作线程池&lt;/li&gt;
&lt;li&gt;执行可能阻塞的操作，如文件I/O或CPU密集型计算&lt;/li&gt;
&lt;li&gt;防止阻塞操作影响异步任务调度&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;设计原因&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隔离阻塞操作，避免影响事件循环&lt;/li&gt;
&lt;li&gt;提供明确的API来处理阻塞操作&lt;/li&gt;
&lt;li&gt;允许控制阻塞操作的并发度&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3-整体设计考量&#34;&gt;3. 整体设计考量
&lt;/h4&gt;&lt;h5 id=&#34;1-关注点分离&#34;&gt;1. 关注点分离
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;scheduler&lt;/code&gt;处理任务调度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;handle&lt;/code&gt;提供运行时访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;blocking_pool&lt;/code&gt;处理阻塞操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2-所有权管理&#34;&gt;2. 所有权管理
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Runtime&lt;/code&gt;拥有所有资源的所有权&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Handle&lt;/code&gt;提供了共享访问的方式&lt;/li&gt;
&lt;li&gt;资源在&lt;code&gt;Runtime&lt;/code&gt;被drop时正确清理&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;3-性能优化&#34;&gt;3. 性能优化
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;轻量级的&lt;code&gt;Handle&lt;/code&gt;可以大量复制&lt;/li&gt;
&lt;li&gt;阻塞操作不会阻塞事件循环&lt;/li&gt;
&lt;li&gt;调度器可以根据需要选择单线程或多线程实现&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;4-灵活性&#34;&gt;4. 灵活性
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;支持不同的运行时配置&lt;/li&gt;
&lt;li&gt;可以扩展新的调度策略&lt;/li&gt;
&lt;li&gt;便于测试和模拟&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;handle为什么是runtime的轻量级引用&#34;&gt;Handle为什么是Runtime的轻量级引用
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Runtime&lt;/code&gt;中的&lt;code&gt;scheduler&lt;/code&gt;字段&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这是主要的&lt;code&gt;Scheduler&lt;/code&gt;实例&lt;/li&gt;
&lt;li&gt;它拥有任务队列和其他资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Handle&lt;/code&gt;中的引用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不是引用&lt;code&gt;Scheduler&lt;/code&gt;本身&lt;/li&gt;
&lt;li&gt;而是引用&lt;code&gt;Scheduler&lt;/code&gt;内部的共享状态&lt;/li&gt;
&lt;li&gt;这些状态通常是通过&lt;code&gt;Arc&lt;/code&gt;包装的独立结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;具体实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CurrentThread&lt;/code&gt;调度器可能使用&lt;code&gt;Rc&amp;lt;RefCell&amp;lt;...&amp;gt;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MultiThread&lt;/code&gt;调度器使用&lt;code&gt;Arc&lt;/code&gt;进行线程间共享&lt;/li&gt;
&lt;li&gt;这些内部结构在&lt;code&gt;Scheduler&lt;/code&gt;初始化创建&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有权关系&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CurrentThread&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 内部使用 Rc 共享状态
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    shared: &lt;span style=&#34;color:#a6e22e&#34;&gt;Rc&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Shared&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Handle&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 共享相同的 Rc&amp;lt;Shared&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    shared: &lt;span style=&#34;color:#a6e22e&#34;&gt;Rc&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Shared&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;创建Handle时，会克隆&lt;code&gt;Arc/Rc&lt;/code&gt;增加引用计数&lt;/li&gt;
&lt;li&gt;这样的设计体现了&lt;code&gt;Scheduler&lt;/code&gt;是&lt;code&gt;Runtime&lt;/code&gt;的核心&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;文件io为什么使用阻塞线程池&#34;&gt;文件I/O为什么使用阻塞线程池
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;网络I/O：现代操作系统提供了专门的非阻塞API（如Linux的epoll，macOS的kqueue）&lt;/li&gt;
&lt;li&gt;文件I/O：大多数操作系统的文件系统API底层仍然是阻塞的&lt;/li&gt;
&lt;li&gt;性能考量：文件操作通常比网络操作快得多；使用非阻塞API反而增加开销；磁盘I/O的延迟通常比网络I/O更可预测。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Waker和Context机制</title>
        <link>http://localhost:1313/rust/tokio/waker%E5%92%8Ccontext%E6%9C%BA%E5%88%B6/</link>
        <pubDate>Fri, 05 Sep 2025 18:51:54 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/tokio/waker%E5%92%8Ccontext%E6%9C%BA%E5%88%B6/</guid>
        <description>&lt;h4 id=&#34;基本概念&#34;&gt;基本概念
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Context&lt;/strong&gt;：提供异步任务执行的上下文信息，最重要的是包含Waker&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Waker&lt;/strong&gt;：用于唤醒被挂起的异步任务的机制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Poll&lt;/strong&gt;：Future的轮询状态, &lt;code&gt;Ready&lt;/code&gt;或&lt;code&gt;Pending&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;context的定义&#34;&gt;Context的定义
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Context&lt;/code&gt; 是Rust标准库中&lt;code&gt;std::task&lt;/code&gt;模块提供的结构体，它主要包含：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对&lt;code&gt;Waker&lt;/code&gt;的引用&lt;/li&gt;
&lt;li&gt;可选的任务本地存储&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在Tokio中，&lt;code&gt;Context&lt;/code&gt;主要用于：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Future &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; MyFuture {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Output&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;poll&lt;/span&gt;(self: &lt;span style=&#34;color:#a6e22e&#34;&gt;Pin&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; Self&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, cx: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Context&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&amp;#39;_&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Poll&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Self::Output&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 使用 cx.waker() 获取 Waker
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 当 I/O 未就绪时，保存 Waker 以便后续唤醒
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;waker的核心实现&#34;&gt;Waker的核心实现
&lt;/h4&gt;&lt;p&gt;在Tokio中，&lt;code&gt;Waker&lt;/code&gt;是异步任务通知机制的核心。先看看Tokio中的关键实现&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;super&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;WakerRef&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;&amp;#39;a&lt;/span&gt;, S: &amp;#39;static&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  waker: &lt;span style=&#34;color:#a6e22e&#34;&gt;ManuallyDrop&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Waker&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  _p: &lt;span style=&#34;color:#a6e22e&#34;&gt;PhantomData&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;&amp;#39;a&lt;/span&gt; Header, S)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;waker的创建&#34;&gt;Waker的创建
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;raw_waker&lt;/span&gt;(header: &lt;span style=&#34;color:#a6e22e&#34;&gt;NonNull&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Header&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;RawWaker&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; ptr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; header.as_ptr() &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  RawWaker::new(ptr, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WAKER_VTABLE&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;waker的vtable&#34;&gt;Waker的VTable
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WAKER_VTABLE&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;RawWakerVTable&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; RawWakerVTable::new(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    clone_waker,    &lt;span style=&#34;color:#75715e&#34;&gt;// 克隆 Waker
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    wake_by_val,    &lt;span style=&#34;color:#75715e&#34;&gt;// 消费 Waker 并唤醒任务
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    wake_by_ref,    &lt;span style=&#34;color:#75715e&#34;&gt;// 不消费 Waker 的情况下唤醒任务
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    drop_waker,     &lt;span style=&#34;color:#75715e&#34;&gt;// 释放 Waker 资源
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;waker的生命周期&#34;&gt;waker的生命周期
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;创建： 当任务被创建时，会创建一个对应的Waker&lt;/li&gt;
&lt;li&gt;唤醒：当I/O事件就绪或定时器触发&lt;/li&gt;
&lt;li&gt;消费：任务被唤醒后，Waker会被消费掉&lt;/li&gt;
&lt;li&gt;重建：如果需要再次唤醒任务，需要重新创建Waker&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;工作流程示例&#34;&gt;工作流程示例
&lt;/h4&gt;&lt;p&gt;简易的任务唤醒流程：&lt;/p&gt;
&lt;h5 id=&#34;1-任务创建&#34;&gt;1. 任务创建
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; task &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;//异步代码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;tokio::spawn(task);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;2-waker创建&#34;&gt;2. Waker创建
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;Tokio运行时为任务创建Waker&lt;/li&gt;
&lt;li&gt;Waker包含指向任务状态的指针&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;3-io注册&#34;&gt;3. I/O注册
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 当调用类似 TcpStream::read 时
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; ready &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ready!&lt;/span&gt;(self.io.poll_read_ready(cx)&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;4-任务挂起&#34;&gt;4. 任务挂起
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;如果I/O未就绪，保存Waker&lt;/li&gt;
&lt;li&gt;返回&lt;code&gt;Poll::Pending&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;5-事件就绪&#34;&gt;5. 事件就绪
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;I/O事件就绪，保存Waker&lt;/li&gt;
&lt;li&gt;事件循环调用保存的Waker的&lt;code&gt;wake()&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;6-任务恢复&#34;&gt;6. 任务恢复
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;Waker将任务放回就绪队列&lt;/li&gt;
&lt;li&gt;调度器再次轮询该任务&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Pin和Unpin</title>
        <link>http://localhost:1313/rust/tokio/pin%E5%92%8Cunpin/</link>
        <pubDate>Thu, 04 Sep 2025 15:03:11 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/tokio/pin%E5%92%8Cunpin/</guid>
        <description>&lt;h4 id=&#34;pin和unpin的基本概念&#34;&gt;Pin和Unpin的基本概念
&lt;/h4&gt;&lt;h5 id=&#34;pin的作用&#34;&gt;Pin的作用
&lt;/h5&gt;&lt;p&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;是一个包装器，用于固定(pin)内存中的值，防止它被移动。这对于自引用结构体和异步编程中的Future特别重要。&lt;/p&gt;
&lt;h5 id=&#34;unpin的特质&#34;&gt;Unpin的特质
&lt;/h5&gt;&lt;p&gt;&lt;code&gt;Unpin&lt;/code&gt;是一个自动派生的标记trait，表示类型可以安全地移出&lt;code&gt;Pin&lt;/code&gt;。大多数类型都自动实现了&lt;code&gt;Unpin&lt;/code&gt;。实现了&lt;code&gt;Unpin&lt;/code&gt;的类型可以安全地从&lt;code&gt;Pin&lt;/code&gt;中移出。&lt;/p&gt;
&lt;h4 id=&#34;asyncawait为何需要pin&#34;&gt;async/await为何需要Pin
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;async&lt;/code&gt;块可能包含自引用，&lt;code&gt;async&lt;/code&gt;转变为&lt;code&gt;Future&lt;/code&gt;结构体,它是一个状态机&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;.await&lt;/code&gt;暂停执行时，局部变量会保存在生成的Future中&lt;/li&gt;
&lt;li&gt;如果这些变量相互引用，移动Future会导致悬垂指针&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;生命周期管理层次&#34;&gt;生命周期管理层次
&lt;/h4&gt;&lt;h5 id=&#34;1-变量级别&#34;&gt;1. 变量级别
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;局部变量被移动到Future状态机中&lt;/li&gt;
&lt;li&gt;生命周期与Future实例绑定&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2-future级别&#34;&gt;2. Future级别
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;由执行器拥有和管理&lt;/li&gt;
&lt;li&gt;执行器决定何时poll，何时drop&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;3-执行器级别&#34;&gt;3. 执行器级别
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;管理所有Future的生命周期&lt;/li&gt;
&lt;li&gt;负责调度和管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;4-栈帧与状态机&#34;&gt;4. 栈帧与状态机
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;同步：变量生命周期由栈帧管理&lt;/li&gt;
&lt;li&gt;异步：变量生命周期由状态机管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;任务队列与future&#34;&gt;任务队列与Future
&lt;/h4&gt;&lt;h5 id=&#34;一次性移动&#34;&gt;一次性移动
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;Future被移动到执行器后，由Pin保证不会再次移动&lt;/li&gt;
&lt;li&gt;执行器内部使用指针来引用Future&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;任务队列的实现&#34;&gt;任务队列的实现
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 伪代码：任务队列中的 Future
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Task&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    future: &lt;span style=&#34;color:#a6e22e&#34;&gt;Pin&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;dyn&lt;/span&gt; Future&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Output &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ()&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; Send&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 任务队列存储的是 Box&amp;lt;Task&amp;gt;，而不是直接存储 Future
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; task_queue: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Task&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;.;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;工作窃取调度&#34;&gt;工作窃取调度
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;当任务在线程间转移时，转移的是&lt;code&gt;Box&amp;lt;Task&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Box&lt;/code&gt;的移动不会影响内部Future的内存地址&lt;/li&gt;
&lt;li&gt;Pin 保证的是 &lt;code&gt;Box&lt;/code&gt; 内部的 Future 不会被移出&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
