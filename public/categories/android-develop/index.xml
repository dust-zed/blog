<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Android-Develop on zed的博客</title><link>https://www.dust-zed.site/categories/android-develop/</link><description>Recent content in Android-Develop on zed的博客</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sat, 28 Jun 2025 12:15:42 +0800</lastBuildDate><atom:link href="https://www.dust-zed.site/categories/android-develop/index.xml" rel="self" type="application/rss+xml"/><item><title>Android打包apk流程</title><link>https://www.dust-zed.site/android-develop/android%E6%89%93%E5%8C%85apk%E6%B5%81%E7%A8%8B/</link><pubDate>Sat, 28 Jun 2025 12:15:42 +0800</pubDate><guid>https://www.dust-zed.site/android-develop/android%E6%89%93%E5%8C%85apk%E6%B5%81%E7%A8%8B/</guid><description>&lt;p>android应用的打包流程是将代码、资源文件、清单文件等编译和压缩成可在设备上安装的APK/AAB文件的过程。以下是详细步骤：&lt;/p>
&lt;h4 id="一主要流程">一、主要流程&lt;/h4>
&lt;h5 id="1-编写代码与资源管理">1. 编写代码与资源管理&lt;/h5>
&lt;ul>
&lt;li>创建&lt;code>/src&lt;/code>目录存放Kotlin/Java源码&lt;/li>
&lt;li>在&lt;code>/res&lt;/code>目录添加资源&lt;/li>
&lt;li>配置&lt;code>AndroidManifest.xml&lt;/code>(声明组件、权限等)。&lt;/li>
&lt;/ul>
&lt;h5 id="2-依赖管理">2. 依赖管理&lt;/h5>
&lt;ul>
&lt;li>在build.gradle中添加所需依赖库&lt;/li>
&lt;/ul>
&lt;h5 id="3-编译过程">3. 编译过程&lt;/h5>
&lt;ul>
&lt;li>编译代码： kotlin源码 → &lt;code>.class&lt;/code>字节码（javac/kotlinc）&lt;/li>
&lt;li>转换为Dex：&lt;code>.class&lt;/code>文件→ &lt;code>.dex&lt;/code>文件（&lt;code>d8&lt;/code>/&lt;code>dx&lt;/code>工具），用于Android的ART虚拟机&lt;/li>
&lt;li>编译资源：&lt;code>AAPT2&lt;/code>编译资源文件（&lt;code>res/&lt;/code> → 二进制格式），生成&lt;code>R.java&lt;/code>和临时资源包(&lt;code>.flat&lt;/code>)&lt;/li>
&lt;/ul>
&lt;h5 id="4打包与签名">4.打包与签名&lt;/h5>
&lt;ul>
&lt;li>合并资源： AAPT2链接编译后的资源，生成resources.arsc（资源索引表）和优化后的res/目录&lt;/li>
&lt;li>打包成APK：APK Builder将以下文件合并为未签名的APK：
&lt;ul>
&lt;li>编译后的字节码(&lt;code>.dex&lt;/code>)&lt;/li>
&lt;li>资源文件(&lt;code>res/&lt;/code> + &lt;code>resources.arsc&lt;/code>)&lt;/li>
&lt;li>&lt;code>AndroidManifest.xml&lt;/code>&lt;/li>
&lt;li>原生库(&lt;code>.so&lt;/code>，若有JNI)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>签名APK：使用签名证书(keystore)进行V1/V2/V3签名(通过&lt;code>apksigner&lt;/code> 或Gradle配置)&lt;/li>
&lt;/ul>
&lt;h5 id="5优化与对齐">5.优化与对齐&lt;/h5>
&lt;ul>
&lt;li>ZIP对齐：&lt;code>zipalign&lt;/code>优化APK文件结构(4字节对齐)，减少运行时内存占用&lt;/li>
&lt;li>生成最终的APK：输出&lt;code>app-release.apk&lt;/code>&lt;/li>
&lt;/ul>
&lt;h4 id="二名词解释">二、名词解释&lt;/h4>
&lt;h5 id="1-临时资源包">1. 临时资源包&lt;/h5>
&lt;p>在AAPT2（&lt;code>Android Asset Packaging Tool 2&lt;/code>）的资源预编译阶段会生成.flat文件，这些文件是中间产物&lt;/p>
&lt;ul>
&lt;li>独立编译：AAPT2将&lt;code>/res&lt;/code>目录下的每个资源文件单独编译成二进制格式的&lt;code>.flat&lt;/code>文件&lt;/li>
&lt;li>支持增量编译：若只修改了单个资源文件，只需重新编译该文件的.flat文件，避免全量编译，加快构建速度&lt;/li>
&lt;li>分阶段处理
&lt;ul>
&lt;li>编译阶段：资源→ &lt;code>.flat&lt;/code>文件&lt;/li>
&lt;li>链接阶段：合并所有&lt;code>.flat&lt;/code>文件 → 生成&lt;code>resources.arsc&lt;/code>和最终的&lt;code>res/&lt;/code>目录&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>优势
&lt;ul>
&lt;li>提升大型项目的编译速度&lt;/li>
&lt;li>支持资源混淆&lt;/li>
&lt;li>更严格的资源验证&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="2-对齐">2. 对齐&lt;/h5>
&lt;ul>
&lt;li>&lt;strong>内存对齐&lt;/strong>：解决CPU访问效率问题（&lt;code>数据项首地址 % n == 0&lt;/code>），但会增加数据结构大小&lt;/li>
&lt;li>&lt;strong>文件对齐(zipalign)&lt;/strong>:解决内存映射效率的问题（&lt;code>文件偏移 % 4096 == 0&lt;/code>），通过消除跨页碎片减少运行时内存占用&lt;/li>
&lt;li>&lt;strong>内存页机制&lt;/strong>
&lt;ul>
&lt;li>系统内存管理以**页(通常4KB)**为单位&lt;/li>
&lt;li>对齐后，每次文件读取 = 整数倍内存页 → &lt;strong>减少I/O次数&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Choreographer类解析</title><link>https://www.dust-zed.site/android-develop/choreographer%E7%B1%BB%E8%A7%A3%E6%9E%90/</link><pubDate>Mon, 16 Jun 2025 06:49:21 +0800</pubDate><guid>https://www.dust-zed.site/android-develop/choreographer%E7%B1%BB%E8%A7%A3%E6%9E%90/</guid><description>&lt;h4 id="一核心作用">一、核心作用&lt;/h4>
&lt;p>Choreographer是Android系统&lt;strong>协调动画、输入和绘制操作的核心调度器&lt;/strong>。它通过VSYNC信号确保帧的渲染与屏幕刷新率同步，避免画面撕裂和卡顿。&lt;/p>
&lt;h4 id="二关键概念">二、关键概念&lt;/h4>
&lt;ul>
&lt;li>VSYNC：垂直同步信号，表示屏幕开始刷新新的一帧&lt;/li>
&lt;li>Frame Callbacks：注册的回调函数，在下一帧的特定阶段执行&lt;/li>
&lt;li>Callback Types（按执行顺序排序）
&lt;ul>
&lt;li>CALLBACK_INPUT&lt;/li>
&lt;li>CALLBACK_ANIMATION&lt;/li>
&lt;li>CALLBACK_INSETS_ANIMATION&lt;/li>
&lt;li>CALLBACK_TRAVERSAL&lt;/li>
&lt;li>CALLBACK_COMMIT&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Choreographer&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 五种回调类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> CALLBACK_INPUT &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> CALLBACK_ANIMATION &lt;span style="color:#f92672">=&lt;/span> 1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> CALLBACK_INSETS_ANIMATION &lt;span style="color:#f92672">=&lt;/span> 2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> CALLBACK_TRAVERSAL &lt;span style="color:#f92672">=&lt;/span> 3;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> CALLBACK_COMMIT &lt;span style="color:#f92672">=&lt;/span> 4;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> CALLBACK_LAST &lt;span style="color:#f92672">=&lt;/span> CALLBACK_COMMIT; &lt;span style="color:#75715e">// 最后一种类型&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 单例模式实现&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> ThreadLocal&lt;span style="color:#f92672">&amp;lt;&lt;/span>Choreographer&lt;span style="color:#f92672">&amp;gt;&lt;/span> sThreadInstance &lt;span style="color:#f92672">=&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> ThreadLocal&lt;span style="color:#f92672">&amp;lt;&lt;/span>Choreographer&lt;span style="color:#f92672">&amp;gt;&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">protected&lt;/span> Choreographer &lt;span style="color:#a6e22e">initialValue&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Looper looper &lt;span style="color:#f92672">=&lt;/span> Looper.&lt;span style="color:#a6e22e">myLooper&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Choreographer(looper, VSYNC_SOURCE_APP);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 回调队列数组&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> CallbackQueue&lt;span style="color:#f92672">[]&lt;/span> mCallbackQueues;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// VSYNC 接收器&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> FrameDisplayEventReceiver mDisplayEventReceiver;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 处理消息的Handler&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> FrameHandler mHandler;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="三核心架构图解">三、核心架构图解&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-tex" data-lang="tex">&lt;span style="display:flex;">&lt;span>┌───────────────────────┐ ┌───────────────────────┐
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ VSYNC 信号源 │──────&amp;gt;│ FrameDisplayEventReceiver │
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└───────────────────────┘ │ (接收硬件VSYNC信号) │
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> └───────────┬───────────┘
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ▼
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>┌───────────────────────┐ ┌───────────────────────┐
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ FrameHandler │&amp;lt;──────│ onVsync() │
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ (处理3类消息) │──────&amp;gt;│ scheduleVsync() │
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└───────────┬───────────┘ └───────────────────────┘
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ▼
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>┌───────────────────────┐
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ doFrame() │
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ (帧处理核心方法) │
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└───────────┬───────────┘
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> │
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ▼
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>┌───────────────────────┐
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ CallbackQueue[] │
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>│ (5种类型回调链表) │
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└───────────────────────┘
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="三回调添加入口">三、回调添加入口&lt;/h4>
&lt;h5 id="1-添加回调入口">1. 添加回调入口&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">postCallback&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> callbackType, Runnable action, Object token) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> postCallbackDelayed(callbackType, action, token, 0);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">postCallbackDelayed&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> callbackType, Runnable action, &lt;span style="color:#66d9ef">long&lt;/span> delayMillis) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> postCallbackDelayedInternal(callbackType, action, token, delayMillis);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="2-内部添加实现">2. 内部添加实现&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">postCallbackDelayedInternal&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> callbackType,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Object action, Object token, &lt;span style="color:#66d9ef">long&lt;/span> delayMillis) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">synchronized&lt;/span> (mLock) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> now &lt;span style="color:#f92672">=&lt;/span> SystemClock.&lt;span style="color:#a6e22e">uptimeMillis&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> dueTime &lt;span style="color:#f92672">=&lt;/span> now &lt;span style="color:#f92672">+&lt;/span> delayMillis;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 1. 添加到对应的回调队列&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mCallbackQueues&lt;span style="color:#f92672">[&lt;/span>callbackType&lt;span style="color:#f92672">]&lt;/span>.&lt;span style="color:#a6e22e">addCallbackLocked&lt;/span>(dueTime, action, token);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 2. 调度帧处理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (dueTime &lt;span style="color:#f92672">&amp;lt;=&lt;/span> now) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 立即调度&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scheduleFrameLocked(now);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 延迟调度&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Message msg &lt;span style="color:#f92672">=&lt;/span> mHandler.&lt;span style="color:#a6e22e">obtainMessage&lt;/span>(MSG_DO_SCHEDULE_CALLBACK, action);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> msg.&lt;span style="color:#a6e22e">arg1&lt;/span> &lt;span style="color:#f92672">=&lt;/span> callbackType;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> msg.&lt;span style="color:#a6e22e">setAsynchronous&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mHandler.&lt;span style="color:#a6e22e">sendMessageAtTime&lt;/span>(msg, dueTime);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="3-回调链表结构">3. 回调链表结构&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CallbackQueue&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> CallbackRecord mHead;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">addCallbackLocked&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> dueTime, Object action, Object token) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CallbackRecord callback &lt;span style="color:#f92672">=&lt;/span> obtainCallbackLocked(dueTime, action, token);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (mHead &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mHead &lt;span style="color:#f92672">=&lt;/span> callback;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 链表按照执行时间排序（小到大）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (dueTime &lt;span style="color:#f92672">&amp;lt;&lt;/span> mHead.&lt;span style="color:#a6e22e">dueTime&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> callback.&lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#f92672">=&lt;/span> mHead;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mHead &lt;span style="color:#f92672">=&lt;/span> callback;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CallbackRecord entry &lt;span style="color:#f92672">=&lt;/span> mHead;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (entry.&lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (dueTime &lt;span style="color:#f92672">&amp;lt;&lt;/span> entry.&lt;span style="color:#a6e22e">next&lt;/span>.&lt;span style="color:#a6e22e">dueTime&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> callback.&lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#f92672">=&lt;/span> entry.&lt;span style="color:#a6e22e">next&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> entry.&lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#f92672">=&lt;/span> callback;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> entry &lt;span style="color:#f92672">=&lt;/span> entry.&lt;span style="color:#a6e22e">next&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> entry.&lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#f92672">=&lt;/span> callback;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 链表节点定义&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">CallbackRecord&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> CallbackRecord next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> dueTime;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Object action; &lt;span style="color:#75715e">// Runnable 或 FrameCallback&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Object token;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="四vsync同步机制">四、VSYNC同步机制&lt;/h4>
&lt;h5 id="1-vsync请求">1、 VSYNC请求&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">scheduleFrameLocked&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> now) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>mFrameScheduled) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mFrameScheduled &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (USE_VSYNC) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 通过 FrameDisplayEventReceiver 请求 VSYNC&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (isRunningOnLooperThreadLocked()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//注册&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scheduleVsyncLocked();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 非UI线程发送消息到UI线程&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Message msg &lt;span style="color:#f92672">=&lt;/span> mHandler.&lt;span style="color:#a6e22e">obtainMessage&lt;/span>(MSG_DO_SCHEDULE_VSYNC);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> msg.&lt;span style="color:#a6e22e">setAsynchronous&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mHandler.&lt;span style="color:#a6e22e">sendMessageAtFrontOfQueue&lt;/span>(msg);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 无VSYNC直接安排帧&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> nextFrameTime &lt;span style="color:#f92672">=&lt;/span> ...;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Message msg &lt;span style="color:#f92672">=&lt;/span> mHandler.&lt;span style="color:#a6e22e">obtainMessage&lt;/span>(MSG_DO_FRAME);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> msg.&lt;span style="color:#a6e22e">setAsynchronous&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mHandler.&lt;span style="color:#a6e22e">sendMessageAtTime&lt;/span>(msg, nextFrameTime);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">scheduleVsyncLocked&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mDisplayEventReceiver.&lt;span style="color:#a6e22e">scheduleVsync&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="2-vsync接收与处理">2. VSYNC接收与处理&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">FrameDisplayEventReceiver&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> DisplayEventReceiver {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">onVsync&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> timestampNanos, &lt;span style="color:#66d9ef">long&lt;/span> physicalDisplayId, &lt;span style="color:#66d9ef">int&lt;/span> frame) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 1. 计算正确的帧时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> now &lt;span style="color:#f92672">=&lt;/span> System.&lt;span style="color:#a6e22e">nanoTime&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> intendedFrameTimeNanos &lt;span style="color:#f92672">=&lt;/span> ...;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 2. 发送MSG_DO_FRAME消息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Message msg &lt;span style="color:#f92672">=&lt;/span> Message.&lt;span style="color:#a6e22e">obtain&lt;/span>(mHandler, MSG_DO_FRAME);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> msg.&lt;span style="color:#a6e22e">setAsynchronous&lt;/span>(&lt;span style="color:#66d9ef">true&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mHandler.&lt;span style="color:#a6e22e">sendMessageAtTime&lt;/span>(msg, intendedFrameTimeNanos &lt;span style="color:#f92672">/&lt;/span> NANOS_PER_MS);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="3-帧处理核心---doframe">3. 帧处理核心 - doFrame()&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">doFrame&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> frameTimeNanos, &lt;span style="color:#66d9ef">int&lt;/span> frame) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> startNanos;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">synchronized&lt;/span> (mLock) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 检查帧调度状态&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>mFrameScheduled) &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 计算跳帧情况&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">long&lt;/span> jitterNanos &lt;span style="color:#f92672">=&lt;/span> startNanos &lt;span style="color:#f92672">-&lt;/span> frameTimeNanos;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (jitterNanos &lt;span style="color:#f92672">&amp;gt;=&lt;/span> mFrameIntervalNanos) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> skippedFrames &lt;span style="color:#f92672">=&lt;/span> jitterNanos &lt;span style="color:#f92672">/&lt;/span> mFrameIntervalNanos;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 超过阈值打印警告日志&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (skippedFrames &lt;span style="color:#f92672">&amp;gt;=&lt;/span> SKIPPED_FRAME_WARNING_LIMIT) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Log.&lt;span style="color:#a6e22e">i&lt;/span>(TAG, &lt;span style="color:#e6db74">&amp;#34;Skipped &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> skippedFrames &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; frames!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> frameTimeNanos &lt;span style="color:#f92672">=&lt;/span> ...; &lt;span style="color:#75715e">// 调整帧时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mLastFrameTimeNanos &lt;span style="color:#f92672">=&lt;/span> frameTimeNanos;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mFrameScheduled &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 按优先级顺序执行回调&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mFrameInfo.&lt;span style="color:#a6e22e">markInputHandlingStart&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> doCallbacks(Choreographer.&lt;span style="color:#a6e22e">CALLBACK_INPUT&lt;/span>, frameTimeNanos);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mFrameInfo.&lt;span style="color:#a6e22e">markAnimationsStart&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> doCallbacks(Choreographer.&lt;span style="color:#a6e22e">CALLBACK_ANIMATION&lt;/span>, frameTimeNanos);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mFrameInfo.&lt;span style="color:#a6e22e">markPerformTraversalsStart&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> doCallbacks(Choreographer.&lt;span style="color:#a6e22e">CALLBACK_TRAVERSAL&lt;/span>, frameTimeNanos);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> doCallbacks(Choreographer.&lt;span style="color:#a6e22e">CALLBACK_COMMIT&lt;/span>, frameTimeNanos);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 清理工作&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="五回调执行处理">五、回调执行处理&lt;/h4>
&lt;h5 id="1-执行回调核心逻辑">1. 执行回调核心逻辑&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">doCallbacks&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> callbackType, &lt;span style="color:#66d9ef">long&lt;/span> frameTimeNanos) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CallbackRecord callbacks;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">synchronized&lt;/span> (mLock) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 提取所有到期的回调&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> now &lt;span style="color:#f92672">=&lt;/span> frameTimeNanos &lt;span style="color:#f92672">/&lt;/span> NANOS_PER_MS;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> callbacks &lt;span style="color:#f92672">=&lt;/span> mCallbackQueues&lt;span style="color:#f92672">[&lt;/span>callbackType&lt;span style="color:#f92672">]&lt;/span>.&lt;span style="color:#a6e22e">extractDueCallbacksLocked&lt;/span>(now);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (callbacks &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mCallbacksRunning &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 执行链表中的所有回调&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (CallbackRecord c &lt;span style="color:#f92672">=&lt;/span> callbacks; c &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>; c &lt;span style="color:#f92672">=&lt;/span> c.&lt;span style="color:#a6e22e">next&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 执行回调&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (c.&lt;span style="color:#a6e22e">action&lt;/span> &lt;span style="color:#66d9ef">instanceof&lt;/span> Runnable) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ((Runnable) c.&lt;span style="color:#a6e22e">action&lt;/span>).&lt;span style="color:#a6e22e">run&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ((FrameCallback) c.&lt;span style="color:#a6e22e">action&lt;/span>).&lt;span style="color:#a6e22e">doFrame&lt;/span>(frameTimeNanos);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">synchronized&lt;/span> (mLock) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 回收CallbackRecord对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> recycleCallbackRecordsLocked(callbacks);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mCallbacksRunning &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="2到期回调提取算法">2.到期回调提取算法&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>CallbackRecord &lt;span style="color:#a6e22e">extractDueCallbacksLocked&lt;/span>(&lt;span style="color:#66d9ef">long&lt;/span> now) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CallbackRecord callbacks &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CallbackRecord next &lt;span style="color:#f92672">=&lt;/span> mHead;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 遍历链表，找出所有dueTime&amp;lt;=now的节点&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (next &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> next.&lt;span style="color:#a6e22e">dueTime&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> now) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CallbackRecord temp &lt;span style="color:#f92672">=&lt;/span> next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> next &lt;span style="color:#f92672">=&lt;/span> next.&lt;span style="color:#a6e22e">next&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> temp.&lt;span style="color:#a6e22e">next&lt;/span> &lt;span style="color:#f92672">=&lt;/span> callbacks; &lt;span style="color:#75715e">// 新节点插入链表头部&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> callbacks &lt;span style="color:#f92672">=&lt;/span> temp; &lt;span style="color:#75715e">// 新链表头&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 更新原链表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mHead &lt;span style="color:#f92672">=&lt;/span> next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 返回的是倒序链表（最近加入的先执行）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> callbacks;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="六choreographer的其他作用">六、Choreographer的其他作用&lt;/h4>
&lt;h5 id="1-帧率监控">1. 帧率监控&lt;/h5>
&lt;p>开发者可以通过postFrameCallback实现帧率监控：&lt;/p></description></item><item><title>包体积优化</title><link>https://www.dust-zed.site/android-develop/%E5%8C%85%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96/</link><pubDate>Sun, 15 Jun 2025 23:19:59 +0800</pubDate><guid>https://www.dust-zed.site/android-develop/%E5%8C%85%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96/</guid><description>&lt;h4 id="包体积优化">包体积优化&lt;/h4>
&lt;h4 id="一apk结构分析工具">一、APK结构分析工具&lt;/h4>
&lt;ol>
&lt;li>Android Studio内置工具
&lt;ul>
&lt;li>使用 Build &amp;gt; Analyze APK&lt;/li>
&lt;li>查看各模块占比(代码/资源/原生库/Assets)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>命令行工具&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>./gradlew :app:assembleRelease --scan
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="二代码优化">二、代码优化&lt;/h4>
&lt;ol>
&lt;li>启用代码混淆与优化&lt;/li>
&lt;li>移除未使用代码
&lt;ul>
&lt;li>使用android studio的lint分析未使用代码&lt;/li>
&lt;li>添加R8配置文件删除无引用代码&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>方法数优化
&lt;ul>
&lt;li>启用Multidex前优化&lt;/li>
&lt;li>使用D8编译器的dex优化&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h4 id="三资源优化">三、资源优化&lt;/h4>
&lt;ol>
&lt;li>资源压缩与清理&lt;/li>
&lt;li>移除未使用资源&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 检测未使用资源&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./gradlew lintRelease
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 自动移除&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./gradlew removeUnusedResources
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>矢量图代替位图&lt;/li>
&lt;li>Webp格式转换&lt;/li>
&lt;/ol>
&lt;h4 id="四库优化">四、库优化&lt;/h4>
&lt;ol>
&lt;li>仅保留必要ABI&lt;/li>
&lt;li>轻量库代替&lt;/li>
&lt;/ol>
&lt;h4 id="五高级优化技术">五、高级优化技术&lt;/h4>
&lt;ol>
&lt;li>资源混淆&lt;/li>
&lt;li>资源分包加载&lt;/li>
&lt;li>按需加载功能模块&lt;/li>
&lt;/ol>
&lt;h4 id="六--assets优化">六 、 Assets优化&lt;/h4>
&lt;ol>
&lt;li>压缩assets资源：存储时压缩，使用时解压&lt;/li>
&lt;/ol>
&lt;h4 id="七知识补充">七、知识补充&lt;/h4>
&lt;ol>
&lt;li>D8、R8和代码混淆的关系
&lt;ul>
&lt;li>D8负责字节码到Dex的精确转换&lt;/li>
&lt;li>R8 = D8 + 裁剪 + 优化 + 混淆&lt;/li>
&lt;li>混淆是R8的战术武器：仅负责名称混淆（对体积影响小，对安全性关键）&lt;/li>
&lt;li>&lt;strong>开启R8 ≈ D8编译 + 三重优化(裁剪/优化/混淆)&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol></description></item><item><title>内存管理最佳实践</title><link>https://www.dust-zed.site/android-develop/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link><pubDate>Sun, 15 Jun 2025 13:05:49 +0800</pubDate><guid>https://www.dust-zed.site/android-develop/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid><description>&lt;h4 id="一内存管理原则">一、内存管理原则&lt;/h4>
&lt;ol>
&lt;li>理解Android内存模型
&lt;ul>
&lt;li>基于JVM垃圾回收机制，采用分代回收策略&lt;/li>
&lt;li>内存不足是触发&lt;code>onTrimMemory()&lt;/code>，开发者需响应此回调释放资源&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>避免内存泄漏根源
&lt;ul>
&lt;li>静态引用：禁止用static持有Activity/Context（用Application Context代替）&lt;/li>
&lt;li>非静态内部类：改用静态内部类+弱引用&lt;/li>
&lt;li>资源未释放：关闭Cursor、File、Bitmap等资源。gc只释放java对象本身，在jvm堆中，系统资源需要显示释放&lt;/li>
&lt;li>集合对象：及时清理无用的集合元素&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>优化关键组件
&lt;ul>
&lt;li>Activity/Fragment
&lt;ul>
&lt;li>在onDestroy中解除BroadcastReceiver、Handler注册，移除回调&lt;/li>
&lt;li>避免在异步任务中直接引用View&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Handler
&lt;ul>
&lt;li>使用静态内部类 + WeakReference。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>单例模式
&lt;ul>
&lt;li>传递Application Context，而非Activity Context&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>大对象优化
&lt;ul>
&lt;li>Bitmap
&lt;ul>
&lt;li>使用inSampleSize压缩图片，采用Glide等库管理内存&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>数据缓存
&lt;ul>
&lt;li>优先使用LruCache和DiskLruCache&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h4 id="二内存泄漏排查工具">二、内存泄漏排查工具&lt;/h4>
&lt;ol>
&lt;li>Android Profiler&lt;/li>
&lt;li>LeakCanary&lt;/li>
&lt;li>MAT&lt;/li>
&lt;li>StrictMode&lt;/li>
&lt;/ol>
&lt;h3 id="二内存泄漏排查工具-1">&lt;strong>二、内存泄漏排查工具&lt;/strong>&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>Android Profiler（Android Studio）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>内存监控&lt;/strong>：实时查看堆内存使用情况。&lt;/li>
&lt;li>&lt;strong>Heap Dump&lt;/strong>：捕获堆快照，分析对象引用链。&lt;/li>
&lt;li>&lt;strong>Allocation Tracker&lt;/strong>：跟踪短时间内的内存分配。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>LeakCanary（自动化检测）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>集成步骤：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-groovy" data-lang="groovy">&lt;span style="display:flex;">&lt;span>debugImplementation &lt;span style="color:#e6db74">&amp;#39;com.squareup.leakcanary:leakcanary-android:2.9.1&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>自动检测泄漏并生成报告，定位泄漏引用链。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>MAT（Memory Analyzer Tool）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>分析Heap Dump步骤：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>用Android Profiler导出&lt;code>.hprof&lt;/code>文件。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过&lt;code>hprof-conv&lt;/code>转换格式（Android SDK工具）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>hprof-conv input.hprof output.hprof
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>在MAT中打开，通过&lt;strong>Dominator Tree&lt;/strong>和&lt;strong>Path to GC Roots&lt;/strong>分析泄漏对象。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>StrictMode&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>检测主线程磁盘/网络操作，间接避免内存问题：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>StrictMode.&lt;span style="color:#a6e22e">setVmPolicy&lt;/span>(&lt;span style="color:#66d9ef">new&lt;/span> VmPolicy.&lt;span style="color:#a6e22e">Builder&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">detectActivityLeaks&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">detectLeakedClosableObjects&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">penaltyLog&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">build&lt;/span>());
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol></description></item><item><title>View性能优化</title><link>https://www.dust-zed.site/android-develop/view%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link><pubDate>Fri, 13 Jun 2025 23:55:35 +0800</pubDate><guid>https://www.dust-zed.site/android-develop/view%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid><description>&lt;h3 id="android-view-性能优化体系">Android View 性能优化体系&lt;/h3>
&lt;hr>
&lt;h3 id="一规避过度绘制gpu优化">一、规避过度绘制（GPU优化）&lt;/h3>
&lt;p>专注于减少GPU的无效像素填充负载&lt;/p>
&lt;ul>
&lt;li>&lt;strong>概念解析：&lt;/strong>&lt;br>
GPU在单个像素点重复绘制超过2.5次（1x绘制+1.5x半透明混合）的现象，消耗填充率导致帧率下降&lt;/li>
&lt;li>&lt;strong>检测工具：&lt;/strong>&lt;br>
&lt;code>开发者选项-&amp;gt;调试GPU过度绘制&lt;/code>（蓝色&amp;lt;1x, 绿色&amp;lt;2x, 粉色&amp;lt;3x, 红色≥4x）&lt;/li>
&lt;li>&lt;strong>核心策略：&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>移除无效背景层：&lt;/strong>
&lt;ul>
&lt;li>检查并移除Activity根布局或主题中冗余的&lt;code>windowBackground&lt;/code>&lt;/li>
&lt;li>删除被完全覆盖的中间层布局（如FrameLayout）背景&lt;/li>
&lt;li>避免在自定义View的&lt;code>onDraw()&lt;/code>中绘制被覆盖区域&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>层级扁平化：&lt;/strong>
&lt;ul>
&lt;li>使用&lt;code>ConstraintLayout&lt;/code>替代多层嵌套布局&lt;/li>
&lt;li>减少RelativeLayout导致的二次测量&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>透明效果控制：&lt;/strong>
&lt;ul>
&lt;li>避免大面积半透明视图（引发GPU混合计算）&lt;/li>
&lt;li>硬件层动画结束时立即禁用（&lt;code>setLayerType(LAYER_TYPE_NONE)&lt;/code>）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>引用关键通用技术：&lt;/strong>&lt;br>
结合&lt;code>clipRect/quickReject&lt;/code>限定绘制区域（详见通用技术章节）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="二绘制指令优化cpu优化">二、绘制指令优化（CPU优化）&lt;/h3>
&lt;p>降低CPU生成绘制指令的开销&lt;/p>
&lt;ul>
&lt;li>&lt;strong>优化焦点：&lt;/strong>&lt;br>
&lt;code>onDraw()&lt;/code>方法的执行效率与资源管理&lt;/li>
&lt;li>&lt;strong>核心准则：&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>禁止内存分配：&lt;/strong>&lt;br>
绝不在&lt;code>onDraw()&lt;/code>中创建Paint/Path/Bitmap对象（应在构造方法初始化）&lt;/li>
&lt;li>&lt;strong>规避耗时操作：&lt;/strong>&lt;br>
避免复杂计算、IO或解析逻辑&lt;/li>
&lt;li>&lt;strong>阻断递归触发：&lt;/strong>&lt;br>
禁止在&lt;code>onDraw()&lt;/code>中调用&lt;code>invalidate()&lt;/code>或&lt;code>requestLayout()&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>高级技巧：&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>绘图资源复用：&lt;/strong>&lt;br>
对矢量图(VectorDrawable)和位图采用不同优化策略
&lt;ul>
&lt;li>小图标优先使用矢量图&lt;/li>
&lt;li>位图加载启用&lt;code>inSampleSize&lt;/code>采样和&lt;code>RGB_565&lt;/code>解码&lt;/li>
&lt;li>使用&lt;code>ImageView.setImageDrawable()&lt;/code>替代&lt;code>canvas.drawBitmap()&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>透明效果实现：&lt;/strong>&lt;br>
优先使用&lt;code>View.setAlpha()&lt;/code>而非半透明背景色&lt;/li>
&lt;li>&lt;strong>引用关键通用技术：&lt;/strong>&lt;br>
精准控制硬件加速生命周期（详见通用技术章节）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="三通用核心技术">三、通用核心技术&lt;/h3>
&lt;p>跨优化领域的共性技术方案&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>区域裁剪技术：&lt;/strong>&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-mermaid" data-lang="mermaid">graph TB
 A[canvas.clipRect] --&amp;gt; B[限定子View绘制区域]
 C[canvas.quickReject] --&amp;gt; D[跳过屏幕外区域绘制]
 A--&amp;gt;|ViewGroup| E[重写dispatchDraw控制]
 C--&amp;gt;|自定义View| F[onDraw中预判可见性]
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>在&lt;code>ViewGroup.drawChild&lt;/code>中限定子View绘制边界&lt;/li>
&lt;li>列表项等非重叠视图必备优化手段&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>硬件加速深度指南：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>运作机制：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>将View缓存为GPU纹理(Texture)&lt;/li>
&lt;li>通过&lt;code>setLayerType(LAYER_TYPE_HARDWARE, null)&lt;/code>启用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>最佳实践：&lt;/strong>&lt;/p></description></item><item><title>关于硬件加速</title><link>https://www.dust-zed.site/android-develop/%E5%85%B3%E4%BA%8E%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/</link><pubDate>Fri, 13 Jun 2025 22:50:57 +0800</pubDate><guid>https://www.dust-zed.site/android-develop/%E5%85%B3%E4%BA%8E%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/</guid><description>&lt;h4 id="一硬件加速核心概念">一、硬件加速核心概念&lt;/h4>
&lt;p>硬件加速是将图形渲染中的光栅化从CPU转移到GPU执行的技术。CPU只需要生成&lt;strong>绘制指令集(DisplayList)&lt;/strong>，由GPU进行高效的并行光栅化计算，最终写入图形缓冲区提供屏幕显示。&lt;/p>
&lt;p>本质：CPU负责逻辑指令，GPU负责繁重像素计算，分工协作提升效率&lt;/p>
&lt;p>光栅化：可以高度抽象的概括为&lt;strong>计算屏幕上每个像素点最终显示的ARGB值&lt;/strong>&lt;/p>
&lt;h4 id="二硬件加速启用前后的核心流程对比">二、硬件加速启用前后的核心流程对比&lt;/h4>
&lt;ol>
&lt;li>&lt;strong>未启用硬件加速&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>measure &amp;amp; layout&lt;/strong>：由CPU在主线程（UI线程）执行&lt;/li>
&lt;li>&lt;strong>Draw&lt;/strong>（关键区别）：
&lt;ul>
&lt;li>CPU：遍历View树，在主线程直接执行每个View的onDraw(Canvas)方法&lt;/li>
&lt;li>光栅化：onDraw中的绘制指令也由CPU执行，直接计算出最终的像素值。&lt;/li>
&lt;li>缓冲区(Frame Buffer)
&lt;ul>
&lt;li>系统维护一个帧缓冲区。&lt;/li>
&lt;li>CPU光栅化好的像素数据直接写入这个帧缓冲区&lt;/li>
&lt;li>核心：CPU既处理逻辑计算又处理生成最终像素的繁重计算(光栅化)，然后把结果放进帧缓冲&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>合成 &amp;amp; 显示&lt;/strong>：屏幕读取帧缓冲区的内容显示到屏幕上。这个过程通常涉及双缓冲和Vsync信号来避免撕裂，但其绘制核心是CPU
&lt;ul>
&lt;li>Front Buffer是屏幕当前帧显示的内容，Back Buffer是屏幕下一帧要显示的内容&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>开启硬件加速&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>Measure &amp;amp; Layout&lt;/strong>：仍然由CPU在主线程执行。&lt;/li>
&lt;li>&lt;strong>Draw&lt;/strong>(关键区别)：
&lt;ul>
&lt;li>CPU：遍历View树，在主线程执行每个View的**&lt;code>onDraw(Canvas)&lt;/code>**方法。但是这里的&lt;code>Canvas&lt;/code>行为不同了&lt;/li>
&lt;li>Display List：onDraw(Canvas)中的绘制指令不再立即光栅化，而是被记录到DisplayList的数据结构中。DisplayList本质是一系列GPU能理解的绘图操作指令的序列化表示&lt;/li>
&lt;li>光栅化：由GPU执行，CPU将构建好的&lt;code>DisplayList&lt;/code>提交给GPU。GPU驱动程序将这些高级绘图指令&lt;strong>并行地、高效地光栅化&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>缓冲区&lt;/strong>(Frame Buffer / GRALLOC Buffers):
&lt;ul>
&lt;li>&lt;strong>普通开启硬件加速时的缓冲区：&lt;/strong> GPU 将光栅化&lt;strong>好的像素数据写入系统分配的图形缓冲区&lt;/strong> (通常是通过 &lt;code>Gralloc&lt;/code> 分配管理的 Buffer Queue 中的缓冲区，如 &lt;code>SurfaceTexture&lt;/code>)。这些缓冲区&lt;strong>就是屏幕最终合成时使用的像素数据源&lt;/strong>&lt;/li>
&lt;li>核心：CPU负责记录绘制命令(onDraw -&amp;gt; DisplayList)；GPU负责光栅化，结果写入图形缓冲区&lt;/li>
&lt;li>Frame Buffer是抽象的缓冲区，而GRALLOC Buffers是物理缓冲区&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h4 id="三启用硬件层">三、启用硬件层&lt;/h4>
&lt;ol>
&lt;li>&lt;strong>目的&lt;/strong>：对像素不会频繁变化的View采用空间换时间的方案，避免View内容未变时重复光栅化，用于后续快速合成&lt;/li>
&lt;li>&lt;strong>作用&lt;/strong>：仅当视图内容改变(&lt;code>invalidate()&lt;/code>)时或主动更新时：GPU重新光栅化该View的DisplayList -&amp;gt; 更新离屏纹理。而只涉及纹理的变换时，不会重新光栅化DisplayList，而是直接使用纹理缓存进行合成，纹理变换正是GPU擅长的。纹理变换和opengl管线工作流程中的顶点变换是不同的层级概念&lt;/li>
&lt;li>&lt;strong>最佳实践&lt;/strong>
&lt;ol>
&lt;li>适合&lt;strong>小面积静态视图&lt;/strong>或&lt;strong>属性动画&lt;/strong>&lt;/li>
&lt;li>避免对大视图（如列表视图）启用，易耗尽显存&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol></description></item><item><title>面试问题收集</title><link>https://www.dust-zed.site/android-develop/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/</link><pubDate>Fri, 13 Jun 2025 09:30:56 +0800</pubDate><guid>https://www.dust-zed.site/android-develop/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/</guid><description>&lt;h4 id="一bitmap内存优化">一、Bitmap内存优化&lt;/h4>
&lt;p>Bitmap是内存消耗大户，通过以下方法减少占用：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>降低色彩解析模式&lt;/strong>&lt;br>
使用RGB565等低色彩模式，将单个像素的字节大小从32位（ARGB8888）减少到16位，显著节省内存。&lt;/li>
&lt;li>&lt;strong>合理放置资源文件&lt;/strong>&lt;br>
高分辨率图片应放置在高密度目录（如&lt;code>drawable-xxhdpi&lt;/code>），避免系统自动缩放导致内存浪费。&lt;/li>
&lt;li>&lt;strong>缩小图片尺寸&lt;/strong>&lt;br>
加载时通过&lt;code>BitmapFactory.Options&lt;/code>动态调整采样率（&lt;code>inSampleSize&lt;/code>），或使用&lt;code>createScaledBitmap()&lt;/code>减少宽高尺寸。&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h4 id="二viewmodel与livedata机制">二、ViewModel与LiveData机制&lt;/h4>
&lt;p>ViewModel和LiveData是Jetpack组件，用于数据生命周期管理和响应式UI更新。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>粘性事件（Sticky Event）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>定义&lt;/strong>：当新观察者订阅&lt;code>LiveData&lt;/code>时，若已有存储值，会立即收到最后一次更新（旧数据）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>示例&lt;/strong>：屏幕旋转后，新Activity观察LiveData时触发UI更新（旧数据）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>来源&lt;/strong>：基于LiveData的版本号对比机制。代码关键部分如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">abstract&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">LiveData&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> mVersion &lt;span style="color:#f92672">=&lt;/span> START_VERSION; &lt;span style="color:#75715e">// LiveData当前版本（初始-1）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">LifecycleBoundObserver&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> ObserverWrapper {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> mLastVersion &lt;span style="color:#f92672">=&lt;/span> START_VERSION;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">considerNotify&lt;/span>(ObserverWrapper observer) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (observer.&lt;span style="color:#a6e22e">mLastVersion&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> mVersion) { &lt;span style="color:#75715e">// 核心判断：版本号落后才分发&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> observer.&lt;span style="color:#a6e22e">mLastVersion&lt;/span> &lt;span style="color:#f92672">=&lt;/span> mVersion;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> observer.&lt;span style="color:#a6e22e">mObserver&lt;/span>.&lt;span style="color:#a6e22e">onChanged&lt;/span>((T)data);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;strong>简单解法&lt;/strong>：使用&lt;code>Event&lt;/code>包装数据。事件消费后置空值，避免旧数据触发更新。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>ViewModel临时数据保存机制&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>内存中保存&lt;/strong>&lt;br>
ViewModel对象存储在&lt;code>ViewModelStore&lt;/code>中。当配置变更（如屏幕旋转）时：
&lt;ul>
&lt;li>Activity/Fragment被销毁重建。&lt;/li>
&lt;li>&lt;code>ViewModelStore&lt;/code>被系统保留（绑定到&lt;code>NonConfigurationInstances&lt;/code>）。&lt;/li>
&lt;li>新建Activity/Fragment时自动恢复ViewModel实例。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>数据范围与最佳实践&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>保留场景&lt;/strong>：屏幕旋转、分屏切换、系统语言更改。&lt;/li>
&lt;li>&lt;strong>不保留场景&lt;/strong>：用户退出应用、系统资源不足杀死进程、Activity被finish()。&lt;/li>
&lt;li>&lt;strong>最佳实践&lt;/strong>：
&lt;ol>
&lt;li>ViewModel解决配置变更的&lt;strong>临时数据保存&lt;/strong>（内存级）。&lt;/li>
&lt;li>&lt;code>SavedStateHandle&lt;/code>解决进程被杀死时的&lt;strong>关键数据持久化&lt;/strong>。&lt;/li>
&lt;li>复杂数据应使用数据库等持久化方案。&lt;/li>
&lt;li>避免内存泄漏：勿在ViewModel持有Context/View引用，必要时用&lt;code>Application Context&lt;/code>代替。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h4 id="三view基础原理">三、View基础原理&lt;/h4>
&lt;p>深入理解View的测量、布局、绘制机制，是优化UI性能的核心。&lt;/p>
&lt;ol>
&lt;li>&lt;strong>MeasureSpec计算与布局优化&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>MeasureSpec原理&lt;/strong>：父容器传递给子View的测量要求，由大小和模式组成，取决于父容器的MeasureSpec和子View的LayoutParams。
&lt;ul>
&lt;li>父布局根据自身MeasureSpec和子View LayoutParams，确定子View的MeasureSpec，再调用&lt;code>children.measure()&lt;/code>，最终确定自身尺寸。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>布局性能优化&lt;/strong>：
&lt;ul>
&lt;li>缓存MeasureSpec计算结果：固定尺寸View（如按钮）直接调用&lt;code>setMeasuredDimension()&lt;/code>设置宽高。&lt;/li>
&lt;li>优化布局流程：减少嵌套层级、懒加载布局、合并重复布局。&lt;/li>
&lt;li>避免无效重绘：使用局部刷新机制。&lt;/li>
&lt;li>精确控制绘制范围：通过&lt;code>Canvas.clipRect()&lt;/code>限制绘制区域。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>getMeasuredWidth()与getWidth()区别&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>getMeasuredWidth()&lt;/strong>：测量阶段后分配的宽度（含内边距）。
&lt;ul>
&lt;li>使用时机：&lt;code>onMeasure()&lt;/code>后或&lt;code>layout()&lt;/code>前。&lt;/li>
&lt;li>特点：反映视图的期望宽度；若布局未强制改变尺寸，可能与&lt;code>getWidth&lt;/code>相同。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>getWidth()&lt;/strong>：布局阶段后的最终可见宽度（屏幕实际值）。
&lt;ul>
&lt;li>使用时机：&lt;code>onLayout&lt;/code>后。&lt;/li>
&lt;li>计算方式：&lt;code>width = right - left&lt;/code>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>requestLayout()与invalidate()区别&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>requestLayout()&lt;/strong>：请求整个视图树的测量（measure）和布局（layout）流程。
&lt;ul>
&lt;li>触发场景：视图尺寸/位置变化、动态添加/移除子视图、&lt;code>setVisibility()&lt;/code>导致布局结构变化。&lt;/li>
&lt;li>执行流程：从当前视图向上回溯到根视图（如ViewRootImpl），依次执行measure → layout。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>invalidate()&lt;/strong>：仅标记视图的局部区域为“脏区”，请求下一帧重绘该区域。
&lt;ul>
&lt;li>触发场景：视图内容变化但不影响尺寸/位置（如&lt;code>onDraw()&lt;/code>依赖数据更新）。&lt;/li>
&lt;li>执行流程：标记脏区 → 加入重绘队列 → 下一帧VSync信号时调用&lt;code>onDraw()&lt;/code>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>View坐标体系&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>getX()/getY()&lt;/strong>：相对当前View左上角的局部坐标（触摸点在View内的位置）。
&lt;ul>
&lt;li>特点：与父容器无关；值可为负（如滑动超出View边界）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>getRawX()/getRawY()&lt;/strong>：相对屏幕左上角的全局坐标。
&lt;ul>
&lt;li>特点：包含状态栏高度（&lt;code>getRawY()&lt;/code>从屏幕顶部算起）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>getLocationOnScreen()&lt;/strong>：获取View左上角在屏幕上的绝对坐标。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>View生命周期关键方法&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>构造函数&lt;/strong>：通过代码或XML创建View实例。&lt;/li>
&lt;li>&lt;strong>onAttachedToWindow()&lt;/strong>：View被添加到窗口时调用。
&lt;ul>
&lt;li>用途：初始化资源、注册监听器、启动动画。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>onDetachedFromWindow()&lt;/strong>：View从窗口移除时调用（如Activity销毁）。
&lt;ul>
&lt;li>关键作用：释放资源、停止动画、注销监听器。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>注意事项&lt;/strong>：
&lt;ul>
&lt;li>&lt;code>onVisibilityChanged()&lt;/code>可能在&lt;code>onAttachedToWindow()&lt;/code>前/后调用（如View初始化为&lt;code>GONE&lt;/code>）。&lt;/li>
&lt;li>&lt;code>onWindowFocusChanged()&lt;/code>可能在&lt;code>onDetachedFromWindow()&lt;/code>后调用（避免在此访问资源）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>View性能优化&lt;/strong>
&lt;ol>
&lt;li>&lt;strong>过度绘制：&lt;/strong>
&lt;ul>
&lt;li>概念：GPU在一个像素点上绘制了多次的现象。系统默认允许2.5次（1x绘制 + 1.5x半透明混合）&lt;/li>
&lt;li>主要优化策略
&lt;ul>
&lt;li>移除不必要的背景&lt;/li>
&lt;li>减少View的层级深度&lt;/li>
&lt;li>谨慎使用半透明或**&lt;code>setLayerType(LAYER_TYPE_HARDWARE)&lt;/code>**&lt;/li>
&lt;li>优化&lt;code>clipRect&lt;/code>和&lt;code>quickReject&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>布局优化：&lt;/strong>
&lt;ul>
&lt;li>概念：指测量和布局阶段的性能优化。CPU需要遍历View树计算每个View的大小和位置&lt;/li>
&lt;li>优化策略：
&lt;ul>
&lt;li>减少嵌套层级&lt;/li>
&lt;li>使用高效布局标签（merge、include、ViewStub）&lt;/li>
&lt;li>优化&lt;code>onMeasure&lt;/code>/&lt;code>onLayout&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>绘制优化：&lt;/strong>
&lt;ul>
&lt;li>概念：指实际调用View.onDraw方法渲染像素到屏幕的性能优化。CPU准备绘制指令 -&amp;gt;GPU执行绘制&lt;/li>
&lt;li>优化策略
&lt;ul>
&lt;li>优化onDraw()方法：避免内存分配(不在onDraw方法内实例化Paint、Path、Bitmap、Rect对象)，避免耗时操作、避免调用invalidate（避免递归/绘制请求），利用canvas.clipRect和canvas.quickReject(),优先使用矢量图代替位图，使用硬件加速支持的Canvas操作&lt;/li>
&lt;li>谨慎开启Hardware_Layer&lt;/li>
&lt;li>优化alpha通道和透明度&lt;/li>
&lt;li>优化Bitmap加载与显示&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>高级机制与原理&lt;/strong>
&lt;ol>
&lt;li>硬件加速：将绘制指令交给GPU，但是部分api不支持&lt;/li>
&lt;li>SurfaceView与TextureView：todo&lt;/li>
&lt;li>view.post与Handler：todo&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h4 id="四事件分发机制">四、事件分发机制&lt;/h4>
&lt;ol>
&lt;li>&lt;strong>滑动实现方式&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>&lt;code>scrollTo()&lt;/code>/&lt;code>scrollBy()&lt;/code>&lt;/strong>: scrollTo()是直接跳转到指定位置，scrollBy是相对移动，基于当前位置滑动指定偏移量&lt;/li>
&lt;li>通过&lt;code>ViewDragHelper&lt;/code>实现复杂拖拽: todo&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>自定义下拉刷新控件&lt;/strong>
&lt;ul>
&lt;li>todo&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>事件分发机制如何提升效率&lt;/strong>
&lt;ul>
&lt;li>todo&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>嵌套滑动处理&lt;/strong>
&lt;ul>
&lt;li>todo&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>RecyclerView的滑动冲突处理&lt;/strong>
&lt;ul>
&lt;li>todo&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h4 id="五handler">五、Handler&lt;/h4>
&lt;ol>
&lt;li>&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h4 id="六性能优化-todo">六、性能优化 （todo）&lt;/h4>
&lt;ol>
&lt;li>&lt;strong>内存管理与泄漏排查&lt;/strong>&lt;/li>
&lt;li>&lt;strong>UI渲染性能(卡顿优化)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>启动速度优化&lt;/strong>&lt;/li>
&lt;li>&lt;strong>功耗优化基础&lt;/strong>&lt;/li>
&lt;li>&lt;strong>包体积优化&lt;/strong>&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h4 id="七常用库与框架todo">七、常用库与框架（todo）&lt;/h4>
&lt;ol>
&lt;li>&lt;strong>网络请求(如Retrofit)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>图片加载(如Glide / Picasso)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Gradle基础&lt;/strong>&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h4 id="八网络与后台">八、网络与后台&lt;/h4>
&lt;ol>
&lt;li>&lt;strong>RESTful API概念与使用&lt;/strong>&lt;/li>
&lt;li>&lt;strong>异步处理深入（线程安全、后台限制）&lt;/strong>&lt;/li>
&lt;li>&lt;strong>缓存策略&lt;/strong>&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h4 id="九架构设计">九、架构设计&lt;/h4>
&lt;ol>
&lt;li>MVVM/MVI理解与实践&lt;/li>
&lt;li>模块化 / 组件化&lt;/li>
&lt;li>设计模式应用&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h4 id="十新技术与趋势">十、新技术与趋势&lt;/h4>
&lt;ol>
&lt;li>Compose&lt;/li>
&lt;li>KMM / Flutter&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h4 id="十一jvm--内存模型基础">十一、JVM / 内存模型基础&lt;/h4>
&lt;ol>
&lt;li>JVM内存结构&lt;/li>
&lt;li>垃圾回收机制基础&lt;/li>
&lt;li>常见数据结构与基础算法&lt;/li>
&lt;/ol></description></item><item><title>RecyclerView缓存机制</title><link>https://www.dust-zed.site/android-develop/recyclerview%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</link><pubDate>Wed, 11 Jun 2025 15:26:57 +0800</pubDate><guid>https://www.dust-zed.site/android-develop/recyclerview%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</guid><description>&lt;p>RecyclerView缓存机制&lt;/p>
&lt;h4 id="多级缓存体系架构图">&lt;strong>多级缓存体系架构图&lt;/strong>&lt;/h4>
&lt;pre tabindex="0">&lt;code>TEXT

RecyclerView 缓存系统
├── 1. 屏幕内缓存 (Attached Scrap)
│ └── 存放当前可见的ViewHolder（快速复用）
├── 2. 屏幕外缓存 (Cache)
│ └── 保存最近离开屏幕的ViewHolder（默认容量=2）
├── 3. 扩展缓存 (ViewCacheExtension)
│ └── 开发者自定义缓存（特殊用途）
└── 4. 回收池 (RecycledViewPool)
 └── 全局共享的ViewHolder存储（不同类型独立缓存）
&lt;/code>&lt;/pre>&lt;p>根据&lt;code>position&lt;/code>判断是否命中&lt;code>Cache&lt;/code>，根据&lt;code>viewType&lt;/code>判断是否命中&lt;code>RecyclerViewPool&lt;/code>，会执行&lt;code>onBindViewHolder&lt;/code>&lt;/p>
&lt;p>在 &lt;strong>RecyclerView&lt;/strong> 的回收复用机制中，&lt;code>changedScrap&lt;/code> 和 &lt;code>attachedScrap&lt;/code> 是两个关键临时缓存，而 &lt;strong>Stable IDs&lt;/strong> 会改变 ViewHolder 获取的方式。以下是详细解释：&lt;/p>
&lt;hr>
&lt;h3 id="1">&lt;strong>1. &lt;code>changedScrap&lt;/code> 的作用&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>用途&lt;/strong>：专门配合 &lt;code>notifyItemChanged()&lt;/code> 或 &lt;code>notifyDataSetChanged()&lt;/code> 使用。&lt;/li>
&lt;li>&lt;strong>工作机制&lt;/strong>：
&lt;ul>
&lt;li>当调用 &lt;code>notifyItemChanged(position)&lt;/code> 时，被标记更新的 item 会被临时移到 &lt;code>changedScrap&lt;/code> 中。&lt;/li>
&lt;li>在布局阶段（如 &lt;code>onLayout&lt;/code>），这些 ViewHolder 会被重新绑定数据（调用 &lt;code>onBindViewHolder()&lt;/code>），然后放回原位置。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>目的&lt;/strong>：支持局部更新动画（如淡入淡出），避免直接回收导致视觉中断。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="2">&lt;strong>2. &lt;code>attachedScrap&lt;/code> 的作用&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>用途&lt;/strong>：用于 &lt;strong>快速复用可见或即将可见的 ViewHolder&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>工作机制&lt;/strong>：
&lt;ul>
&lt;li>在布局过程中（如 &lt;code>LinearLayoutManager.fill()&lt;/code>），RecyclerView 会先将当前屏幕上的 ViewHolder &lt;strong>临时移除&lt;/strong> 到 &lt;code>attachedScrap&lt;/code>。&lt;/li>
&lt;li>遍历新布局时，直接从 &lt;code>attachedScrap&lt;/code> 中按 &lt;strong>position 匹配&lt;/strong> 取回 ViewHolder（无需创建或绑定）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>目的&lt;/strong>：避免无效的创建/绑定，提升滚动性能（尤其在快速滑动时）。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="3-stable-ids-如何改变-viewholder-获取方式">&lt;strong>3. Stable IDs 如何改变 ViewHolder 获取方式&lt;/strong>&lt;/h3>
&lt;p>当启用 &lt;strong>Stable IDs&lt;/strong>（通过 &lt;code>setHasStableIds(true)&lt;/code> + 重写 &lt;code>getItemId()&lt;/code>）时：&lt;/p></description></item></channel></rss>