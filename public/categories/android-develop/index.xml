<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Android-Develop on zed的博客</title>
        <link>http://localhost:1313/categories/android-develop/</link>
        <description>Recent content in Android-Develop on zed的博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Wed, 15 Oct 2025 11:55:59 +0800</lastBuildDate><atom:link href="http://localhost:1313/categories/android-develop/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Android_rust混合开发入门</title>
        <link>http://localhost:1313/android-develop/android_rust%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</link>
        <pubDate>Wed, 15 Oct 2025 11:55:59 +0800</pubDate>
        
        <guid>http://localhost:1313/android-develop/android_rust%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/</guid>
        <description>&lt;h4 id=&#34;什么是ndk&#34;&gt;什么是NDK?
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;NDK = Native Development Kit(原生开发工具包)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一句话解释&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;NDK 是 Android 提供的工具集,让你能用 &lt;strong&gt;C/C++/Rust&lt;/strong&gt; 等原生语言开发 Android 应用的一部分&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;android应用的两种开发方式&#34;&gt;Android应用的两种开发方式
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;┌─────────────────────────────────────────┐&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;         Android &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;应用&lt;/span&gt;                     &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;├─────────────────────────────────────────┤&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;                                         &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;方式&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;Java&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;Kotlin (Android &lt;span style=&#34;color:#66d9ef&#34;&gt;SDK&lt;/span&gt;)      &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;┌──────────────────────────────────┐&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  Kotlin&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;Java &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;代码&lt;/span&gt;                &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;↓&lt;/span&gt;                               &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;编译为&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;DEX&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;字节码&lt;/span&gt;               &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;↓&lt;/span&gt;                               &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;在&lt;/span&gt; Dalvik&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ART&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;虚拟机运行&lt;/span&gt;        &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;└──────────────────────────────────┘&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;                                         &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;方式&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;C&lt;span style=&#34;color:#f92672&#34;&gt;++/&lt;/span&gt;Rust (Android &lt;span style=&#34;color:#66d9ef&#34;&gt;NDK&lt;/span&gt;)       &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;┌──────────────────────────────────┐&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  C&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;C&lt;span style=&#34;color:#f92672&#34;&gt;++/&lt;/span&gt;Rust &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;代码&lt;/span&gt;                 &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;↓&lt;/span&gt;                               &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;编译为&lt;/span&gt; .so &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;文件&lt;/span&gt; (&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;机器码&lt;/span&gt;)        &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;↓&lt;/span&gt;                               &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;直接在&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CPU&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;上运行&lt;/span&gt; (&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;无虚拟机&lt;/span&gt;)    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;└──────────────────────────────────┘&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;                                         &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;  &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;两者通过&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;JNI&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;桥接&lt;/span&gt;                      &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;└─────────────────────────────────────────┘&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;为什么需要ndk&#34;&gt;为什么需要NDK？
&lt;/h4&gt;&lt;h5 id=&#34;对比理解&#34;&gt;对比理解
&lt;/h5&gt;&lt;p&gt;纯 &lt;strong&gt;Java/Kotlin(SDK):&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;优点&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;✅&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;开发简单&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;✅&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;跨设备兼容好&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;✅&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;调试方便&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;缺点&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;❌&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;性能有限&lt;/span&gt; (&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;虚拟机开销&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;❌&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;某些功能无法实现&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;❌&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;无法复用&lt;/span&gt; C&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;C&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;库&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;NDK(C/C++/Rust)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;优点&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;✅&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;性能极高&lt;/span&gt; (&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;接近机器码&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;✅&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;可以复用现有&lt;/span&gt; C&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;C&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;库&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;✅&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;直接访问硬件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;✅&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;跨平台代码复用&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;缺点&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;❌&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;开发复杂&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;❌&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;调试困难&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;❌&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;需要为不同&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CPU&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;编译&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h4 id=&#34;ndk工作原理&#34;&gt;NDK工作原理
&lt;/h4&gt;&lt;h5 id=&#34;完整流程&#34;&gt;完整流程
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;第&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;步&lt;/span&gt;: &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;写&lt;/span&gt; Rust &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;代码&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;┌────────────────────────┐&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// Rust 代码           │
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(a: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;, b: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;     a &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b              &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt; }                      &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;└────────────────────────┘&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;↓&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;第&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;步&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;NDK&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;编译&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;┌────────────────────────┐&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;NDK&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;工具链编译&lt;/span&gt;          &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;交叉编译&lt;/span&gt;              &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;针对&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ARM&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;x86 &lt;span style=&#34;color:#66d9ef&#34;&gt;CPU&lt;/span&gt;     &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;└────────────────────────┘&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;↓&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;第&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;步&lt;/span&gt;: &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;生成&lt;/span&gt; .so &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;┌────────────────────────┐&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt; librust_lib.so          &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt; (&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;机器码&lt;/span&gt;,&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;可直接运行&lt;/span&gt;)     &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;└────────────────────────┘&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;↓&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;第&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;步&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;Android&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;加载&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;┌────────────────────────┐&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt; System.loadLibrary(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;rust_lib&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;                        &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt; external fun add(a: &lt;span style=&#34;color:#a6e22e&#34;&gt;Int&lt;/span&gt;, b: &lt;span style=&#34;color:#a6e22e&#34;&gt;Int&lt;/span&gt;): &lt;span style=&#34;color:#a6e22e&#34;&gt;Int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;└────────────────────────┘&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;         &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;↓&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;第&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;步&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;JNI&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;调用&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;┌────────────────────────┐&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt; Kotlin &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;→&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;JNI&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;→&lt;/span&gt; Rust    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt; val result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; add(&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;) &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// result = 8          │
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;└────────────────────────┘&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h4 id=&#34;ndk包含什么&#34;&gt;NDK包含什么？
&lt;/h4&gt;&lt;h5 id=&#34;ndk工具集&#34;&gt;NDK工具集
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;$ANDROID_NDK_HOME&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;├──&lt;/span&gt; build&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;              # &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;构建脚本&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;├──&lt;/span&gt; toolchains&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;         # &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;编译器工具链&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;   &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;├──&lt;/span&gt; aarch64&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;linux&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;android&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;  # &lt;span style=&#34;color:#66d9ef&#34;&gt;ARM64&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;编译器&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;   &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;├──&lt;/span&gt; arm&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;linux&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;androideabi&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;  # &lt;span style=&#34;color:#66d9ef&#34;&gt;ARM32&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;编译器&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;   &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;├──&lt;/span&gt; x86&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;                    # x86 &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;编译器&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;│&lt;/span&gt;   &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;└──&lt;/span&gt; x86_64&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;                 # x86_64 &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;编译器&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;├──&lt;/span&gt; platforms&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;          # Android &lt;span style=&#34;color:#66d9ef&#34;&gt;API&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;级别的头文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;├──&lt;/span&gt; sources&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;           # &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;示例代码&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;└──&lt;/span&gt; sysroot&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;           # &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;系统库&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;编译器&#34;&gt;编译器
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;NDK&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;提供了针对不同&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;CPU&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;架构的编译器&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ARM64&lt;/span&gt; (arm64&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;v8a):     &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;现代手机&lt;/span&gt; (&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;主流&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ARM32&lt;/span&gt; (armeabi&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;v7a):   &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;老手机&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;x86:                   &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;模拟器&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;x86_64:                &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;模拟器&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h4 id=&#34;so文件是什么&#34;&gt;.so文件是什么？
&lt;/h4&gt;&lt;h5 id=&#34;理解so文件&#34;&gt;理解.so文件
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.so &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Shared Object (&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;共享对象&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;类似于&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; Windows &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;的&lt;/span&gt; .dll &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; macOS &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;的&lt;/span&gt; .dylib &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;作用&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;包含编译后的机器码&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;可以被多个程序共享使用&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;so文件示例&#34;&gt;.so文件示例
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 查看 .so 文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ls android/app/src/main/jniLibs/arm64-v8a/
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# librust_lib.so  ← 这就是编译后的 Rust 代码&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 查看文件信息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;file librust_lib.so
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# librust_lib.so: ELF 64-bit LSB shared object, ARM aarch64, ...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 查看导出的函数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;nm -D librust_lib.so | grep Java
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Java_com_example_rustdemo_RustBridge_add&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Java_com_example_rustdemo_RustBridge_reverseString&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h4 id=&#34;ndk开发流程&#34;&gt;NDK开发流程
&lt;/h4&gt;&lt;h5 id=&#34;完整开发流程&#34;&gt;完整开发流程
&lt;/h5&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1. 安装 NDK
   ↓
   Android Studio → SDK Manager → SDK Tools → NDK

2. 配置环境
   ↓
   export ANDROID_NDK_HOME=/path/to/ndk

3. 编写原生代码 (C/C++/Rust)
   ↓
   例如: add.c, image.cpp, search.rs

4. 使用 NDK 编译
   ↓
   ndk-build  (C/C++)
   cargo-ndk  (Rust)

5. 生成 .so 文件
   ↓
   libmylib.so

6. 放入 jniLibs 目录
   ↓
   app/src/main/jniLibs/arm64-v8a/libmylib.so

7. Kotlin 加载和调用
   ↓
   System.loadLibrary(&amp;#34;mylib&amp;#34;)
   external fun add(a: Int, b: Int): Int
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h4 id=&#34;ndk核心概念&#34;&gt;NDK核心概念
&lt;/h4&gt;&lt;h5 id=&#34;jnijava-native-interface&#34;&gt;JNI(Java Native Interface)
&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;JNI&lt;/strong&gt;是桥梁:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;┌──────────────┐         ┌──────────────┐
│   Kotlin     │   JNI   │   Rust       │
│   (虚拟机)    │ ◄─────► │   (原生码)    │
└──────────────┘         └──────────────┘

数据传递:
Kotlin Int      ↔  Rust i32
Kotlin String   ↔  Rust String
Kotlin IntArray ↔  Rust &amp;amp;[i32]
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;交叉编译&#34;&gt;交叉编译
&lt;/h5&gt;&lt;p&gt;什么是交叉编译?&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;你在&lt;/span&gt; x86_64 &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;电脑上开发&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;↓&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;但手机是&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ARM64&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;架构&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;↓&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;需要&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;交叉编译&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;在&lt;/span&gt; x86_64 &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;上编译出&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;ARM64&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;代码&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;↓&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;NDK&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;提供了交叉编译工具链&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;abiapplication-binary-interface&#34;&gt;ABI(Application Binary Interface)
&lt;/h5&gt;&lt;p&gt;不同&lt;strong&gt;CPU&lt;/strong&gt;需要不同的**.so**文件:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;arm64-v8a/libmylib.so    → ARM64 手机
armeabi-v7a/libmylib.so  → ARM32 手机
x86/libmylib.so          → x86 模拟器
x86_64/libmylib.so       → x86_64 模拟器
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h4 id=&#34;什么时候用ndk&#34;&gt;什么时候用NDK?
&lt;/h4&gt;&lt;h5 id=&#34;应该用ndk的场景&#34;&gt;应该用NDK的场景
&lt;/h5&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1. 性能关键代码
   - 图像/视频处理
   - 音频处理
   - 大量数学计算
   - 加密/解密

2. 复用现有代码
   - 已有 C/C++ 库
   - 跨平台代码 (iOS/Android 共享)

3. 保护核心算法
   - 防止反编译
   - 商业逻辑保护

4. 访问底层功能
   - 硬件控制
   - 系统调用
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;不应该用ndk的场景&#34;&gt;不应该用NDK的场景
&lt;/h5&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1. 简单业务逻辑
   - 按钮点击
   - 数据展示
   - 网络请求

2. 快速开发
   - 原型验证
   - MVP 阶段

3. 团队不熟悉 C/C++/Rust
   - 维护成本高
   - Bug 难以调试
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h4 id=&#34;ndk开发工具&#34;&gt;NDK开发工具
&lt;/h4&gt;&lt;h5 id=&#34;必备工具&#34;&gt;必备工具
&lt;/h5&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1. Android NDK
   - 下载: Android Studio SDK Manager

2. CMake (C/C++) 或 cargo-ndk (Rust)
   - cargo install cargo-ndk

3. LLDB (调试器)
   - Android Studio 内置
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;辅助工具&#34;&gt;辅助工具
&lt;/h5&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 查看 .so 文件信息
readelf -h libmylib.so

# 查看导出的函数
nm -D libmylib.so

# 反汇编 (调试用)
objdump -d libmylib.so
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h4 id=&#34;总结&#34;&gt;总结
&lt;/h4&gt;&lt;h5 id=&#34;ndk是什么&#34;&gt;NDK是什么？
&lt;/h5&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;NDK = 让你用 C/C++/Rust 开发 Android 的工具包

作用:
1. 提供交叉编译工具链
2. 编译出 .so 机器码文件
3. 通过 JNI 与 Kotlin 交互
4. 获得原生性能

适用场景:
- 高性能计算
- 复用 C/C++ 库
- 跨平台开发
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;关键概念&#34;&gt;关键概念
&lt;/h5&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;NDK:   工具包
JNI:   桥梁 (Kotlin ↔ 原生代码)
.so:   编译后的机器码
ABI:   不同 CPU 架构

流程:
Rust 代码 → NDK 编译 → .so 文件 → JNI 调用 → Kotlin 使用
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Android事件分发机制详解</title>
        <link>http://localhost:1313/android-develop/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</link>
        <pubDate>Tue, 02 Sep 2025 21:41:39 +0800</pubDate>
        
        <guid>http://localhost:1313/android-develop/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</guid>
        <description>&lt;h4 id=&#34;1-事件分发的基本流程&#34;&gt;1. 事件分发的基本流程
&lt;/h4&gt;&lt;h5 id=&#34;11-事件传递顺序&#34;&gt;1.1 事件传递顺序
&lt;/h5&gt;&lt;p&gt;事件从Activity开始，按照一下顺序传递：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Activity -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Window&lt;/span&gt; -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DecorView&lt;/span&gt; -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ViewGroup&lt;/span&gt; -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;View&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;12-核心方法&#34;&gt;1.2 核心方法
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;dispatchTouchEvent&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;负责事件的分发&lt;/li&gt;
&lt;li&gt;返回true表示事件被消费，false表示未消费&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;onInterceptTouchEvent&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;只有ViewGroup才有的方法&lt;/li&gt;
&lt;li&gt;用于拦截事件，返回true表示拦截事件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;onTouchEvent&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;处理点击事件&lt;/li&gt;
&lt;li&gt;返回true表示事件被消费&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;2-源码分析&#34;&gt;2. 源码分析
&lt;/h4&gt;&lt;h5 id=&#34;21-activity的dispatchtouchevent&#34;&gt;2.1 Activity的dispatchTouchEvent
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dispatchTouchEvent&lt;/span&gt;(MotionEvent ev) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (ev.&lt;span style=&#34;color:#a6e22e&#34;&gt;getAction&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; MotionEvent.&lt;span style=&#34;color:#a6e22e&#34;&gt;ACTION_DOWN&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        onUserInteraction(); &lt;span style=&#34;color:#75715e&#34;&gt;// 空方法，可以重写&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (getWindow().&lt;span style=&#34;color:#a6e22e&#34;&gt;superDispatchTouchEvent&lt;/span&gt;(ev)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 事件被消费&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; onTouchEvent(ev); &lt;span style=&#34;color:#75715e&#34;&gt;// 如果所有View都没有处理，则调用Activity的onTouchEvent&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;22-viewgroup的dispatchtouchevent&#34;&gt;2.2 ViewGroup的dispatchTouchEvent
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dispatchTouchEvent&lt;/span&gt;(MotionEvent ev) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 1. 检查是否拦截&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; intercepted;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (actionMasked &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; MotionEvent.&lt;span style=&#34;color:#a6e22e&#34;&gt;ACTION_DOWN&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; mFirstTouchTarget &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; disallowIntercept &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (mGroupFlags &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; FLAG_DISALLOW_INTERCEPT) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; 0;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;disallowIntercept) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            intercepted &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; onInterceptTouchEvent(ev);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ev.&lt;span style=&#34;color:#a6e22e&#34;&gt;setAction&lt;/span&gt;(action); &lt;span style=&#34;color:#75715e&#34;&gt;// 恢复action，防止被修改&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            intercepted &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 没有目标处理该事件，也不拦截&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        intercepted &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 2. 如果不拦截，则寻找可以处理事件的子View&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;canceled &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;intercepted) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 遍历子View，寻找可以处理事件的View&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; childrenCount &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; 0; i&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; View child &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; children&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (child.&lt;span style=&#34;color:#a6e22e&#34;&gt;dispatchTouchEvent&lt;/span&gt;(ev)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 找到可以处理事件的子View&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                mFirstTouchTarget &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; addTouchTarget(child, idBitsToAssign);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 3. 分发事件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (mFirstTouchTarget &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 没有子View处理事件，调用父类的dispatchTouchEvent&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        handled &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;super&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;dispatchTouchEvent&lt;/span&gt;(ev);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 将事件分发给目标View&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        TouchTarget target &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mFirstTouchTarget;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (target &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; View child &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; target.&lt;span style=&#34;color:#a6e22e&#34;&gt;child&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (child.&lt;span style=&#34;color:#a6e22e&#34;&gt;dispatchTouchEvent&lt;/span&gt;(ev)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                handled &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            target &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; target.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; handled;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h6 id=&#34;实际执行流程&#34;&gt;实际执行流程
&lt;/h6&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;DOWN事件&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mFirstTouchTarget == null&lt;/code&gt;，进入寻找目标View的循环&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;child.dispatchTouchEvent(ev)&lt;/code&gt;（第一次）&lt;/li&gt;
&lt;li&gt;如果某个子View返回true，设置&lt;code&gt;mFirstTouchTarget&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MOVE/UP事件&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mFirstTouchTarget != null&lt;/code&gt;，直接进入分发流程&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;target.child.dispatchTouchEvent(ev)&lt;/code&gt;（第二次）&lt;/li&gt;
&lt;li&gt;不会再次进入寻找目标View的循环&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TouchTarget&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;TouchTarget是链表结构主要目的是为了支持多点触控&lt;/li&gt;
&lt;li&gt;从 &lt;code&gt;mFirstTouchTarget&lt;/code&gt; 开始遍历链表&lt;/li&gt;
&lt;li&gt;检查每个 &lt;code&gt;TouchTarget&lt;/code&gt; 的 &lt;code&gt;pointerIdBits&lt;/code&gt; 是否与当前事件的 &lt;code&gt;desiredPointerIdBits&lt;/code&gt; 匹配&lt;/li&gt;
&lt;li&gt;如果找到匹配的 &lt;code&gt;TouchTarget&lt;/code&gt;，则将事件分发给对应的子View&lt;/li&gt;
&lt;li&gt;如果没有找到匹配的 &lt;code&gt;TouchTarget&lt;/code&gt;，则返回false&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h6 id=&#34;为什么这样设计&#34;&gt;为什么这样设计
&lt;/h6&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;性能优化&lt;/strong&gt;：避免每次事件都遍历所有子View&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件一致性&lt;/strong&gt;：确保同一事件序列由同一View处理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;正确性&lt;/strong&gt;：防止事件序列被拆分到不同View处理&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;23-view的dispatchtouchevent&#34;&gt;2.3 View的dispatchTouchEvent
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dispatchTouchEvent&lt;/span&gt;(MotionEvent event) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 1. 首先检查OnTouchListener&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ListenerInfo li &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mListenerInfo;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (li &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; li.&lt;span style=&#34;color:#a6e22e&#34;&gt;mOnTouchListener&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; (mViewFlags &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; ENABLED_MASK) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; ENABLED 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; li.&lt;span style=&#34;color:#a6e22e&#34;&gt;mOnTouchListener&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;onTouch&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;, event)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 2. 然后调用onTouchEvent&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (onTouchEvent(event)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;3-事件分发的关键点&#34;&gt;3. 事件分发的关键点
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;事件序列&lt;/strong&gt;：从ACTION_DOWN开始，到ACTION_UP或ACTION_CANCEL结束的一些列事件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件拦截&lt;/strong&gt;：ViewGroup可以通过onIterceptTouchEvent拦截事件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件消费&lt;/strong&gt;：View可以通过onTouchEvent或OnTouchListener消费事件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件传递&lt;/strong&gt;：默认情况下，事件会从上到下传递，直到被消费&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;4-常见面试题&#34;&gt;4. 常见面试题
&lt;/h4&gt;&lt;h5 id=&#34;41-事件分发的流程是怎样的&#34;&gt;4.1 事件分发的流程是怎样的
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;从Activity的dispatchTouchEvent开始&lt;/li&gt;
&lt;li&gt;经过Window、DecorView、ViewGroup&lt;/li&gt;
&lt;li&gt;最终到达具体的View&lt;/li&gt;
&lt;li&gt;如果没有任何View消费事件，事件会回传到Activity的onTouchEvent&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;42-ontouch和ontouchevent的区别&#34;&gt;4.2 onTouch和onTouchEvent的区别
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;onTouch是View.OnTouchListener接口中的方法&lt;/li&gt;
&lt;li&gt;onTouchEvent是View的方法&lt;/li&gt;
&lt;li&gt;onTouch的优先级高于onTouchEvent&lt;/li&gt;
&lt;li&gt;如果onTouch返回true，则onTouch不会被调用&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;43-如何解决滑动冲突&#34;&gt;4.3 如何解决滑动冲突
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;外部拦截法：重写父容器的onInterceptTouchEvent方法&lt;/li&gt;
&lt;li&gt;内部拦截法： 重写子元素的dispatchTouchEvent方法，结合requestDisallowInterceptTouchEvent方法&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;5-实际应用示例&#34;&gt;5. 实际应用示例
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 自定义ViewGroup，处理左右滑动冲突&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CustomViewPager&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; ViewGroup {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; mLastX;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; mLastY;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;onInterceptTouchEvent&lt;/span&gt;(MotionEvent ev) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; intercepted &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ev.&lt;span style=&#34;color:#a6e22e&#34;&gt;getX&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ev.&lt;span style=&#34;color:#a6e22e&#34;&gt;getY&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;switch&lt;/span&gt; (ev.&lt;span style=&#34;color:#a6e22e&#34;&gt;getAction&lt;/span&gt;()) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; MotionEvent.&lt;span style=&#34;color:#a6e22e&#34;&gt;ACTION_DOWN&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                mLastX &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                mLastY &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; y;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                intercepted &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; MotionEvent.&lt;span style=&#34;color:#a6e22e&#34;&gt;ACTION_MOVE&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; deltaX &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Math.&lt;span style=&#34;color:#a6e22e&#34;&gt;abs&lt;/span&gt;(x &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; mLastX);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; deltaY &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Math.&lt;span style=&#34;color:#a6e22e&#34;&gt;abs&lt;/span&gt;(y &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; mLastY);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 横向滑动距离大于纵向滑动距离时拦截事件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (deltaX &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; deltaY) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    intercepted &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    intercepted &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; MotionEvent.&lt;span style=&#34;color:#a6e22e&#34;&gt;ACTION_UP&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                intercepted &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        mLastX &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        mLastY &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; y;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; intercepted;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>MMKV与SharedPreferences</title>
        <link>http://localhost:1313/android-develop/mmkv%E4%B8%8Esharedpreferences/</link>
        <pubDate>Tue, 01 Jul 2025 15:49:53 +0800</pubDate>
        
        <guid>http://localhost:1313/android-develop/mmkv%E4%B8%8Esharedpreferences/</guid>
        <description>&lt;p&gt;Android中的MMKV和SharedPreferences都是用于存储键值对数据的轻量级解决方案，但他们在设计、性能和适用场景上存在显著差异。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;sharedpreferences&#34;&gt;SharedPreferences
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定位&lt;/strong&gt;：Android官方提供的轻量级键值对存储API。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;基于&lt;code&gt;XML&lt;/code&gt;文件存储。&lt;/li&gt;
&lt;li&gt;数据保存在&lt;code&gt;/data/data/&amp;lt;package_name&amp;gt;/shared_prefs/&lt;/code&gt;目录下&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;特点：
&lt;ul&gt;
&lt;li&gt;简单易用：API直观，原生支持&lt;/li&gt;
&lt;li&gt;线程安全(读写锁)：内部使用锁机制保证多线程安全，但也可能成为性能瓶颈&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异步写入(&lt;code&gt;apply()&lt;/code&gt;)&lt;/strong&gt;:主要推荐方式，异步写入磁盘，避免阻塞UI线程(但提交操作本身在主线程)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;同步写入(&lt;code&gt;commit()&lt;/code&gt;)&lt;/strong&gt;:阻塞调用线程直到写入完成，可能导致ANR，一般避免在主线程使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主要缺点：
&lt;ul&gt;
&lt;li&gt;性能较差：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全量写入&lt;/strong&gt;：即使只修改一个值，&lt;code&gt;apply()/commit()&lt;/code&gt;也会触发整个XML文件的序列化和写入操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;XML解析开销&lt;/strong&gt;：每次读取都需要解析XML&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;潜在ANR风险：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;commit(&lt;/code&gt;)在主线程同步写入大文件可能导致ANR。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apply()&lt;/code&gt;的潜在ANR：apply虽然异步，但它把写入任务放进一个&lt;code&gt;QueueWork队列&lt;/code&gt;。在Activity生命周期（如&lt;code&gt;onPause&lt;/code&gt;，&lt;code&gt;onStop&lt;/code&gt;）触发&lt;code&gt;QueueWork.waitToFinish()&lt;/code&gt;时，会等待所有未完成的apply()写入任务完成。如果后台任务积压或写入缓慢，会阻塞主线程，可能导致ANR(尤其在低端设备、频繁更新或大文件时)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可靠性问题(&lt;code&gt;MODE_MULTI_PROCESS&lt;/code&gt;):
&lt;ul&gt;
&lt;li&gt;官方&lt;code&gt;MODE_MULTI_PROCESS&lt;/code&gt;已被弃用且声明不可靠。不支持真正的多进程同步。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据膨胀：修改频繁会导致XML文件变大（需手动&lt;code&gt;clear + commit&lt;/code&gt;才能减小）。&lt;/li&gt;
&lt;li&gt;不支持复杂类型：仅支持基本类型，存储对象需自行序列化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;2-mmkv&#34;&gt;2. MMKV
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定位&lt;/strong&gt;：由腾讯微信团队开源的高性能&lt;strong&gt;跨平台&lt;/strong&gt;键值存储组件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现原理&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内存映射(&lt;code&gt;mmap&lt;/code&gt;)&lt;/strong&gt;:核心机制！将文件直接映射到内存空间。读写操作直接在内存中进行，由操作系统负责异步刷盘。省去了传统I/O的数据拷贝过程，比XML更小更快&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Protobuf&lt;/code&gt;编码：使用高效的protobuf格式进行序列化，比XML更小更快。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;增量写入&lt;/strong&gt;：修改数据时，通常是&lt;strong&gt;追加写&lt;/strong&gt;到文件末尾 (append-only)，避免全量重写。通过特殊的空间复用和垃圾回收机制处理过期数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;极致性能：读写速度远超SharedPreferences，通常达到数倍或百倍的提升。写入即生效，读取立即可见。&lt;/li&gt;
&lt;li&gt;真正的多进程支持：完美解决跨进程同步问题（&lt;code&gt;mmap&lt;/code&gt; + &lt;code&gt;文件锁/进程间锁机制&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;更小的存储空间：protobuf编码比XML更紧凑。&lt;/li&gt;
&lt;li&gt;无ANR担忧：
&lt;ul&gt;
&lt;li&gt;写入操作几乎完全被&lt;code&gt;mmap&lt;/code&gt;和&lt;code&gt;OS&lt;/code&gt;接管，是真正非阻塞的。&lt;/li&gt;
&lt;li&gt;完全避免了&lt;code&gt;SharedPreferences.apply&lt;/code&gt;潜在的&lt;code&gt;QueueWork.waitToFinish()&lt;/code&gt;ANR问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;支持数据类型丰富：原生支持基本类型、&lt;code&gt;String&lt;/code&gt;, &lt;code&gt;byte[]&lt;/code&gt;, 并且能方便地支持实现了 &lt;code&gt;Parcelable&lt;/code&gt; 或 &lt;code&gt;Serializable&lt;/code&gt; 的&lt;strong&gt;任意 Java 对象&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>协程知识点</title>
        <link>http://localhost:1313/android-develop/%E5%8D%8F%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
        <pubDate>Mon, 30 Jun 2025 19:02:22 +0800</pubDate>
        
        <guid>http://localhost:1313/android-develop/%E5%8D%8F%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9/</guid>
        <description>&lt;h4 id=&#34;将回调转换为协程&#34;&gt;将回调转换为协程
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;背景&lt;/strong&gt;：很多库（尤其是Java/Android遗留库）使用基于回调（Callback）的API处理异步操作（如网络请求，数据库操作）。这在代码中会导致回调地狱。我们需要一种方法将这种回调风格的API转换成&lt;code&gt;挂起函数(suspend fun)&lt;/code&gt;，使其可以在协程中像&lt;strong&gt;顺序代码&lt;/strong&gt;一样使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心函数：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;suspendCoroutine&lt;/code&gt;(简单转换，无内置取消支持)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &amp;lt;&lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt;&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;convertCallbackToSuspendingFunc&lt;/span&gt;(): T = suspendCoroutine {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  continuation &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;//1. 启动异步操作
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; callback = &lt;span style=&#34;color:#66d9ef&#34;&gt;object&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;: &lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Callback&lt;/span&gt;&amp;lt;T&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;onSuccess&lt;/span&gt;(result: T) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;//2. 成功时恢复协程，传递结果
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      continuation.resume(result)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;onFailure&lt;/span&gt;(error: Throwable) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;//3. 失败时恢复协程，传递异常
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      continuation.resumeWithException(error)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  someAsyncOperation(callback)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;continuation: 表示当前被挂起的协程。它提供了恢复协程的方法：resume(value)和resumeWithException(exception)。&lt;/li&gt;
&lt;li&gt;缺点：如果调用这个suspend fun 的协程被取消。someAsyncOperation不会自动终止。这可能导致资源浪费或意外结果。只适用于异步操作本身非常快或你不关心取消的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;suspendCancellableCoroutine&lt;/code&gt;(支持取消)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &amp;lt;&lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt;&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;convertCallbackToSuspendingFuncSafely&lt;/span&gt;(): T = suspendCancellableCoroutine { cancellableContinuation &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 1. 启动异步操作
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; callback = &lt;span style=&#34;color:#66d9ef&#34;&gt;object&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;: &lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Callback&lt;/span&gt;&amp;lt;T&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;onSuccess&lt;/span&gt;(result: T) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            cancellableContinuation.resume(result)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;onFailure&lt;/span&gt;(error: Throwable) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            cancellableContinuation.resumeWithException(error)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    someAsyncOperation(callback)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 2. ⭐ 关键步骤：注册取消监听器 ⭐
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    cancellableContinuation.invokeOnCancellation {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 当协程被取消时，尝试取消底层的异步操作
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 通常调用库提供的取消方法，例如：cancelOperation(callback)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        cancelOperation(callback)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;当调用这个&lt;code&gt;suspend fun&lt;/code&gt;的协程被取消时：
&lt;ol&gt;
&lt;li&gt;协程的取消状态会传播到这个 &lt;code&gt;CancellableContinuation&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;触发 &lt;code&gt;invokeOnCancellation {}&lt;/code&gt; 块。&lt;/li&gt;
&lt;li&gt;在块内，你调用库的取消方法去清理资源并停止操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;这是&lt;strong&gt;将回调 API 集成到协程世界的最佳实践&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;协程作用域&#34;&gt;协程作用域
&lt;/h4&gt;&lt;h5 id=&#34;1什么是协程作用域coroutinescope&#34;&gt;1、什么是协程作用域（CoroutineScope）
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CoroutineScope&lt;/code&gt;不是协程本身，而是一个&lt;strong&gt;定义新协程运行环境&lt;/strong&gt;的接口&lt;/li&gt;
&lt;li&gt;它为在其内部启动的所有子协程提供了一个统一的&lt;code&gt;CoroutineContext&lt;/code&gt;基础&lt;/li&gt;
&lt;li&gt;它将所有在其内部启动的协程&lt;strong&gt;组织在一个结构中&lt;/strong&gt;，以便进行&lt;strong&gt;生命周期管理&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;核心构成：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CoroutineScope接口只有一个属性：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CoroutineScope&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; coroutineContext: CotoutineContext
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个&lt;code&gt;coroutineContext&lt;/code&gt;是启动在该作用域内的&lt;strong&gt;所有子协程的默认上下文&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;协程作用域的核心优点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;生命周期的自动管理(取消)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;避免内存泄漏&lt;/li&gt;
&lt;li&gt;简化资源清理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;安全性与清晰性&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;取消传播：作用域的取消会自动且可靠地传播到所有子协程，无需开发者手动级联取消&lt;/li&gt;
&lt;li&gt;异常处理控制：作用域定义了异常传播的策略（通过其关联的&lt;code&gt;Job&lt;/code&gt;是普通&lt;code&gt;Job&lt;/code&gt;还是&lt;code&gt;SupervisorJob&lt;/code&gt;）。&lt;code&gt;SupervisorJob&lt;/code&gt;允许子协程独立失败而不影响其他兄弟协程和父作用域（常用于UI组件中单独的后台任务）。&lt;/li&gt;
&lt;li&gt;代码组织清晰：将任务划分到不同的作用域中，体现了任务的逻辑和生命周期归属。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;上下文继承与共享&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;在作用域内启动的协程默认继承作用域的coroutineContext&lt;/li&gt;
&lt;li&gt;可以指定不同的CoroutineContext元素来覆盖上下文&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;协同等待(job.join(), coroutineScope {})&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;你可以通过作用域的关联 &lt;code&gt;Job&lt;/code&gt; (调用 &lt;code&gt;scope.coroutineContext[Job]!!.join()&lt;/code&gt; 或更简单地使用 &lt;code&gt;coroutineScope {}&lt;/code&gt; 构建器) 来&lt;strong&gt;等待作用域内所有子协程全部完成&lt;/strong&gt;。这保证了任务内部的并发操作在外部看来是原子性的（即父协程等待所有子协程完成后自己才完成）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;coroutineScope {}&lt;/code&gt; 构建器本身也会创建一个新的子作用域，并等待其内部所有子协程完成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h4 id=&#34;async的行为&#34;&gt;async的行为
&lt;/h4&gt;&lt;h5 id=&#34;1-async的立即启动特性&#34;&gt;1. async的立即启动特性
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;async不是等待await才执行：当使用async { &amp;hellip; } 创建协程时，其中的代码会立即开始执行，而不是等待调用&lt;code&gt;await()&lt;/code&gt;。即使不调用await()，协程体也会在后台启动。&lt;/li&gt;
&lt;li&gt;并发执行：多个async协程默认并行执行（取决于调度器和上下文）。例如：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; deferred1 = async { task1() } &lt;span style=&#34;color:#75715e&#34;&gt;// 立即开始执行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; deferred2 = async { task2() } &lt;span style=&#34;color:#75715e&#34;&gt;// 立即开始执行（可能与 task1 同时运行）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;2-await的作用&#34;&gt;2. await()的作用
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;同步等待结果：await()是一个挂起点：
&lt;ul&gt;
&lt;li&gt;如果协程已完成：直接返回结果&lt;/li&gt;
&lt;li&gt;如果协程未完成：挂起当前协程，等待结果但不阻止其他协程执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;顺序控制：await()可强制等待顺序：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; result1 = deferred1.await() &lt;span style=&#34;color:#75715e&#34;&gt;// 等待 task1 完成
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; result2 = deferred2.await() &lt;span style=&#34;color:#75715e&#34;&gt;// 再等待 task2 完成
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;qa&#34;&gt;Q&amp;amp;A
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;父协程的挂起会影响子协程的运行吗？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;通常不会影响子协程的运行&lt;/strong&gt;，父协程与子协程是独立的任务单元，只要子协程未完成且未被取消，他们会继续由调度器分配线程执行。取消是取消，挂起时让出当前线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;父作用域会等待所有子协程完成后才继续执行？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是的，所有父协程（父作用域）会自动等待所有子协程完成。&lt;code&gt;join()&lt;/code&gt;和&lt;code&gt;wait()&lt;/code&gt;&lt;strong&gt;控制执行顺序&lt;/strong&gt;和&lt;strong&gt;确保在特定节点有结果&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么I/O操作支持挂起，而CPU密集操作需要&lt;code&gt;withContext&lt;/code&gt;手动挂起。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;I/O操作需要&lt;strong&gt;等待外部资源&lt;/strong&gt;（文件/网络/数据库响应）就绪，进而CPU就会空闲，空闲下来了，协程就决定&lt;strong&gt;主动释放线程 - 挂起&lt;/strong&gt;，让其他任务去使用线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU密集操作&lt;strong&gt;持续消耗CPU计算资源&lt;/strong&gt;，CPU不会空闲&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>协程原理</title>
        <link>http://localhost:1313/android-develop/%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86/</link>
        <pubDate>Mon, 30 Jun 2025 15:13:25 +0800</pubDate>
        
        <guid>http://localhost:1313/android-develop/%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86/</guid>
        <description>&lt;p&gt;Kotlin协程的本质是&lt;strong&gt;通过状态机管理挂起点，由编译器进行CPS变换实现的轻量级并发抽象&lt;/strong&gt;。其核心原理和状态推进机制如下：&lt;/p&gt;
&lt;h4 id=&#34;核心原理&#34;&gt;核心原理
&lt;/h4&gt;&lt;h5 id=&#34;1-挂起函数&#34;&gt;1. 挂起函数
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;用suspend修饰的函数&lt;/li&gt;
&lt;li&gt;编译器会将其编译为&lt;strong&gt;状态机代码&lt;/strong&gt;(而非阻塞线程)，支持在任意位置挂起/恢复&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2-续体&#34;&gt;2. 续体
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;类似回调的接口&lt;code&gt;Continuation&amp;lt;T&amp;gt;&lt;/code&gt;，其关键方法是&lt;code&gt;resumeWith(result)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;协程的每一步执行都依附于一个续体对象，存储当前执行状态和上下文&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;3-状态机转换&#34;&gt;3. 状态机转换
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;编译器将挂起函数拆解成一个状态机（通过&lt;code&gt;label&lt;/code&gt;标记状态）&lt;/li&gt;
&lt;li&gt;每个挂起点对应一个状态迁移&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;状态推进流程&#34;&gt;状态推进流程
&lt;/h4&gt;&lt;p&gt;以下代码展示状态机的运作：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fetchData&lt;/span&gt;(): String {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; data1 = fetchPart1()  &lt;span style=&#34;color:#75715e&#34;&gt;//挂起点1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; data2 = fetchPart2()  &lt;span style=&#34;color:#75715e&#34;&gt;//挂起点2
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; data1 + data2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;编译器转换后（伪代码）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;FetchDataStateMachine&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;val&lt;/span&gt; completion: Continuation&amp;lt;String&amp;gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; label: Int = &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) : Continuation&amp;lt;Unit&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; data1: String? = &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; data2: String? = &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;resumeWith&lt;/span&gt;(result: Result&amp;lt;Any?&amp;gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;when&lt;/span&gt;(label) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        label = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        fetchPart1(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        data1 = result.getOrThrow() &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; String
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        label = &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        fetchPart2(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        data2 = result.getOrThrow() &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; String
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        completion.resumeWith(data1 + data2)	&lt;span style=&#34;color:#75715e&#34;&gt;//返回最终结果
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h4 id=&#34;关键机制&#34;&gt;关键机制
&lt;/h4&gt;&lt;h5 id=&#34;1-挂起不阻塞线程&#34;&gt;1. 挂起不阻塞线程：
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;协程挂起时，底层线程立即释放（例如返回到线程池），避免资源浪费&lt;/li&gt;
&lt;li&gt;异步操作完成后，任务被派发到合适的线程继续执行（通过&lt;code&gt;Dispatcher&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2续体传递风格&#34;&gt;2.续体传递风格
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;挂起函数被编译为接受额外&lt;code&gt;Continuation&lt;/code&gt;参数的函数&lt;/li&gt;
&lt;li&gt;例如&lt;code&gt;suspend fun foo()&lt;/code&gt; → &lt;code&gt;fun foo(continuation: Continuation)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;3-协程上下文coroutinecontext&#34;&gt;3. 协程上下文（CoroutineContext）
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;通过&lt;code&gt;CoroutineContext&lt;/code&gt;传递调度器、异常处理器等。&lt;/li&gt;
&lt;li&gt;状态机中通过&lt;code&gt;Continuation.context&lt;/code&gt;获取当前上下文&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;4-结构化并发&#34;&gt;4. 结构化并发
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;协程树通过父-子关系管理生命周期&lt;/li&gt;
&lt;li&gt;父协程取消时，自动取消所有子协程&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;状态推进&#34;&gt;状态推进
&lt;/h4&gt;&lt;p&gt;在&lt;code&gt;FetchDataStateMachine&lt;/code&gt;的&lt;code&gt;resumeWith&lt;/code&gt;中并没有循环，label的状态是如何推进的呢？实际上状态推进是通过&lt;strong&gt;递归链式调用与间接跳转&lt;/strong&gt;实现的。&lt;/p&gt;
&lt;h5 id=&#34;1-单次触发模型&#34;&gt;1. 单次触发模型
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;每次resumeWith被调用时只处理当前状态&lt;/li&gt;
&lt;li&gt;通过更新label值标记下一步状态&lt;/li&gt;
&lt;li&gt;不立即处理后续状态，而是等待下一次恢复&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;label = &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;//只标记下一步状态，不立即执行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;fetchPart2(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;)  &lt;span style=&#34;color:#75715e&#34;&gt;//触发异步操作（挂起），this就是FetchDataStateMachine，其是Continuation，可通过this调用resumeWith
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;2-链式递归唤醒&#34;&gt;2. 链式递归唤醒
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;每个异步操作完成时，都会重新调用resumeWith&lt;/li&gt;
&lt;li&gt;每调用一次，就会处理当前状态并设置下一次状态&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;resumeWith(结果) → 处理当前状态
      ↑               ↓
  异步完成          设置下一状态
      ↑             
  恢复执行        
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&#34;3-状态变量持久化&#34;&gt;3. 状态变量持久化
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;状态机对象在挂起期间持续存在（堆内存）&lt;/li&gt;
&lt;li&gt;成员变量(data1, label)保存中间状态&lt;/li&gt;
&lt;li&gt;每次恢复时从正确状态继续执行&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;4-编译器优化技巧&#34;&gt;4. 编译器优化技巧
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;尾递归优化：编译器会将状态处理转为循环&lt;/li&gt;
&lt;li&gt;状态折叠 ：合并可优化状态减少跳转次数&lt;/li&gt;
&lt;li&gt;内联状态：简单状态机转为switch跳转表&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;对挂起的理解&#34;&gt;对挂起的理解
&lt;/h4&gt;&lt;p&gt;协程挂机：在挂起点暂停当前的同步代码，转而去执行消息队列的runnable；这样就是我对挂起的理解，也就是让出线程&lt;/p&gt;
</description>
        </item>
        <item>
        <title>gradle相关知识</title>
        <link>http://localhost:1313/android-develop/gradle%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</link>
        <pubDate>Sun, 29 Jun 2025 15:26:57 +0800</pubDate>
        
        <guid>http://localhost:1313/android-develop/gradle%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</guid>
        <description>&lt;h3 id=&#34;一插件plugins-vs-库libraries&#34;&gt;一、插件(Plugins) vs 库(Libraries)
&lt;/h3&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;特征&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;插件 (Plugins)&lt;/th&gt;
          &lt;th&gt;库 (Libraries)&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;本质&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;构建逻辑扩展工具&lt;/td&gt;
          &lt;td&gt;运行时依赖的代码组件&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;添加任务/配置/目录结构&lt;/td&gt;
          &lt;td&gt;提供可调用的具体代码实现&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;声明位置&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;plugins {}&lt;/code&gt; 块&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;dependencies {}&lt;/code&gt; 块&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;影响范围&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;构建过程&lt;/td&gt;
          &lt;td&gt;运行时或编译时&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;典型示例&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;java&lt;/code&gt;，&lt;code&gt;android&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;gson&lt;/code&gt;, &lt;code&gt;junit&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;1-插件详解&#34;&gt;1. 插件详解
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;核心作用&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加新任务（如 &lt;code&gt;compileJava&lt;/code&gt;, &lt;code&gt;assemble&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;定义默认目录结构（如 &lt;code&gt;src/main/java&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;引入预置配置（如 &lt;code&gt;implementation&lt;/code&gt; 依赖配置）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;使用场景&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;plugins &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;com.android.application&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// Android APP插件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    id &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;org.jetbrains.kotlin.android&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// Kotlin支持
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;2-库详解&#34;&gt;2. 库详解
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;关键特征&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过坐标声明：&lt;code&gt;group:name:version&lt;/code&gt;（如 &lt;code&gt;com.google.guava:guava:32.0-jre&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传递依赖&lt;/strong&gt;：库可能自带其他依赖（如 Retrofit 自动引入 OkHttp）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;使用场景&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;dependencies &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    implementation &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;androidx.core:core-ktx:1.12.0&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 主代码依赖
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    testImplementation &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;junit:junit:4.13.2&amp;#39;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 测试代码专用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h3 id=&#34;二依赖配置详解&#34;&gt;二、依赖配置详解
&lt;/h3&gt;&lt;h4 id=&#34;1-implementation最常用&#34;&gt;1. &lt;code&gt;implementation&lt;/code&gt;（最常用）
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;依赖&lt;strong&gt;不传递&lt;/strong&gt;给其他模块,&lt;code&gt;模块F → 模块D → 模块E&lt;/code&gt;（传导终止于D），模块F完全不知道模块E的存在&lt;/li&gt;
&lt;li&gt;加快构建（减少重编译）&lt;/li&gt;
&lt;li&gt;适用于绝大多数字依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;implementation &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;com.squareup.retrofit2:retrofit:2.9.0&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;2-api谨慎使用&#34;&gt;2. &lt;code&gt;api&lt;/code&gt;（谨慎使用）
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;依赖&lt;strong&gt;传递&lt;/strong&gt;给其他模块，建立&lt;strong&gt;依赖传递链&lt;/strong&gt;：&lt;code&gt;模块C → 模块A → 模块B&lt;/code&gt;，模块C可以使用模块B公开的接口&lt;/li&gt;
&lt;li&gt;用于 SDK 开发需暴露依赖的场景&lt;/li&gt;
&lt;li&gt;会增加构建时间&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;api &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;com.google.dagger:dagger:2.48&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 其他模块需使用Dagger
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;3-classpath&#34;&gt;3. &lt;code&gt;classpath&lt;/code&gt;
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;仅用于项目级构建脚本(&lt;code&gt;build.gradle&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;为 Gradle 自身引入插件包，然后在模块级plugins块中声明使用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不参与&lt;/strong&gt;模块代码编译&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 项目级 build.gradle
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;buildscript &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    dependencies &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        classpath &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;com.android.tools.build:gradle:8.1.0&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;4-alias版本目录&#34;&gt;4. &lt;code&gt;alias&lt;/code&gt;（版本目录）
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;gradle/libs.versions.toml&lt;/code&gt; 中集中管理依赖&lt;/li&gt;
&lt;li&gt;解决版本号硬编码问题&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;需 AGP 7.4+&lt;/strong&gt; 支持&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# libs.versions.toml&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;versions&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;androidxCore&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1.12.0&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;libraries&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;android-core&lt;/span&gt; = { 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;group&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;androidx.core&amp;#34;&lt;/span&gt;, 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;core-ktx&amp;#34;&lt;/span&gt;, 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;version&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ref&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;androidxCore&amp;#34;&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;dependencies &lt;span style=&#34;color:#f92672&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    implementation&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;libs&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;android&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;core&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// 通过别名引用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>Android打包apk流程</title>
        <link>http://localhost:1313/android-develop/android%E6%89%93%E5%8C%85apk%E6%B5%81%E7%A8%8B/</link>
        <pubDate>Sat, 28 Jun 2025 12:15:42 +0800</pubDate>
        
        <guid>http://localhost:1313/android-develop/android%E6%89%93%E5%8C%85apk%E6%B5%81%E7%A8%8B/</guid>
        <description>&lt;p&gt;android应用的打包流程是将代码、资源文件、清单文件等编译和压缩成可在设备上安装的APK/AAB文件的过程。以下是详细步骤：&lt;/p&gt;
&lt;h4 id=&#34;一主要流程&#34;&gt;一、主要流程
&lt;/h4&gt;&lt;h5 id=&#34;1-编写代码与资源管理&#34;&gt;1. 编写代码与资源管理
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;创建&lt;code&gt;/src&lt;/code&gt;目录存放Kotlin/Java源码&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;/res&lt;/code&gt;目录添加资源&lt;/li&gt;
&lt;li&gt;配置&lt;code&gt;AndroidManifest.xml&lt;/code&gt;(声明组件、权限等)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2-依赖管理&#34;&gt;2. 依赖管理
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;在build.gradle中添加所需依赖库&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;3-编译过程&#34;&gt;3. 编译过程
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;编译代码： kotlin源码 → &lt;code&gt;.class&lt;/code&gt;字节码（javac/kotlinc）&lt;/li&gt;
&lt;li&gt;转换为Dex：&lt;code&gt;.class&lt;/code&gt;文件→ &lt;code&gt;.dex&lt;/code&gt;文件（&lt;code&gt;d8&lt;/code&gt;/&lt;code&gt;dx&lt;/code&gt;工具），用于Android的ART虚拟机&lt;/li&gt;
&lt;li&gt;编译资源：&lt;code&gt;AAPT2&lt;/code&gt;编译资源文件（&lt;code&gt;res/&lt;/code&gt; → 二进制格式），生成&lt;code&gt;R.java&lt;/code&gt;和临时资源包(&lt;code&gt;.flat&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;4打包与签名&#34;&gt;4.打包与签名
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;合并资源： AAPT2链接编译后的资源，生成resources.arsc（资源索引表）和优化后的res/目录&lt;/li&gt;
&lt;li&gt;打包成APK：APK Builder将以下文件合并为未签名的APK：
&lt;ul&gt;
&lt;li&gt;编译后的字节码(&lt;code&gt;.dex&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;资源文件(&lt;code&gt;res/&lt;/code&gt; + &lt;code&gt;resources.arsc&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AndroidManifest.xml&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;原生库(&lt;code&gt;.so&lt;/code&gt;，若有JNI)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;签名APK：使用签名证书(keystore)进行V1/V2/V3签名(通过&lt;code&gt;apksigner&lt;/code&gt; 或Gradle配置)&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;5优化与对齐&#34;&gt;5.优化与对齐
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;ZIP对齐：&lt;code&gt;zipalign&lt;/code&gt;优化APK文件结构(4字节对齐)，减少运行时内存占用&lt;/li&gt;
&lt;li&gt;生成最终的APK：输出&lt;code&gt;app-release.apk&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;二名词解释&#34;&gt;二、名词解释
&lt;/h4&gt;&lt;h5 id=&#34;1-临时资源包&#34;&gt;1. 临时资源包
&lt;/h5&gt;&lt;p&gt;在AAPT2（&lt;code&gt;Android Asset Packaging Tool 2&lt;/code&gt;）的资源预编译阶段会生成.flat文件，这些文件是中间产物&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;独立编译：AAPT2将&lt;code&gt;/res&lt;/code&gt;目录下的每个资源文件单独编译成二进制格式的&lt;code&gt;.flat&lt;/code&gt;文件&lt;/li&gt;
&lt;li&gt;支持增量编译：若只修改了单个资源文件，只需重新编译该文件的.flat文件，避免全量编译，加快构建速度&lt;/li&gt;
&lt;li&gt;分阶段处理
&lt;ul&gt;
&lt;li&gt;编译阶段：资源→ &lt;code&gt;.flat&lt;/code&gt;文件&lt;/li&gt;
&lt;li&gt;链接阶段：合并所有&lt;code&gt;.flat&lt;/code&gt;文件 → 生成&lt;code&gt;resources.arsc&lt;/code&gt;和最终的&lt;code&gt;res/&lt;/code&gt;目录&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优势
&lt;ul&gt;
&lt;li&gt;提升大型项目的编译速度&lt;/li&gt;
&lt;li&gt;支持资源混淆&lt;/li&gt;
&lt;li&gt;更严格的资源验证&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2-对齐&#34;&gt;2. 对齐
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内存对齐&lt;/strong&gt;：解决CPU访问效率问题（&lt;code&gt;数据项首地址 % n == 0&lt;/code&gt;），但会增加数据结构大小&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件对齐(zipalign)&lt;/strong&gt;:解决内存映射效率的问题（&lt;code&gt;文件偏移 % 4096 == 0&lt;/code&gt;），通过消除跨页碎片减少运行时内存占用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存页机制&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;系统内存管理以**页(通常4KB)**为单位&lt;/li&gt;
&lt;li&gt;对齐后，每次文件读取 = 整数倍内存页 → &lt;strong&gt;减少I/O次数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Choreographer类解析</title>
        <link>http://localhost:1313/android-develop/choreographer%E7%B1%BB%E8%A7%A3%E6%9E%90/</link>
        <pubDate>Mon, 16 Jun 2025 06:49:21 +0800</pubDate>
        
        <guid>http://localhost:1313/android-develop/choreographer%E7%B1%BB%E8%A7%A3%E6%9E%90/</guid>
        <description>&lt;h4 id=&#34;一核心作用&#34;&gt;一、核心作用
&lt;/h4&gt;&lt;p&gt;Choreographer是Android系统&lt;strong&gt;协调动画、输入和绘制操作的核心调度器&lt;/strong&gt;。它通过VSYNC信号确保帧的渲染与屏幕刷新率同步，避免画面撕裂和卡顿。&lt;/p&gt;
&lt;h4 id=&#34;二关键概念&#34;&gt;二、关键概念
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;VSYNC：垂直同步信号，表示屏幕开始刷新新的一帧&lt;/li&gt;
&lt;li&gt;Frame Callbacks：注册的回调函数，在下一帧的特定阶段执行&lt;/li&gt;
&lt;li&gt;Callback Types（按执行顺序排序）
&lt;ul&gt;
&lt;li&gt;CALLBACK_INPUT&lt;/li&gt;
&lt;li&gt;CALLBACK_ANIMATION&lt;/li&gt;
&lt;li&gt;CALLBACK_INSETS_ANIMATION&lt;/li&gt;
&lt;li&gt;CALLBACK_TRAVERSAL&lt;/li&gt;
&lt;li&gt;CALLBACK_COMMIT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Choreographer&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 五种回调类型&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; CALLBACK_INPUT &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; CALLBACK_ANIMATION &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 1;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; CALLBACK_INSETS_ANIMATION &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 2;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; CALLBACK_TRAVERSAL &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 3;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; CALLBACK_COMMIT &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 4;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; CALLBACK_LAST &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; CALLBACK_COMMIT; &lt;span style=&#34;color:#75715e&#34;&gt;// 最后一种类型&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 单例模式实现&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; ThreadLocal&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Choreographer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; sThreadInstance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ThreadLocal&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Choreographer&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;protected&lt;/span&gt; Choreographer &lt;span style=&#34;color:#a6e22e&#34;&gt;initialValue&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                Looper looper &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Looper.&lt;span style=&#34;color:#a6e22e&#34;&gt;myLooper&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Choreographer(looper, VSYNC_SOURCE_APP);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 回调队列数组&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; CallbackQueue&lt;span style=&#34;color:#f92672&#34;&gt;[]&lt;/span&gt; mCallbackQueues;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// VSYNC 接收器&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; FrameDisplayEventReceiver mDisplayEventReceiver;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 处理消息的Handler&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; FrameHandler mHandler;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;三核心架构图解&#34;&gt;三、核心架构图解
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-tex&#34; data-lang=&#34;tex&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;┌───────────────────────┐       ┌───────────────────────┐
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│    VSYNC 信号源        │──────&amp;gt;│ FrameDisplayEventReceiver │
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;└───────────────────────┘       │  (接收硬件VSYNC信号)     │
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                └───────────┬───────────┘
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                            │
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                                            ▼
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;┌───────────────────────┐       ┌───────────────────────┐
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│     FrameHandler       │&amp;lt;──────│    onVsync()          │
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│   (处理3类消息)        │──────&amp;gt;│    scheduleVsync()    │
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;└───────────┬───────────┘       └───────────────────────┘
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            │
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ▼
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;┌───────────────────────┐
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│      doFrame()         │
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│ (帧处理核心方法)       │
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;└───────────┬───────────┘
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            │
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            ▼
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;┌───────────────────────┐
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│   CallbackQueue[]      │
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│ (5种类型回调链表)      │
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;└───────────────────────┘
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;三回调添加入口&#34;&gt;三、回调添加入口
&lt;/h4&gt;&lt;h5 id=&#34;1-添加回调入口&#34;&gt;1. 添加回调入口
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;postCallback&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; callbackType, Runnable action, Object token) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    postCallbackDelayed(callbackType, action, token, 0);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;postCallbackDelayed&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; callbackType, Runnable action, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; delayMillis) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    postCallbackDelayedInternal(callbackType, action, token, delayMillis);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;2-内部添加实现&#34;&gt;2. 内部添加实现
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;postCallbackDelayedInternal&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; callbackType,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Object action, Object token, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; delayMillis) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; (mLock) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; now &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; SystemClock.&lt;span style=&#34;color:#a6e22e&#34;&gt;uptimeMillis&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; dueTime &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; now &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; delayMillis;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 1. 添加到对应的回调队列&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        mCallbackQueues&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;callbackType&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;addCallbackLocked&lt;/span&gt;(dueTime, action, token);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 2. 调度帧处理&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (dueTime &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; now) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 立即调度&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            scheduleFrameLocked(now);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 延迟调度&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            Message msg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mHandler.&lt;span style=&#34;color:#a6e22e&#34;&gt;obtainMessage&lt;/span&gt;(MSG_DO_SCHEDULE_CALLBACK, action);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            msg.&lt;span style=&#34;color:#a6e22e&#34;&gt;arg1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; callbackType;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            msg.&lt;span style=&#34;color:#a6e22e&#34;&gt;setAsynchronous&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            mHandler.&lt;span style=&#34;color:#a6e22e&#34;&gt;sendMessageAtTime&lt;/span&gt;(msg, dueTime);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;3-回调链表结构&#34;&gt;3. 回调链表结构
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CallbackQueue&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; CallbackRecord mHead;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;addCallbackLocked&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; dueTime, Object action, Object token) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        CallbackRecord callback &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; obtainCallbackLocked(dueTime, action, token);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (mHead &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            mHead &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; callback;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 链表按照执行时间排序（小到大）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (dueTime &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; mHead.&lt;span style=&#34;color:#a6e22e&#34;&gt;dueTime&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            callback.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mHead;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            mHead &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; callback;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        CallbackRecord entry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mHead;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (entry.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (dueTime &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; entry.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;dueTime&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                callback.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; entry.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                entry.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; callback;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            entry &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; entry.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        entry.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; callback;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 链表节点定义&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;CallbackRecord&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; CallbackRecord next;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; dueTime;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Object action; &lt;span style=&#34;color:#75715e&#34;&gt;// Runnable 或 FrameCallback&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; Object token;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;四vsync同步机制&#34;&gt;四、VSYNC同步机制
&lt;/h4&gt;&lt;h5 id=&#34;1-vsync请求&#34;&gt;1、 VSYNC请求
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;scheduleFrameLocked&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; now) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;mFrameScheduled) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        mFrameScheduled &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (USE_VSYNC) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 通过 FrameDisplayEventReceiver 请求 VSYNC&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (isRunningOnLooperThreadLocked()) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;              &lt;span style=&#34;color:#75715e&#34;&gt;//注册&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                scheduleVsyncLocked();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;// 非UI线程发送消息到UI线程&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                Message msg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mHandler.&lt;span style=&#34;color:#a6e22e&#34;&gt;obtainMessage&lt;/span&gt;(MSG_DO_SCHEDULE_VSYNC);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                msg.&lt;span style=&#34;color:#a6e22e&#34;&gt;setAsynchronous&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                mHandler.&lt;span style=&#34;color:#a6e22e&#34;&gt;sendMessageAtFrontOfQueue&lt;/span&gt;(msg);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 无VSYNC直接安排帧&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; nextFrameTime &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ...;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            Message msg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mHandler.&lt;span style=&#34;color:#a6e22e&#34;&gt;obtainMessage&lt;/span&gt;(MSG_DO_FRAME);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            msg.&lt;span style=&#34;color:#a6e22e&#34;&gt;setAsynchronous&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            mHandler.&lt;span style=&#34;color:#a6e22e&#34;&gt;sendMessageAtTime&lt;/span&gt;(msg, nextFrameTime);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;scheduleVsyncLocked&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    mDisplayEventReceiver.&lt;span style=&#34;color:#a6e22e&#34;&gt;scheduleVsync&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;2-vsync接收与处理&#34;&gt;2. VSYNC接收与处理
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;FrameDisplayEventReceiver&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;extends&lt;/span&gt; DisplayEventReceiver {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;onVsync&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; timestampNanos, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; physicalDisplayId, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; frame) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 1. 计算正确的帧时间&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; now &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; System.&lt;span style=&#34;color:#a6e22e&#34;&gt;nanoTime&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; intendedFrameTimeNanos &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ...;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 2. 发送MSG_DO_FRAME消息&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Message msg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Message.&lt;span style=&#34;color:#a6e22e&#34;&gt;obtain&lt;/span&gt;(mHandler, MSG_DO_FRAME);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        msg.&lt;span style=&#34;color:#a6e22e&#34;&gt;setAsynchronous&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        mHandler.&lt;span style=&#34;color:#a6e22e&#34;&gt;sendMessageAtTime&lt;/span&gt;(msg, intendedFrameTimeNanos &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; NANOS_PER_MS);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;3-帧处理核心---doframe&#34;&gt;3. 帧处理核心 - doFrame()
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;doFrame&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; frameTimeNanos, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; frame) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; startNanos;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; (mLock) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 检查帧调度状态&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;mFrameScheduled) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 计算跳帧情况&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; jitterNanos &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; startNanos &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; frameTimeNanos;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (jitterNanos &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; mFrameIntervalNanos) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; skippedFrames &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; jitterNanos &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; mFrameIntervalNanos;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 超过阈值打印警告日志&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (skippedFrames &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; SKIPPED_FRAME_WARNING_LIMIT) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                Log.&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;(TAG, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Skipped &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; skippedFrames &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; frames!&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            frameTimeNanos &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ...; &lt;span style=&#34;color:#75715e&#34;&gt;// 调整帧时间&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        mLastFrameTimeNanos &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; frameTimeNanos;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        mFrameScheduled &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 按优先级顺序执行回调&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        mFrameInfo.&lt;span style=&#34;color:#a6e22e&#34;&gt;markInputHandlingStart&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        doCallbacks(Choreographer.&lt;span style=&#34;color:#a6e22e&#34;&gt;CALLBACK_INPUT&lt;/span&gt;, frameTimeNanos);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        mFrameInfo.&lt;span style=&#34;color:#a6e22e&#34;&gt;markAnimationsStart&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        doCallbacks(Choreographer.&lt;span style=&#34;color:#a6e22e&#34;&gt;CALLBACK_ANIMATION&lt;/span&gt;, frameTimeNanos);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        mFrameInfo.&lt;span style=&#34;color:#a6e22e&#34;&gt;markPerformTraversalsStart&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        doCallbacks(Choreographer.&lt;span style=&#34;color:#a6e22e&#34;&gt;CALLBACK_TRAVERSAL&lt;/span&gt;, frameTimeNanos);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        doCallbacks(Choreographer.&lt;span style=&#34;color:#a6e22e&#34;&gt;CALLBACK_COMMIT&lt;/span&gt;, frameTimeNanos);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#66d9ef&#34;&gt;finally&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 清理工作&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;五回调执行处理&#34;&gt;五、回调执行处理
&lt;/h4&gt;&lt;h5 id=&#34;1-执行回调核心逻辑&#34;&gt;1. 执行回调核心逻辑
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;doCallbacks&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; callbackType, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; frameTimeNanos) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    CallbackRecord callbacks;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; (mLock) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 提取所有到期的回调&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; now &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; frameTimeNanos &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; NANOS_PER_MS;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        callbacks &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mCallbackQueues&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;callbackType&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;extractDueCallbacksLocked&lt;/span&gt;(now);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (callbacks &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        mCallbacksRunning &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 执行链表中的所有回调&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (CallbackRecord c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; callbacks; c &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;; c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 执行回调&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (c.&lt;span style=&#34;color:#a6e22e&#34;&gt;action&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;instanceof&lt;/span&gt; Runnable) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                ((Runnable) c.&lt;span style=&#34;color:#a6e22e&#34;&gt;action&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                ((FrameCallback) c.&lt;span style=&#34;color:#a6e22e&#34;&gt;action&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;doFrame&lt;/span&gt;(frameTimeNanos);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#66d9ef&#34;&gt;finally&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;synchronized&lt;/span&gt; (mLock) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 回收CallbackRecord对象&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            recycleCallbackRecordsLocked(callbacks);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            mCallbacksRunning &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;2到期回调提取算法&#34;&gt;2.到期回调提取算法
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CallbackRecord &lt;span style=&#34;color:#a6e22e&#34;&gt;extractDueCallbacksLocked&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; now) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    CallbackRecord callbacks &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    CallbackRecord next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mHead;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 遍历链表，找出所有dueTime&amp;lt;=now的节点&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (next &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; next.&lt;span style=&#34;color:#a6e22e&#34;&gt;dueTime&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; now) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        CallbackRecord temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        temp.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; callbacks;  &lt;span style=&#34;color:#75715e&#34;&gt;// 新节点插入链表头部&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        callbacks &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; temp;       &lt;span style=&#34;color:#75715e&#34;&gt;// 新链表头&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 更新原链表&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    mHead &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 返回的是倒序链表（最近加入的先执行）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; callbacks;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;六choreographer的其他作用&#34;&gt;六、Choreographer的其他作用
&lt;/h4&gt;&lt;h5 id=&#34;1-帧率监控&#34;&gt;1. 帧率监控
&lt;/h5&gt;&lt;p&gt;开发者可以通过postFrameCallback实现帧率监控：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;startMonitoring&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Choreographer.&lt;span style=&#34;color:#a6e22e&#34;&gt;getInstance&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;postFrameCallback&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; FrameCallback() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; lastFrameTime &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;@Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;doFrame&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; frameTimeNanos) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (lastFrameTime &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; 0) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; frameInterval &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (frameTimeNanos &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; lastFrameTime) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; 1000000;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (frameInterval &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; 16) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#75715e&#34;&gt;// 记录掉帧情况&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            lastFrameTime &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; frameTimeNanos;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            Choreographer.&lt;span style=&#34;color:#a6e22e&#34;&gt;getInstance&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;postFrameCallback&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;七总结&#34;&gt;七、总结
&lt;/h4&gt;&lt;p&gt;Choreographer 是 Android 渲染系统的核心协调器，其工作原理可以概括为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;任务管理&lt;/strong&gt;：通过 5 个链表队列管理不同优先级的回调任务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入 &amp;gt; 动画 &amp;gt; 插入动画 &amp;gt; 视图遍历 &amp;gt; 提交&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;VSYNC 同步&lt;/strong&gt;：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;scheduleVsync() → DisplayEventReceiver → onVsync() → doFrame()
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;帧生命周期&lt;/strong&gt;：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;doFrame() → 
  doCallbacks(INPUT) → 
  doCallbacks(ANIMATION) → 
  doCallbacks(TRAVERSAL) → 
  doCallbacks(COMMIT)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;性能监控&lt;/strong&gt;：内置跳帧检测和警告机制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;系统协调&lt;/strong&gt;：作为动画系统、UI 系统、输入系统的同步中枢&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;整个设计体现了 Android 系统对以下关键目标的平衡：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;精确性&lt;/strong&gt;：通过 VSYNC 精准同步&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高效性&lt;/strong&gt;：链表结构和对象复用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优先级&lt;/strong&gt;：严格的分级回调顺序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩展性&lt;/strong&gt;：支持多种回调类型&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;监控能力&lt;/strong&gt;：内置性能检测机制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;scheduleVsync()&lt;/code&gt; 的唯一目的就是在 VSYNC 到来时触发 &lt;code&gt;doFrame()&lt;/code&gt;&lt;/strong&gt;，而整个 Choreographer 的核心任务就是确保所有帧处理操作完美对齐 VSYNC 时间序列。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>包体积优化</title>
        <link>http://localhost:1313/android-develop/%E5%8C%85%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96/</link>
        <pubDate>Sun, 15 Jun 2025 23:19:59 +0800</pubDate>
        
        <guid>http://localhost:1313/android-develop/%E5%8C%85%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96/</guid>
        <description>&lt;h4 id=&#34;包体积优化&#34;&gt;包体积优化
&lt;/h4&gt;&lt;h4 id=&#34;一apk结构分析工具&#34;&gt;一、APK结构分析工具
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;Android Studio内置工具
&lt;ul&gt;
&lt;li&gt;使用 Build &amp;gt; Analyze APK&lt;/li&gt;
&lt;li&gt;查看各模块占比(代码/资源/原生库/Assets)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;命令行工具&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./gradlew :app:assembleRelease --scan
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;二代码优化&#34;&gt;二、代码优化
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;启用代码混淆与优化&lt;/li&gt;
&lt;li&gt;移除未使用代码
&lt;ul&gt;
&lt;li&gt;使用android studio的lint分析未使用代码&lt;/li&gt;
&lt;li&gt;添加R8配置文件删除无引用代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;方法数优化
&lt;ul&gt;
&lt;li&gt;启用Multidex前优化&lt;/li&gt;
&lt;li&gt;使用D8编译器的dex优化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;三资源优化&#34;&gt;三、资源优化
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;资源压缩与清理&lt;/li&gt;
&lt;li&gt;移除未使用资源&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 检测未使用资源&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./gradlew lintRelease
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 自动移除&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;./gradlew removeUnusedResources
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;矢量图代替位图&lt;/li&gt;
&lt;li&gt;Webp格式转换&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;四库优化&#34;&gt;四、库优化
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;仅保留必要ABI&lt;/li&gt;
&lt;li&gt;轻量库代替&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;五高级优化技术&#34;&gt;五、高级优化技术
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;资源混淆&lt;/li&gt;
&lt;li&gt;资源分包加载&lt;/li&gt;
&lt;li&gt;按需加载功能模块&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;六--assets优化&#34;&gt;六 、 Assets优化
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;压缩assets资源：存储时压缩，使用时解压&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;七知识补充&#34;&gt;七、知识补充
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;D8、R8和代码混淆的关系
&lt;ul&gt;
&lt;li&gt;D8负责字节码到Dex的精确转换&lt;/li&gt;
&lt;li&gt;R8 = D8 + 裁剪 + 优化 + 混淆&lt;/li&gt;
&lt;li&gt;混淆是R8的战术武器：仅负责名称混淆（对体积影响小，对安全性关键）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开启R8 ≈ D8编译 + 三重优化(裁剪/优化/混淆)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>内存管理最佳实践</title>
        <link>http://localhost:1313/android-develop/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link>
        <pubDate>Sun, 15 Jun 2025 13:05:49 +0800</pubDate>
        
        <guid>http://localhost:1313/android-develop/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid>
        <description>&lt;h4 id=&#34;一内存管理原则&#34;&gt;一、内存管理原则
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;理解Android内存模型
&lt;ul&gt;
&lt;li&gt;基于JVM垃圾回收机制，采用分代回收策略&lt;/li&gt;
&lt;li&gt;内存不足是触发&lt;code&gt;onTrimMemory()&lt;/code&gt;，开发者需响应此回调释放资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;避免内存泄漏根源
&lt;ul&gt;
&lt;li&gt;静态引用：禁止用static持有Activity/Context（用Application Context代替）&lt;/li&gt;
&lt;li&gt;非静态内部类：改用静态内部类+弱引用&lt;/li&gt;
&lt;li&gt;资源未释放：关闭Cursor、File、Bitmap等资源。gc只释放java对象本身，在jvm堆中，系统资源需要显示释放&lt;/li&gt;
&lt;li&gt;集合对象：及时清理无用的集合元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优化关键组件
&lt;ul&gt;
&lt;li&gt;Activity/Fragment
&lt;ul&gt;
&lt;li&gt;在onDestroy中解除BroadcastReceiver、Handler注册，移除回调&lt;/li&gt;
&lt;li&gt;避免在异步任务中直接引用View&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Handler
&lt;ul&gt;
&lt;li&gt;使用静态内部类 + WeakReference。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;单例模式
&lt;ul&gt;
&lt;li&gt;传递Application Context，而非Activity Context&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;大对象优化
&lt;ul&gt;
&lt;li&gt;Bitmap
&lt;ul&gt;
&lt;li&gt;使用inSampleSize压缩图片，采用Glide等库管理内存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据缓存
&lt;ul&gt;
&lt;li&gt;优先使用LruCache和DiskLruCache&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;二内存泄漏排查工具&#34;&gt;二、内存泄漏排查工具
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;Android Profiler&lt;/li&gt;
&lt;li&gt;LeakCanary&lt;/li&gt;
&lt;li&gt;MAT&lt;/li&gt;
&lt;li&gt;StrictMode&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;二内存泄漏排查工具-1&#34;&gt;&lt;strong&gt;二、内存泄漏排查工具&lt;/strong&gt;
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Android Profiler（Android Studio）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内存监控&lt;/strong&gt;：实时查看堆内存使用情况。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Heap Dump&lt;/strong&gt;：捕获堆快照，分析对象引用链。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Allocation Tracker&lt;/strong&gt;：跟踪短时间内的内存分配。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;LeakCanary（自动化检测）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;集成步骤：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;debugImplementation &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;com.squareup.leakcanary:leakcanary-android:2.9.1&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自动检测泄漏并生成报告，定位泄漏引用链。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;MAT（Memory Analyzer Tool）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;分析Heap Dump步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用Android Profiler导出&lt;code&gt;.hprof&lt;/code&gt;文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过&lt;code&gt;hprof-conv&lt;/code&gt;转换格式（Android SDK工具）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;hprof-conv input.hprof output.hprof
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在MAT中打开，通过&lt;strong&gt;Dominator Tree&lt;/strong&gt;和&lt;strong&gt;Path to GC Roots&lt;/strong&gt;分析泄漏对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;StrictMode&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;检测主线程磁盘/网络操作，间接避免内存问题：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;StrictMode.&lt;span style=&#34;color:#a6e22e&#34;&gt;setVmPolicy&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; VmPolicy.&lt;span style=&#34;color:#a6e22e&#34;&gt;Builder&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .&lt;span style=&#34;color:#a6e22e&#34;&gt;detectActivityLeaks&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .&lt;span style=&#34;color:#a6e22e&#34;&gt;detectLeakedClosableObjects&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .&lt;span style=&#34;color:#a6e22e&#34;&gt;penaltyLog&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .&lt;span style=&#34;color:#a6e22e&#34;&gt;build&lt;/span&gt;());
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>View性能优化</title>
        <link>http://localhost:1313/android-develop/view%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
        <pubDate>Fri, 13 Jun 2025 23:55:35 +0800</pubDate>
        
        <guid>http://localhost:1313/android-develop/view%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
        <description>&lt;h3 id=&#34;android-view-性能优化体系&#34;&gt;Android View 性能优化体系
&lt;/h3&gt;&lt;hr&gt;
&lt;h3 id=&#34;一规避过度绘制gpu优化&#34;&gt;一、规避过度绘制（GPU优化）
&lt;/h3&gt;&lt;p&gt;专注于减少GPU的无效像素填充负载&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;概念解析：&lt;/strong&gt;&lt;br&gt;
GPU在单个像素点重复绘制超过2.5次（1x绘制+1.5x半透明混合）的现象，消耗填充率导致帧率下降&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;检测工具：&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;开发者选项-&amp;gt;调试GPU过度绘制&lt;/code&gt;（蓝色&amp;lt;1x, 绿色&amp;lt;2x, 粉色&amp;lt;3x, 红色≥4x）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;核心策略：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;移除无效背景层：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;检查并移除Activity根布局或主题中冗余的&lt;code&gt;windowBackground&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除被完全覆盖的中间层布局（如FrameLayout）背景&lt;/li&gt;
&lt;li&gt;避免在自定义View的&lt;code&gt;onDraw()&lt;/code&gt;中绘制被覆盖区域&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;层级扁平化：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;ConstraintLayout&lt;/code&gt;替代多层嵌套布局&lt;/li&gt;
&lt;li&gt;减少RelativeLayout导致的二次测量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;透明效果控制：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;避免大面积半透明视图（引发GPU混合计算）&lt;/li&gt;
&lt;li&gt;硬件层动画结束时立即禁用（&lt;code&gt;setLayerType(LAYER_TYPE_NONE)&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引用关键通用技术：&lt;/strong&gt;&lt;br&gt;
结合&lt;code&gt;clipRect/quickReject&lt;/code&gt;限定绘制区域（详见通用技术章节）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;二绘制指令优化cpu优化&#34;&gt;二、绘制指令优化（CPU优化）
&lt;/h3&gt;&lt;p&gt;降低CPU生成绘制指令的开销&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优化焦点：&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;onDraw()&lt;/code&gt;方法的执行效率与资源管理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;核心准则：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;禁止内存分配：&lt;/strong&gt;&lt;br&gt;
绝不在&lt;code&gt;onDraw()&lt;/code&gt;中创建Paint/Path/Bitmap对象（应在构造方法初始化）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;规避耗时操作：&lt;/strong&gt;&lt;br&gt;
避免复杂计算、IO或解析逻辑&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阻断递归触发：&lt;/strong&gt;&lt;br&gt;
禁止在&lt;code&gt;onDraw()&lt;/code&gt;中调用&lt;code&gt;invalidate()&lt;/code&gt;或&lt;code&gt;requestLayout()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高级技巧：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;绘图资源复用：&lt;/strong&gt;&lt;br&gt;
对矢量图(VectorDrawable)和位图采用不同优化策略
&lt;ul&gt;
&lt;li&gt;小图标优先使用矢量图&lt;/li&gt;
&lt;li&gt;位图加载启用&lt;code&gt;inSampleSize&lt;/code&gt;采样和&lt;code&gt;RGB_565&lt;/code&gt;解码&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;ImageView.setImageDrawable()&lt;/code&gt;替代&lt;code&gt;canvas.drawBitmap()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;透明效果实现：&lt;/strong&gt;&lt;br&gt;
优先使用&lt;code&gt;View.setAlpha()&lt;/code&gt;而非半透明背景色&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引用关键通用技术：&lt;/strong&gt;&lt;br&gt;
精准控制硬件加速生命周期（详见通用技术章节）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;三通用核心技术&#34;&gt;三、通用核心技术
&lt;/h3&gt;&lt;p&gt;跨优化领域的共性技术方案&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;区域裁剪技术：&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;graph TB
  A[canvas.clipRect] --&amp;gt; B[限定子View绘制区域]
  C[canvas.quickReject] --&amp;gt; D[跳过屏幕外区域绘制]
  A--&amp;gt;|ViewGroup| E[重写dispatchDraw控制]
  C--&amp;gt;|自定义View| F[onDraw中预判可见性]
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;ViewGroup.drawChild&lt;/code&gt;中限定子View绘制边界&lt;/li&gt;
&lt;li&gt;列表项等非重叠视图必备优化手段&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;硬件加速深度指南：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;运作机制：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将View缓存为GPU纹理(Texture)&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;setLayerType(LAYER_TYPE_HARDWARE, null)&lt;/code&gt;启用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;最佳实践：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 动画开始前启用&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;view.&lt;span style=&#34;color:#a6e22e&#34;&gt;setLayerType&lt;/span&gt;(LAYER_TYPE_HARDWARE, &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ObjectAnimator.&lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 动画结束后立即释放&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;animator.&lt;span style=&#34;color:#a6e22e&#34;&gt;addListener&lt;/span&gt;(() &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    view.&lt;span style=&#34;color:#a6e22e&#34;&gt;setLayerType&lt;/span&gt;(LAYER_TYPE_NONE, &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;开销预警：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;离屏缓冲增加20%-30%内存占用&lt;/li&gt;
&lt;li&gt;静态视图启用反而降低性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;圆角处理方案：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;实现方式&lt;/th&gt;
          &lt;th&gt;适用场景&lt;/th&gt;
          &lt;th&gt;性能影响&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;ViewOutlineProvider&lt;/td&gt;
          &lt;td&gt;小面积圆角&lt;/td&gt;
          &lt;td&gt;★★☆&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;.9.png贴图&lt;/td&gt;
          &lt;td&gt;固定尺寸元素&lt;/td&gt;
          &lt;td&gt;★☆☆&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;绘制圆角矩形&lt;/td&gt;
          &lt;td&gt;动态尺寸视图&lt;/td&gt;
          &lt;td&gt;★★☆&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;clipToOutline&lt;/td&gt;
          &lt;td&gt;避免大面积使用&lt;/td&gt;
          &lt;td&gt;★★★&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;四布局优化独立模块&#34;&gt;四、布局优化（独立模块）
&lt;/h3&gt;&lt;p&gt;优化测量(measure)与布局(layout)阶段性能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;检测工具：&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Profile GPU Rendering&lt;/code&gt;分析各阶段耗时&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优化策略：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;层级压缩：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;使用ConstraintLayout减少嵌套&lt;/li&gt;
&lt;li&gt;避免LinearLayout权重导致的二次测量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态加载：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;merge&amp;gt;&lt;/code&gt;消除冗余容器层&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ViewStub&lt;/code&gt;延迟加载隐藏视图&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自定义布局优化：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;缓存&lt;code&gt;onMeasure()&lt;/code&gt;计算结果&lt;/li&gt;
&lt;li&gt;只测量可见子View&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;优化关联图谱&#34;&gt;优化关联图谱
&lt;/h3&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;flowchart TD
    A[性能优化] --&amp;gt; B[GPU负载]
    A --&amp;gt; C[CPU负载]
    B --&amp;gt; D[过度绘制优化]
    C --&amp;gt; E[布局计算优化]
    C --&amp;gt; F[绘制指令优化]
    D &amp;amp; F --&amp;gt; G[通用技术]
    G --&amp;gt; H[区域裁剪]
    G --&amp;gt; I[硬件加速]
    G --&amp;gt; J[圆角处理]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该重组方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;完整保留原文所有技术点&lt;/li&gt;
&lt;li&gt;消除硬件加速/clipRect等技术点的重复描述&lt;/li&gt;
&lt;li&gt;建立清晰的「GPU优化-CPU优化-通用技术」逻辑链路&lt;/li&gt;
&lt;li&gt;通过流程图和表格提升关键技术的可操作性&lt;/li&gt;
&lt;li&gt;维持与原文档相同的技术细节颗粒度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最终形成的体系逻辑：&lt;br&gt;
&lt;strong&gt;GPU优化&lt;/strong&gt;解决&amp;quot;绘制次数&amp;quot;问题 → &lt;strong&gt;CPU优化&lt;/strong&gt;解决&amp;quot;绘制效率&amp;quot;问题 → &lt;strong&gt;通用技术&lt;/strong&gt;提供跨领域解决方案 → &lt;strong&gt;布局优化&lt;/strong&gt;作为独立并行模块&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;canvas.save()&lt;/code&gt;: 将当前&lt;strong&gt;绘制状态&lt;/strong&gt;（矩阵变换/裁剪区域/图层属性）存入栈中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;canvas.restore()&lt;/code&gt;: 从栈顶取出最近保存的状态并恢复&lt;/li&gt;
&lt;li&gt;&lt;code&gt;canvas.quickReject()&lt;/code&gt;:快速判断指定矩形区域是否&lt;strong&gt;完全位于当前裁剪区域外&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>关于硬件加速</title>
        <link>http://localhost:1313/android-develop/%E5%85%B3%E4%BA%8E%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/</link>
        <pubDate>Fri, 13 Jun 2025 22:50:57 +0800</pubDate>
        
        <guid>http://localhost:1313/android-develop/%E5%85%B3%E4%BA%8E%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/</guid>
        <description>&lt;h4 id=&#34;一硬件加速核心概念&#34;&gt;一、硬件加速核心概念
&lt;/h4&gt;&lt;p&gt;硬件加速是将图形渲染中的光栅化从CPU转移到GPU执行的技术。CPU只需要生成&lt;strong&gt;绘制指令集(DisplayList)&lt;/strong&gt;，由GPU进行高效的并行光栅化计算，最终写入图形缓冲区提供屏幕显示。&lt;/p&gt;
&lt;p&gt;本质：CPU负责逻辑指令，GPU负责繁重像素计算，分工协作提升效率&lt;/p&gt;
&lt;p&gt;光栅化：可以高度抽象的概括为&lt;strong&gt;计算屏幕上每个像素点最终显示的ARGB值&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;二硬件加速启用前后的核心流程对比&#34;&gt;二、硬件加速启用前后的核心流程对比
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;未启用硬件加速&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;measure &amp;amp; layout&lt;/strong&gt;：由CPU在主线程（UI线程）执行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Draw&lt;/strong&gt;（关键区别）：
&lt;ul&gt;
&lt;li&gt;CPU：遍历View树，在主线程直接执行每个View的onDraw(Canvas)方法&lt;/li&gt;
&lt;li&gt;光栅化：onDraw中的绘制指令也由CPU执行，直接计算出最终的像素值。&lt;/li&gt;
&lt;li&gt;缓冲区(Frame Buffer)
&lt;ul&gt;
&lt;li&gt;系统维护一个帧缓冲区。&lt;/li&gt;
&lt;li&gt;CPU光栅化好的像素数据直接写入这个帧缓冲区&lt;/li&gt;
&lt;li&gt;核心：CPU既处理逻辑计算又处理生成最终像素的繁重计算(光栅化)，然后把结果放进帧缓冲&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;合成 &amp;amp; 显示&lt;/strong&gt;：屏幕读取帧缓冲区的内容显示到屏幕上。这个过程通常涉及双缓冲和Vsync信号来避免撕裂，但其绘制核心是CPU
&lt;ul&gt;
&lt;li&gt;Front Buffer是屏幕当前帧显示的内容，Back Buffer是屏幕下一帧要显示的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开启硬件加速&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Measure &amp;amp; Layout&lt;/strong&gt;：仍然由CPU在主线程执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Draw&lt;/strong&gt;(关键区别)：
&lt;ul&gt;
&lt;li&gt;CPU：遍历View树，在主线程执行每个View的**&lt;code&gt;onDraw(Canvas)&lt;/code&gt;**方法。但是这里的&lt;code&gt;Canvas&lt;/code&gt;行为不同了&lt;/li&gt;
&lt;li&gt;Display List：onDraw(Canvas)中的绘制指令不再立即光栅化，而是被记录到DisplayList的数据结构中。DisplayList本质是一系列GPU能理解的绘图操作指令的序列化表示&lt;/li&gt;
&lt;li&gt;光栅化：由GPU执行，CPU将构建好的&lt;code&gt;DisplayList&lt;/code&gt;提交给GPU。GPU驱动程序将这些高级绘图指令&lt;strong&gt;并行地、高效地光栅化&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓冲区&lt;/strong&gt;(Frame Buffer / GRALLOC Buffers):
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;普通开启硬件加速时的缓冲区：&lt;/strong&gt; GPU 将光栅化&lt;strong&gt;好的像素数据写入系统分配的图形缓冲区&lt;/strong&gt; (通常是通过 &lt;code&gt;Gralloc&lt;/code&gt; 分配管理的 Buffer Queue 中的缓冲区，如 &lt;code&gt;SurfaceTexture&lt;/code&gt;)。这些缓冲区&lt;strong&gt;就是屏幕最终合成时使用的像素数据源&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;核心：CPU负责记录绘制命令(onDraw -&amp;gt; DisplayList)；GPU负责光栅化，结果写入图形缓冲区&lt;/li&gt;
&lt;li&gt;Frame Buffer是抽象的缓冲区，而GRALLOC Buffers是物理缓冲区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;三启用硬件层&#34;&gt;三、启用硬件层
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;目的&lt;/strong&gt;：对像素不会频繁变化的View采用空间换时间的方案，避免View内容未变时重复光栅化，用于后续快速合成&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：仅当视图内容改变(&lt;code&gt;invalidate()&lt;/code&gt;)时或主动更新时：GPU重新光栅化该View的DisplayList -&amp;gt; 更新离屏纹理。而只涉及纹理的变换时，不会重新光栅化DisplayList，而是直接使用纹理缓存进行合成，纹理变换正是GPU擅长的。纹理变换和opengl管线工作流程中的顶点变换是不同的层级概念&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最佳实践&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;适合&lt;strong&gt;小面积静态视图&lt;/strong&gt;或&lt;strong&gt;属性动画&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;避免对大视图（如列表视图）启用，易耗尽显存&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>面试问题收集</title>
        <link>http://localhost:1313/android-develop/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/</link>
        <pubDate>Fri, 13 Jun 2025 09:30:56 +0800</pubDate>
        
        <guid>http://localhost:1313/android-develop/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/</guid>
        <description>&lt;h4 id=&#34;一bitmap内存优化&#34;&gt;一、Bitmap内存优化
&lt;/h4&gt;&lt;p&gt;Bitmap是内存消耗大户，通过以下方法减少占用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;降低色彩解析模式&lt;/strong&gt;&lt;br&gt;
使用RGB565等低色彩模式，将单个像素的字节大小从32位（ARGB8888）减少到16位，显著节省内存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;合理放置资源文件&lt;/strong&gt;&lt;br&gt;
高分辨率图片应放置在高密度目录（如&lt;code&gt;drawable-xxhdpi&lt;/code&gt;），避免系统自动缩放导致内存浪费。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缩小图片尺寸&lt;/strong&gt;&lt;br&gt;
加载时通过&lt;code&gt;BitmapFactory.Options&lt;/code&gt;动态调整采样率（&lt;code&gt;inSampleSize&lt;/code&gt;），或使用&lt;code&gt;createScaledBitmap()&lt;/code&gt;减少宽高尺寸。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h4 id=&#34;二viewmodel与livedata机制&#34;&gt;二、ViewModel与LiveData机制
&lt;/h4&gt;&lt;p&gt;ViewModel和LiveData是Jetpack组件，用于数据生命周期管理和响应式UI更新。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;粘性事件（Sticky Event）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：当新观察者订阅&lt;code&gt;LiveData&lt;/code&gt;时，若已有存储值，会立即收到最后一次更新（旧数据）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：屏幕旋转后，新Activity观察LiveData时触发UI更新（旧数据）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;来源&lt;/strong&gt;：基于LiveData的版本号对比机制。代码关键部分如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LiveData&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; mVersion &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; START_VERSION; &lt;span style=&#34;color:#75715e&#34;&gt;// LiveData当前版本（初始-1）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LifecycleBoundObserver&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;implements&lt;/span&gt; ObserverWrapper {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; mLastVersion &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; START_VERSION;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;considerNotify&lt;/span&gt;(ObserverWrapper observer) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (observer.&lt;span style=&#34;color:#a6e22e&#34;&gt;mLastVersion&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; mVersion) { &lt;span style=&#34;color:#75715e&#34;&gt;// 核心判断：版本号落后才分发&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      observer.&lt;span style=&#34;color:#a6e22e&#34;&gt;mLastVersion&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mVersion;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      observer.&lt;span style=&#34;color:#a6e22e&#34;&gt;mObserver&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;onChanged&lt;/span&gt;((T)data);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;简单解法&lt;/strong&gt;：使用&lt;code&gt;Event&lt;/code&gt;包装数据。事件消费后置空值，避免旧数据触发更新。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;但是这个不支持多观察者&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;SharedFlow&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ViewModel临时数据保存机制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内存中保存&lt;/strong&gt;&lt;br&gt;
ViewModel对象存储在&lt;code&gt;ViewModelStore&lt;/code&gt;中。当配置变更（如屏幕旋转）时：
&lt;ul&gt;
&lt;li&gt;Activity/Fragment被销毁重建。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ViewModelStore&lt;/code&gt;被系统保留（绑定到&lt;code&gt;NonConfigurationInstances&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;新建Activity/Fragment时自动恢复ViewModel实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据范围与最佳实践&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;保留场景&lt;/strong&gt;：屏幕旋转、分屏切换、系统语言更改。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不保留场景&lt;/strong&gt;：用户退出应用、系统资源不足杀死进程、Activity被finish()。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最佳实践&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;ViewModel解决配置变更的&lt;strong&gt;临时数据保存&lt;/strong&gt;（内存级）。&lt;/li&gt;
&lt;li&gt;在ViewModel使用&lt;code&gt;SavedStateHandle&lt;/code&gt;解决进程被杀死时的&lt;strong&gt;关键数据持久化&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;复杂数据应使用数据库等持久化方案。&lt;/li&gt;
&lt;li&gt;避免内存泄漏：勿在ViewModel持有Context/View引用，必要时用&lt;code&gt;Application Context&lt;/code&gt;代替。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h4 id=&#34;三view基础原理&#34;&gt;三、View基础原理
&lt;/h4&gt;&lt;p&gt;深入理解View的测量、布局、绘制机制，是优化UI性能的核心。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;MeasureSpec计算与布局优化&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MeasureSpec原理&lt;/strong&gt;：父容器传递给子View的测量要求，由大小和模式组成，取决于父容器的MeasureSpec和子View的LayoutParams。
&lt;ul&gt;
&lt;li&gt;父布局根据自身MeasureSpec和子View LayoutParams，确定子View的MeasureSpec，再调用&lt;code&gt;children.measure()&lt;/code&gt;，最终确定自身尺寸。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;布局性能优化&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;缓存MeasureSpec计算结果：固定尺寸View（如按钮）直接调用&lt;code&gt;setMeasuredDimension()&lt;/code&gt;设置宽高。&lt;/li&gt;
&lt;li&gt;优化布局流程：减少嵌套层级、懒加载布局、合并重复布局。&lt;/li&gt;
&lt;li&gt;避免无效重绘：使用局部刷新机制。&lt;/li&gt;
&lt;li&gt;精确控制绘制范围：通过&lt;code&gt;Canvas.clipRect()&lt;/code&gt;限制绘制区域。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;getMeasuredWidth()与getWidth()区别&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;getMeasuredWidth()&lt;/strong&gt;：测量阶段后分配的宽度（含内边距）。
&lt;ul&gt;
&lt;li&gt;使用时机：&lt;code&gt;onMeasure()&lt;/code&gt;后或&lt;code&gt;layout()&lt;/code&gt;前。&lt;/li&gt;
&lt;li&gt;特点：反映视图的期望宽度；若布局未强制改变尺寸，可能与&lt;code&gt;getWidth&lt;/code&gt;相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;getWidth()&lt;/strong&gt;：布局阶段后的最终可见宽度（屏幕实际值）。
&lt;ul&gt;
&lt;li&gt;使用时机：&lt;code&gt;onLayout&lt;/code&gt;后。&lt;/li&gt;
&lt;li&gt;计算方式：&lt;code&gt;width = right - left&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;requestLayout()与invalidate()区别&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;requestLayout()&lt;/strong&gt;：请求整个视图树的测量（measure）和布局（layout）流程。
&lt;ul&gt;
&lt;li&gt;触发场景：视图尺寸/位置变化、动态添加/移除子视图、&lt;code&gt;setVisibility()&lt;/code&gt;导致布局结构变化。&lt;/li&gt;
&lt;li&gt;执行流程：从当前视图向上回溯到根视图（如ViewRootImpl），依次执行measure → layout。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;invalidate()&lt;/strong&gt;：仅标记视图的局部区域为“脏区”，请求下一帧重绘该区域。
&lt;ul&gt;
&lt;li&gt;触发场景：视图内容变化但不影响尺寸/位置（如&lt;code&gt;onDraw()&lt;/code&gt;依赖数据更新）。&lt;/li&gt;
&lt;li&gt;执行流程：标记脏区 → 加入重绘队列 → 下一帧VSync信号时调用&lt;code&gt;onDraw()&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;View坐标体系&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;getX()/getY()&lt;/strong&gt;：相对当前View左上角的局部坐标（触摸点在View内的位置）。
&lt;ul&gt;
&lt;li&gt;特点：与父容器无关；值可为负（如滑动超出View边界）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;getRawX()/getRawY()&lt;/strong&gt;：相对屏幕左上角的全局坐标。
&lt;ul&gt;
&lt;li&gt;特点：包含状态栏高度（&lt;code&gt;getRawY()&lt;/code&gt;从屏幕顶部算起）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;getLocationOnScreen()&lt;/strong&gt;：获取View左上角在屏幕上的绝对坐标。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;View生命周期关键方法&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;构造函数&lt;/strong&gt;：通过代码或XML创建View实例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;onAttachedToWindow()&lt;/strong&gt;：View被添加到窗口时调用。
&lt;ul&gt;
&lt;li&gt;用途：初始化资源、注册监听器、启动动画。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;onDetachedFromWindow()&lt;/strong&gt;：View从窗口移除时调用（如Activity销毁）。
&lt;ul&gt;
&lt;li&gt;关键作用：释放资源、停止动画、注销监听器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;onVisibilityChanged()&lt;/code&gt;可能在&lt;code&gt;onAttachedToWindow()&lt;/code&gt;前/后调用（如View初始化为&lt;code&gt;GONE&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;onWindowFocusChanged()&lt;/code&gt;可能在&lt;code&gt;onDetachedFromWindow()&lt;/code&gt;后调用（避免在此访问资源）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;View性能优化&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;过度绘制：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;概念：GPU在一个像素点上绘制了多次的现象。系统默认允许2.5次（1x绘制 + 1.5x半透明混合）&lt;/li&gt;
&lt;li&gt;主要优化策略
&lt;ul&gt;
&lt;li&gt;移除不必要的背景&lt;/li&gt;
&lt;li&gt;减少View的层级深度&lt;/li&gt;
&lt;li&gt;谨慎使用半透明或**&lt;code&gt;setLayerType(LAYER_TYPE_HARDWARE)&lt;/code&gt;**&lt;/li&gt;
&lt;li&gt;优化&lt;code&gt;clipRect&lt;/code&gt;和&lt;code&gt;quickReject&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;布局优化：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;概念：指测量和布局阶段的性能优化。CPU需要遍历View树计算每个View的大小和位置&lt;/li&gt;
&lt;li&gt;优化策略：
&lt;ul&gt;
&lt;li&gt;减少嵌套层级&lt;/li&gt;
&lt;li&gt;使用高效布局标签（merge、include、ViewStub）&lt;/li&gt;
&lt;li&gt;优化&lt;code&gt;onMeasure&lt;/code&gt;/&lt;code&gt;onLayout&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;绘制优化：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;概念：指实际调用View.onDraw方法渲染像素到屏幕的性能优化。CPU准备绘制指令 -&amp;gt;GPU执行绘制&lt;/li&gt;
&lt;li&gt;优化策略
&lt;ul&gt;
&lt;li&gt;优化onDraw()方法：避免内存分配(不在onDraw方法内实例化Paint、Path、Bitmap、Rect对象)，避免耗时操作、避免调用invalidate（避免递归/绘制请求），利用canvas.clipRect和canvas.quickReject(),优先使用矢量图代替位图，使用硬件加速支持的Canvas操作&lt;/li&gt;
&lt;li&gt;谨慎开启Hardware_Layer&lt;/li&gt;
&lt;li&gt;优化alpha通道和透明度&lt;/li&gt;
&lt;li&gt;优化Bitmap加载与显示&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高级机制与原理&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;硬件加速：将绘制指令交给GPU，但是部分api不支持&lt;/li&gt;
&lt;li&gt;SurfaceView与TextureView：todo&lt;/li&gt;
&lt;li&gt;view.post与Handler：todo&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h4 id=&#34;四事件分发机制&#34;&gt;四、事件分发机制
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;滑动实现方式&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;scrollTo()&lt;/code&gt;/&lt;code&gt;scrollBy()&lt;/code&gt;&lt;/strong&gt;: scrollTo()是直接跳转到指定位置，scrollBy是相对移动，基于当前位置滑动指定偏移量&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;ViewDragHelper&lt;/code&gt;实现复杂拖拽: todo&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自定义下拉刷新控件&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;todo&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件分发机制如何提升效率&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;todo&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;嵌套滑动处理&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;todo&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RecyclerView的滑动冲突处理&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;todo&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h4 id=&#34;五handler&#34;&gt;五、Handler
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h4 id=&#34;六性能优化-todo&#34;&gt;六、性能优化 （todo）
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;内存管理与泄漏排查&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UI渲染性能(卡顿优化)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;启动速度优化&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功耗优化基础&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;包体积优化&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h4 id=&#34;七常用库与框架todo&#34;&gt;七、常用库与框架（todo）
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;网络请求(如Retrofit)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;图片加载(如Glide / Picasso)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Gradle基础&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h4 id=&#34;八网络与后台&#34;&gt;八、网络与后台
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;RESTful API概念与使用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异步处理深入（线程安全、后台限制）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存策略&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h4 id=&#34;九架构设计&#34;&gt;九、架构设计
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;MVVM/MVI理解与实践&lt;/li&gt;
&lt;li&gt;模块化 / 组件化&lt;/li&gt;
&lt;li&gt;设计模式应用&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h4 id=&#34;十新技术与趋势&#34;&gt;十、新技术与趋势
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;Compose&lt;/li&gt;
&lt;li&gt;KMM / Flutter&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h4 id=&#34;十一jvm--内存模型基础&#34;&gt;十一、JVM / 内存模型基础
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;JVM内存结构&lt;/li&gt;
&lt;li&gt;垃圾回收机制基础&lt;/li&gt;
&lt;li&gt;常见数据结构与基础算法&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>RecyclerView缓存机制</title>
        <link>http://localhost:1313/android-develop/recyclerview%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</link>
        <pubDate>Wed, 11 Jun 2025 15:26:57 +0800</pubDate>
        
        <guid>http://localhost:1313/android-develop/recyclerview%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</guid>
        <description>&lt;p&gt;RecyclerView缓存机制&lt;/p&gt;
&lt;h4 id=&#34;多级缓存体系架构图&#34;&gt;&lt;strong&gt;多级缓存体系架构图&lt;/strong&gt;
&lt;/h4&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;TEXT

RecyclerView 缓存系统
├── 1. 屏幕内缓存 (Attached Scrap)
│   └── 存放当前可见的ViewHolder（快速复用）
├── 2. 屏幕外缓存 (Cache)
│   └── 保存最近离开屏幕的ViewHolder（默认容量=2）
├── 3. 扩展缓存 (ViewCacheExtension)
│   └── 开发者自定义缓存（特殊用途）
└── 4. 回收池 (RecycledViewPool)
    └── 全局共享的ViewHolder存储（不同类型独立缓存）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据&lt;code&gt;position&lt;/code&gt;判断是否命中&lt;code&gt;Cache&lt;/code&gt;，根据&lt;code&gt;viewType&lt;/code&gt;判断是否命中&lt;code&gt;RecyclerViewPool&lt;/code&gt;，会执行&lt;code&gt;onBindViewHolder&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;RecyclerView&lt;/strong&gt; 的回收复用机制中，&lt;code&gt;changedScrap&lt;/code&gt; 和 &lt;code&gt;attachedScrap&lt;/code&gt; 是两个关键临时缓存，而 &lt;strong&gt;Stable IDs&lt;/strong&gt; 会改变 ViewHolder 获取的方式。以下是详细解释：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;1&#34;&gt;&lt;strong&gt;1. &lt;code&gt;changedScrap&lt;/code&gt; 的作用&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用途&lt;/strong&gt;：专门配合 &lt;code&gt;notifyItemChanged()&lt;/code&gt; 或 &lt;code&gt;notifyDataSetChanged()&lt;/code&gt; 使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作机制&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;当调用 &lt;code&gt;notifyItemChanged(position)&lt;/code&gt; 时，被标记更新的 item 会被临时移到 &lt;code&gt;changedScrap&lt;/code&gt; 中。&lt;/li&gt;
&lt;li&gt;在布局阶段（如 &lt;code&gt;onLayout&lt;/code&gt;），这些 ViewHolder 会被重新绑定数据（调用 &lt;code&gt;onBindViewHolder()&lt;/code&gt;），然后放回原位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目的&lt;/strong&gt;：支持局部更新动画（如淡入淡出），避免直接回收导致视觉中断。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2&#34;&gt;&lt;strong&gt;2. &lt;code&gt;attachedScrap&lt;/code&gt; 的作用&lt;/strong&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用途&lt;/strong&gt;：用于 &lt;strong&gt;快速复用可见或即将可见的 ViewHolder&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作机制&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;在布局过程中（如 &lt;code&gt;LinearLayoutManager.fill()&lt;/code&gt;），RecyclerView 会先将当前屏幕上的 ViewHolder &lt;strong&gt;临时移除&lt;/strong&gt; 到 &lt;code&gt;attachedScrap&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;遍历新布局时，直接从 &lt;code&gt;attachedScrap&lt;/code&gt; 中按 &lt;strong&gt;position 匹配&lt;/strong&gt; 取回 ViewHolder（无需创建或绑定）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目的&lt;/strong&gt;：避免无效的创建/绑定，提升滚动性能（尤其在快速滑动时）。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;3-stable-ids-如何改变-viewholder-获取方式&#34;&gt;&lt;strong&gt;3. Stable IDs 如何改变 ViewHolder 获取方式&lt;/strong&gt;
&lt;/h3&gt;&lt;p&gt;当启用 &lt;strong&gt;Stable IDs&lt;/strong&gt;（通过 &lt;code&gt;setHasStableIds(true)&lt;/code&gt; + 重写 &lt;code&gt;getItemId()&lt;/code&gt;）时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;传统方式（无 Stable IDs）&lt;/strong&gt;：&lt;br&gt;
RecyclerView 通过 &lt;strong&gt;position&lt;/strong&gt; 在 &lt;code&gt;attachedScrap&lt;/code&gt; 或 &lt;code&gt;changedScrap&lt;/code&gt; 中查找匹配的 ViewHolder。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 伪代码：按 position 匹配&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ViewHolder vh &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; attachedScrap.&lt;span style=&#34;color:#a6e22e&#34;&gt;findViewForPosition&lt;/span&gt;(position);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;启用 Stable IDs 后&lt;/strong&gt;：&lt;br&gt;
RecyclerView 改为通过 &lt;strong&gt;item ID&lt;/strong&gt;（而非 position）在 &lt;code&gt;scrap&lt;/code&gt; 中查找 ViewHolder：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 伪代码：按 stable ID 匹配&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ViewHolder vh &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; changedScrap.&lt;span style=&#34;color:#a6e22e&#34;&gt;findViewHolderByItemId&lt;/span&gt;(id);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;优势&#34;&gt;&lt;strong&gt;优势&lt;/strong&gt;
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;位置无关复用&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;即使数据集变化导致 item 位置改变（如插入/删除），仍能通过唯一 ID 正确复用 ViewHolder。&lt;/li&gt;
&lt;li&gt;避免因 position 变化导致的 “复用错乱” 问题（如 A 位置复用到 B 数据）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动画兼容性&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;支持更流畅的动画（如 &lt;code&gt;DiffUtil&lt;/code&gt;），因为 ID 是数据项的唯一标识，不受布局顺序影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;效率提升&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;查找操作从 O(N) 优化到 O(1)（基于 &lt;code&gt;LongSparseArray&lt;/code&gt; 实现）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;关键对比总结&#34;&gt;&lt;strong&gt;关键对比总结&lt;/strong&gt;
&lt;/h3&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;特性&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;&lt;code&gt;changedScrap&lt;/code&gt;&lt;/th&gt;
          &lt;th&gt;&lt;code&gt;attachedScrap&lt;/code&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;触发场景&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;notifyItemChanged()&lt;/code&gt; 调用时&lt;/td&gt;
          &lt;td&gt;布局过程中临时移除可见 ViewHolder&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;数据状态&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;需重新绑定（&lt;code&gt;onBindViewHolder&lt;/code&gt;）&lt;/td&gt;
          &lt;td&gt;数据未变，直接复用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;存储内容&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;被标记更新的 ViewHolder&lt;/td&gt;
          &lt;td&gt;当前/即将可见的 ViewHolder&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;查找方式（无 ID）&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;按 &lt;code&gt;position&lt;/code&gt; 匹配&lt;/td&gt;
          &lt;td&gt;按 &lt;code&gt;position&lt;/code&gt; 匹配&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;查找方式（有 ID）&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;按 &lt;code&gt;stableId&lt;/code&gt; 匹配&lt;/td&gt;
          &lt;td&gt;按 &lt;code&gt;stableId&lt;/code&gt; 匹配&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;使用建议&lt;/strong&gt;：&lt;br&gt;
若数据集存在动态位置变化（如排序、增删），强烈建议启用 &lt;strong&gt;Stable IDs&lt;/strong&gt;，以提升复用准确性和动画效果。&lt;/p&gt;&lt;/blockquote&gt;
</description>
        </item>
        
    </channel>
</rss>
