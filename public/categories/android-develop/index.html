<!DOCTYPE html>
<html lang="zh-cn">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>zed的博客</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="The last theme you&#39;ll ever need. Maybe.">
    <meta name="generator" content="Hugo 0.147.8">
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >




    


    
      

    

    
    
      <link href="/categories/android-develop/index.xml" rel="alternate" type="application/rss+xml" title="zed的博客" />
      <link href="/categories/android-develop/index.xml" rel="feed" type="application/rss+xml" title="zed的博客" />
      
    

    
      <link rel="canonical" href="http://localhost:1313/categories/android-develop/">
    

    <meta property="og:url" content="http://localhost:1313/categories/android-develop/">
  <meta property="og:site_name" content="zed的博客">
  <meta property="og:title" content="Android-Develop">
  <meta property="og:description" content="The last theme you&#39;ll ever need. Maybe.">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="website">

  <meta itemprop="name" content="Android-Develop">
  <meta itemprop="description" content="The last theme you&#39;ll ever need. Maybe.">
  <meta itemprop="datePublished" content="2025-06-30T15:13:25+08:00">
  <meta itemprop="dateModified" content="2025-06-30T15:13:25+08:00">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Android-Develop">
  <meta name="twitter:description" content="The last theme you&#39;ll ever need. Maybe.">

	
  </head><body class="ma0 avenir bg-near-white development">

    

  <header>
    <div class="pb3-m pb6-l bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l center items-center justify-between">
    <a href="/" class="f3 fw2 hover-white white-90 dib no-underline">
      
        zed的博客
      
    </a>
    <div class="flex-l items-center">
      

      
        <ul class="pl0 mr3">
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/android-develop/" title="">
              Android-Develops
            </a>
          </li>
          
          <li class="list f5 f4-ns fw4 dib pr3">
            <a class="hover-white white-90 no-underline" href="/tutorials/" title="">
              Tutorials
            </a>
          </li>
          
        </ul>
      
      <div class="ananke-socials"></div>

    </div>
  </div>
</nav>

      <div class="tc-l pv3 ph3 ph4-ns">
        <h1 class="f2 f-subheadline-l fw2 light-silver mb0 lh-title">
          Android-Develop
        </h1>
        
      </div>
    </div>
  </header>


    <main class="pb7" role="main">
      
  <article class="cf pa3 pa4-m pa4-l">
    <div class="measure-wide-l center f4 lh-copy nested-copy-line-height nested-links mid-gray">
      <p></p>
    </div>
  </article>
  <div class="mw8 center">
    <section class="flex-ns mt5 flex-wrap justify-around">
      
        <div class="w-100 mb4 relative bg-white">
          <div class="w-100 mb4 nested-copy-line-height relative bg-white">
  <div class="mb3 pa4 gray overflow-hidden bg-white">
    <span class="f6 db">Android-Develops</span>
    <h1 class="f3 near-black">
      <a href="/android-develop/%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86/" class="link black dim">
        协程原理
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <p>Kotlin协程的本质是<strong>通过状态机管理挂起点，由编译器进行CPS变换实现的轻量级并发抽象</strong>。其核心原理和状态推进机制如下：</p>
<h4 id="核心原理">核心原理</h4>
<h5 id="1-挂起函数">1. 挂起函数</h5>
<ul>
<li>用suspend修饰的函数</li>
<li>编译器会将其编译为<strong>状态机代码</strong>(而非阻塞线程)，支持在任意位置挂起/恢复</li>
</ul>
<h5 id="2-续体">2. 续体</h5>
<ul>
<li>类似回调的接口<code>Continuation&lt;T&gt;</code>，其关键方法是<code>resumeWith(result)</code></li>
<li>协程的每一步执行都依附于一个续体对象，存储当前执行状态和上下文</li>
</ul>
<h5 id="3-状态机转换">3. 状态机转换</h5>
<ul>
<li>编译器将挂起函数拆解成一个状态机（通过<code>label</code>标记状态）</li>
<li>每个挂起点对应一个状态迁移</li>
</ul>
<hr>
<h4 id="状态推进流程">状态推进流程</h4>
<p>以下代码展示状态机的运作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">suspend</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">fetchData</span>(): String {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">val</span> data1 = fetchPart1()  <span style="color:#75715e">//挂起点1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">val</span> data2 = fetchPart2()  <span style="color:#75715e">//挂起点2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> data1 + data2
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>编译器转换后（伪代码）</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-kotlin" data-lang="kotlin"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FetchDataStateMachine</span>(
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">val</span> completion: Continuation&lt;String&gt;,
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> label: Int = <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>) : Continuation&lt;Unit&gt; {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> data1: String? = <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">var</span> data2: String? = <span style="color:#66d9ef">null</span>
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">fun</span> <span style="color:#a6e22e">resumeWith</span>(result: Result&lt;Any?&gt;) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">when</span>(label) {
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">0</span> <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>        label = <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        fetchPart1(<span style="color:#66d9ef">this</span>)
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">1</span> <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>        data1 = result.getOrThrow() <span style="color:#66d9ef">as</span> String
</span></span><span style="display:flex;"><span>        label = <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>        fetchPart2(<span style="color:#66d9ef">this</span>)
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">2</span> <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>        data2 = result.getOrThrow() <span style="color:#66d9ef">as</span> String
</span></span><span style="display:flex;"><span>        completion.resumeWith(data1 + data2)	<span style="color:#75715e">//返回最终结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h4 id="关键机制">关键机制</h4>
<h5 id="1-挂起不阻塞线程">1. 挂起不阻塞线程：</h5>
<ul>
<li>协程挂起时，底层线程立即释放（例如返回到线程池），避免资源浪费</li>
<li>异步操作完成后，任务被派发到合适的线程继续执行（通过<code>Dispatcher</code>）</li>
</ul>
<h5 id="2续体传递风格">2.续体传递风格</h5>
<ul>
<li>挂起函数被编译为接受额外<code>Continuation</code>参数的函数</li>
<li>例如<code>suspend fun foo()</code> → <code>fun foo(continuation: Continuation)</code></li>
</ul>
<h5 id="3-协程上下文coroutinecontext">3. 协程上下文（CoroutineContext）</h5>
<ul>
<li>通过<code>CoroutineContext</code>传递调度器、异常处理器等。</li>
<li>状态机中通过<code>Continuation.context</code>获取当前上下文</li>
</ul>
<h5 id="4-结构化并发">4. 结构化并发</h5>
<ul>
<li>协程树通过父-子关系管理生命周期</li>
<li>父协程取消时，自动取消所有子协程</li>
</ul>
<hr>
<h4 id="状态推进">状态推进</h4>
<p>在<code>FetchDataStateMachine</code>的<code>resumeWith</code>中并没有循环，label的状态是如何推进的呢？实际上状态推进是通过<strong>递归链式调用与间接跳转</strong>实现的。</p>
    </div>
    <a href="/android-develop/%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1"></a>
  </div>
</div>

        </div>
      
        <div class="w-100 mb4 relative bg-white">
          <div class="w-100 mb4 nested-copy-line-height relative bg-white">
  <div class="mb3 pa4 gray overflow-hidden bg-white">
    <span class="f6 db">Android-Develops</span>
    <h1 class="f3 near-black">
      <a href="/android-develop/gradle%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" class="link black dim">
        gradle相关知识
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h3 id="一插件plugins-vs-库libraries">一、插件(Plugins) vs 库(Libraries)</h3>
<table>
  <thead>
      <tr>
          <th><strong>特征</strong></th>
          <th>插件 (Plugins)</th>
          <th>库 (Libraries)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>本质</strong></td>
          <td>构建逻辑扩展工具</td>
          <td>运行时依赖的代码组件</td>
      </tr>
      <tr>
          <td><strong>作用</strong></td>
          <td>添加任务/配置/目录结构</td>
          <td>提供可调用的具体代码实现</td>
      </tr>
      <tr>
          <td><strong>声明位置</strong></td>
          <td><code>plugins {}</code> 块</td>
          <td><code>dependencies {}</code> 块</td>
      </tr>
      <tr>
          <td><strong>影响范围</strong></td>
          <td>构建过程</td>
          <td>运行时或编译时</td>
      </tr>
      <tr>
          <td><strong>典型示例</strong></td>
          <td><code>java</code>，<code>android</code></td>
          <td><code>gson</code>, <code>junit</code></td>
      </tr>
  </tbody>
</table>
<h4 id="1-插件详解">1. 插件详解</h4>
<p><strong>核心作用</strong>：</p>
<ul>
<li>添加新任务（如 <code>compileJava</code>, <code>assemble</code>）</li>
<li>定义默认目录结构（如 <code>src/main/java</code>）</li>
<li>引入预置配置（如 <code>implementation</code> 依赖配置）</li>
</ul>
<p><strong>使用场景</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-groovy" data-lang="groovy"><span style="display:flex;"><span>plugins <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    id <span style="color:#e6db74">&#39;com.android.application&#39;</span> <span style="color:#75715e">// Android APP插件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    id <span style="color:#e6db74">&#39;org.jetbrains.kotlin.android&#39;</span> <span style="color:#75715e">// Kotlin支持
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span></code></pre></div><h4 id="2-库详解">2. 库详解</h4>
<p><strong>关键特征</strong>：</p>
<ul>
<li>通过坐标声明：<code>group:name:version</code>（如 <code>com.google.guava:guava:32.0-jre</code>）</li>
<li><strong>传递依赖</strong>：库可能自带其他依赖（如 Retrofit 自动引入 OkHttp）</li>
</ul>
<p><strong>使用场景</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-groovy" data-lang="groovy"><span style="display:flex;"><span>dependencies <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    implementation <span style="color:#e6db74">&#39;androidx.core:core-ktx:1.12.0&#39;</span> <span style="color:#75715e">// 主代码依赖
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    testImplementation <span style="color:#e6db74">&#39;junit:junit:4.13.2&#39;</span>        <span style="color:#75715e">// 测试代码专用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</span></span></code></pre></div><hr>
<h3 id="二依赖配置详解">二、依赖配置详解</h3>
<h4 id="1-implementation最常用">1. <code>implementation</code>（最常用）</h4>
<p><strong>特点</strong>:</p>
    </div>
    <a href="/android-develop/gradle%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1"></a>
  </div>
</div>

        </div>
      
        <div class="w-100 mb4 relative bg-white">
          <div class="w-100 mb4 nested-copy-line-height relative bg-white">
  <div class="mb3 pa4 gray overflow-hidden bg-white">
    <span class="f6 db">Android-Develops</span>
    <h1 class="f3 near-black">
      <a href="/android-develop/android%E6%89%93%E5%8C%85apk%E6%B5%81%E7%A8%8B/" class="link black dim">
        Android打包apk流程
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <p>android应用的打包流程是将代码、资源文件、清单文件等编译和压缩成可在设备上安装的APK/AAB文件的过程。以下是详细步骤：</p>
<h4 id="一主要流程">一、主要流程</h4>
<h5 id="1-编写代码与资源管理">1. 编写代码与资源管理</h5>
<ul>
<li>创建<code>/src</code>目录存放Kotlin/Java源码</li>
<li>在<code>/res</code>目录添加资源</li>
<li>配置<code>AndroidManifest.xml</code>(声明组件、权限等)。</li>
</ul>
<h5 id="2-依赖管理">2. 依赖管理</h5>
<ul>
<li>在build.gradle中添加所需依赖库</li>
</ul>
<h5 id="3-编译过程">3. 编译过程</h5>
<ul>
<li>编译代码： kotlin源码 → <code>.class</code>字节码（javac/kotlinc）</li>
<li>转换为Dex：<code>.class</code>文件→ <code>.dex</code>文件（<code>d8</code>/<code>dx</code>工具），用于Android的ART虚拟机</li>
<li>编译资源：<code>AAPT2</code>编译资源文件（<code>res/</code> → 二进制格式），生成<code>R.java</code>和临时资源包(<code>.flat</code>)</li>
</ul>
<h5 id="4打包与签名">4.打包与签名</h5>
<ul>
<li>合并资源： AAPT2链接编译后的资源，生成resources.arsc（资源索引表）和优化后的res/目录</li>
<li>打包成APK：APK Builder将以下文件合并为未签名的APK：
<ul>
<li>编译后的字节码(<code>.dex</code>)</li>
<li>资源文件(<code>res/</code> + <code>resources.arsc</code>)</li>
<li><code>AndroidManifest.xml</code></li>
<li>原生库(<code>.so</code>，若有JNI)</li>
</ul>
</li>
<li>签名APK：使用签名证书(keystore)进行V1/V2/V3签名(通过<code>apksigner</code> 或Gradle配置)</li>
</ul>
<h5 id="5优化与对齐">5.优化与对齐</h5>
<ul>
<li>ZIP对齐：<code>zipalign</code>优化APK文件结构(4字节对齐)，减少运行时内存占用</li>
<li>生成最终的APK：输出<code>app-release.apk</code></li>
</ul>
<h4 id="二名词解释">二、名词解释</h4>
<h5 id="1-临时资源包">1. 临时资源包</h5>
<p>在AAPT2（<code>Android Asset Packaging Tool 2</code>）的资源预编译阶段会生成.flat文件，这些文件是中间产物</p>
<ul>
<li>独立编译：AAPT2将<code>/res</code>目录下的每个资源文件单独编译成二进制格式的<code>.flat</code>文件</li>
<li>支持增量编译：若只修改了单个资源文件，只需重新编译该文件的.flat文件，避免全量编译，加快构建速度</li>
<li>分阶段处理
<ul>
<li>编译阶段：资源→ <code>.flat</code>文件</li>
<li>链接阶段：合并所有<code>.flat</code>文件 → 生成<code>resources.arsc</code>和最终的<code>res/</code>目录</li>
</ul>
</li>
<li>优势
<ul>
<li>提升大型项目的编译速度</li>
<li>支持资源混淆</li>
<li>更严格的资源验证</li>
</ul>
</li>
</ul>
<h5 id="2-对齐">2. 对齐</h5>
<ul>
<li><strong>内存对齐</strong>：解决CPU访问效率问题（<code>数据项首地址 % n == 0</code>），但会增加数据结构大小</li>
<li><strong>文件对齐(zipalign)</strong>:解决内存映射效率的问题（<code>文件偏移 % 4096 == 0</code>），通过消除跨页碎片减少运行时内存占用</li>
<li><strong>内存页机制</strong>
<ul>
<li>系统内存管理以**页(通常4KB)**为单位</li>
<li>对齐后，每次文件读取 = 整数倍内存页 → <strong>减少I/O次数</strong></li>
</ul>
</li>
</ul>
    </div>
    <a href="/android-develop/android%E6%89%93%E5%8C%85apk%E6%B5%81%E7%A8%8B/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1"></a>
  </div>
</div>

        </div>
      
        <div class="w-100 mb4 relative bg-white">
          <div class="w-100 mb4 nested-copy-line-height relative bg-white">
  <div class="mb3 pa4 gray overflow-hidden bg-white">
    <span class="f6 db">Android-Develops</span>
    <h1 class="f3 near-black">
      <a href="/android-develop/choreographer%E7%B1%BB%E8%A7%A3%E6%9E%90/" class="link black dim">
        Choreographer类解析
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h4 id="一核心作用">一、核心作用</h4>
<p>Choreographer是Android系统<strong>协调动画、输入和绘制操作的核心调度器</strong>。它通过VSYNC信号确保帧的渲染与屏幕刷新率同步，避免画面撕裂和卡顿。</p>
<h4 id="二关键概念">二、关键概念</h4>
<ul>
<li>VSYNC：垂直同步信号，表示屏幕开始刷新新的一帧</li>
<li>Frame Callbacks：注册的回调函数，在下一帧的特定阶段执行</li>
<li>Callback Types（按执行顺序排序）
<ul>
<li>CALLBACK_INPUT</li>
<li>CALLBACK_ANIMATION</li>
<li>CALLBACK_INSETS_ANIMATION</li>
<li>CALLBACK_TRAVERSAL</li>
<li>CALLBACK_COMMIT</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Choreographer</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 五种回调类型</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> CALLBACK_INPUT <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> CALLBACK_ANIMATION <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> CALLBACK_INSETS_ANIMATION <span style="color:#f92672">=</span> 2;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> CALLBACK_TRAVERSAL <span style="color:#f92672">=</span> 3;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> CALLBACK_COMMIT <span style="color:#f92672">=</span> 4;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> CALLBACK_LAST <span style="color:#f92672">=</span> CALLBACK_COMMIT; <span style="color:#75715e">// 最后一种类型</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 单例模式实现</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> ThreadLocal<span style="color:#f92672">&lt;</span>Choreographer<span style="color:#f92672">&gt;</span> sThreadInstance <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">new</span> ThreadLocal<span style="color:#f92672">&lt;</span>Choreographer<span style="color:#f92672">&gt;</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">protected</span> Choreographer <span style="color:#a6e22e">initialValue</span>() {
</span></span><span style="display:flex;"><span>                Looper looper <span style="color:#f92672">=</span> Looper.<span style="color:#a6e22e">myLooper</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Choreographer(looper, VSYNC_SOURCE_APP);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 回调队列数组</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> CallbackQueue<span style="color:#f92672">[]</span> mCallbackQueues;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// VSYNC 接收器</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> FrameDisplayEventReceiver mDisplayEventReceiver;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 处理消息的Handler</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> FrameHandler mHandler;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="三核心架构图解">三、核心架构图解</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-tex" data-lang="tex"><span style="display:flex;"><span>┌───────────────────────┐       ┌───────────────────────┐
</span></span><span style="display:flex;"><span>│    VSYNC 信号源        │──────&gt;│ FrameDisplayEventReceiver │
</span></span><span style="display:flex;"><span>└───────────────────────┘       │  (接收硬件VSYNC信号)     │
</span></span><span style="display:flex;"><span>                                └───────────┬───────────┘
</span></span><span style="display:flex;"><span>                                            │
</span></span><span style="display:flex;"><span>                                            ▼
</span></span><span style="display:flex;"><span>┌───────────────────────┐       ┌───────────────────────┐
</span></span><span style="display:flex;"><span>│     FrameHandler       │&lt;──────│    onVsync()          │
</span></span><span style="display:flex;"><span>│   (处理3类消息)        │──────&gt;│    scheduleVsync()    │
</span></span><span style="display:flex;"><span>└───────────┬───────────┘       └───────────────────────┘
</span></span><span style="display:flex;"><span>            │
</span></span><span style="display:flex;"><span>            ▼
</span></span><span style="display:flex;"><span>┌───────────────────────┐
</span></span><span style="display:flex;"><span>│      doFrame()         │
</span></span><span style="display:flex;"><span>│ (帧处理核心方法)       │
</span></span><span style="display:flex;"><span>└───────────┬───────────┘
</span></span><span style="display:flex;"><span>            │
</span></span><span style="display:flex;"><span>            ▼
</span></span><span style="display:flex;"><span>┌───────────────────────┐
</span></span><span style="display:flex;"><span>│   CallbackQueue[]      │
</span></span><span style="display:flex;"><span>│ (5种类型回调链表)      │
</span></span><span style="display:flex;"><span>└───────────────────────┘
</span></span></code></pre></div><h4 id="三回调添加入口">三、回调添加入口</h4>
<h5 id="1-添加回调入口">1. 添加回调入口</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">postCallback</span>(<span style="color:#66d9ef">int</span> callbackType, Runnable action, Object token) {
</span></span><span style="display:flex;"><span>    postCallbackDelayed(callbackType, action, token, 0);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">postCallbackDelayed</span>(<span style="color:#66d9ef">int</span> callbackType, Runnable action, <span style="color:#66d9ef">long</span> delayMillis) {
</span></span><span style="display:flex;"><span>    postCallbackDelayedInternal(callbackType, action, token, delayMillis);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="2-内部添加实现">2. 内部添加实现</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">postCallbackDelayedInternal</span>(<span style="color:#66d9ef">int</span> callbackType,
</span></span><span style="display:flex;"><span>        Object action, Object token, <span style="color:#66d9ef">long</span> delayMillis) {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">synchronized</span> (mLock) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> now <span style="color:#f92672">=</span> SystemClock.<span style="color:#a6e22e">uptimeMillis</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> dueTime <span style="color:#f92672">=</span> now <span style="color:#f92672">+</span> delayMillis;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 1. 添加到对应的回调队列</span>
</span></span><span style="display:flex;"><span>        mCallbackQueues<span style="color:#f92672">[</span>callbackType<span style="color:#f92672">]</span>.<span style="color:#a6e22e">addCallbackLocked</span>(dueTime, action, token);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 2. 调度帧处理</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (dueTime <span style="color:#f92672">&lt;=</span> now) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 立即调度</span>
</span></span><span style="display:flex;"><span>            scheduleFrameLocked(now);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 延迟调度</span>
</span></span><span style="display:flex;"><span>            Message msg <span style="color:#f92672">=</span> mHandler.<span style="color:#a6e22e">obtainMessage</span>(MSG_DO_SCHEDULE_CALLBACK, action);
</span></span><span style="display:flex;"><span>            msg.<span style="color:#a6e22e">arg1</span> <span style="color:#f92672">=</span> callbackType;
</span></span><span style="display:flex;"><span>            msg.<span style="color:#a6e22e">setAsynchronous</span>(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>            mHandler.<span style="color:#a6e22e">sendMessageAtTime</span>(msg, dueTime);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="3-回调链表结构">3. 回调链表结构</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CallbackQueue</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> CallbackRecord mHead;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addCallbackLocked</span>(<span style="color:#66d9ef">long</span> dueTime, Object action, Object token) {
</span></span><span style="display:flex;"><span>        CallbackRecord callback <span style="color:#f92672">=</span> obtainCallbackLocked(dueTime, action, token);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (mHead <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            mHead <span style="color:#f92672">=</span> callback;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 链表按照执行时间排序（小到大）</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (dueTime <span style="color:#f92672">&lt;</span> mHead.<span style="color:#a6e22e">dueTime</span>) {
</span></span><span style="display:flex;"><span>            callback.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> mHead;
</span></span><span style="display:flex;"><span>            mHead <span style="color:#f92672">=</span> callback;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        CallbackRecord entry <span style="color:#f92672">=</span> mHead;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (entry.<span style="color:#a6e22e">next</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (dueTime <span style="color:#f92672">&lt;</span> entry.<span style="color:#a6e22e">next</span>.<span style="color:#a6e22e">dueTime</span>) {
</span></span><span style="display:flex;"><span>                callback.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> entry.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>                entry.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> callback;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            entry <span style="color:#f92672">=</span> entry.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        entry.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> callback;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 链表节点定义</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CallbackRecord</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> CallbackRecord next;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">long</span> dueTime;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Object action; <span style="color:#75715e">// Runnable 或 FrameCallback</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Object token;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="四vsync同步机制">四、VSYNC同步机制</h4>
<h5 id="1-vsync请求">1、 VSYNC请求</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">scheduleFrameLocked</span>(<span style="color:#66d9ef">long</span> now) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>mFrameScheduled) {
</span></span><span style="display:flex;"><span>        mFrameScheduled <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (USE_VSYNC) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 通过 FrameDisplayEventReceiver 请求 VSYNC</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (isRunningOnLooperThreadLocked()) {
</span></span><span style="display:flex;"><span>              <span style="color:#75715e">//注册</span>
</span></span><span style="display:flex;"><span>                scheduleVsyncLocked();
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 非UI线程发送消息到UI线程</span>
</span></span><span style="display:flex;"><span>                Message msg <span style="color:#f92672">=</span> mHandler.<span style="color:#a6e22e">obtainMessage</span>(MSG_DO_SCHEDULE_VSYNC);
</span></span><span style="display:flex;"><span>                msg.<span style="color:#a6e22e">setAsynchronous</span>(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>                mHandler.<span style="color:#a6e22e">sendMessageAtFrontOfQueue</span>(msg);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 无VSYNC直接安排帧</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> nextFrameTime <span style="color:#f92672">=</span> ...;
</span></span><span style="display:flex;"><span>            Message msg <span style="color:#f92672">=</span> mHandler.<span style="color:#a6e22e">obtainMessage</span>(MSG_DO_FRAME);
</span></span><span style="display:flex;"><span>            msg.<span style="color:#a6e22e">setAsynchronous</span>(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>            mHandler.<span style="color:#a6e22e">sendMessageAtTime</span>(msg, nextFrameTime);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">scheduleVsyncLocked</span>() {
</span></span><span style="display:flex;"><span>    mDisplayEventReceiver.<span style="color:#a6e22e">scheduleVsync</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="2-vsync接收与处理">2. VSYNC接收与处理</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FrameDisplayEventReceiver</span> <span style="color:#66d9ef">extends</span> DisplayEventReceiver {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onVsync</span>(<span style="color:#66d9ef">long</span> timestampNanos, <span style="color:#66d9ef">long</span> physicalDisplayId, <span style="color:#66d9ef">int</span> frame) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 1. 计算正确的帧时间</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> now <span style="color:#f92672">=</span> System.<span style="color:#a6e22e">nanoTime</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> intendedFrameTimeNanos <span style="color:#f92672">=</span> ...;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 2. 发送MSG_DO_FRAME消息</span>
</span></span><span style="display:flex;"><span>        Message msg <span style="color:#f92672">=</span> Message.<span style="color:#a6e22e">obtain</span>(mHandler, MSG_DO_FRAME);
</span></span><span style="display:flex;"><span>        msg.<span style="color:#a6e22e">setAsynchronous</span>(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>        mHandler.<span style="color:#a6e22e">sendMessageAtTime</span>(msg, intendedFrameTimeNanos <span style="color:#f92672">/</span> NANOS_PER_MS);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="3-帧处理核心---doframe">3. 帧处理核心 - doFrame()</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doFrame</span>(<span style="color:#66d9ef">long</span> frameTimeNanos, <span style="color:#66d9ef">int</span> frame) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> startNanos;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">synchronized</span> (mLock) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 检查帧调度状态</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>mFrameScheduled) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 计算跳帧情况</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> jitterNanos <span style="color:#f92672">=</span> startNanos <span style="color:#f92672">-</span> frameTimeNanos;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (jitterNanos <span style="color:#f92672">&gt;=</span> mFrameIntervalNanos) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> skippedFrames <span style="color:#f92672">=</span> jitterNanos <span style="color:#f92672">/</span> mFrameIntervalNanos;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 超过阈值打印警告日志</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (skippedFrames <span style="color:#f92672">&gt;=</span> SKIPPED_FRAME_WARNING_LIMIT) {
</span></span><span style="display:flex;"><span>                Log.<span style="color:#a6e22e">i</span>(TAG, <span style="color:#e6db74">&#34;Skipped &#34;</span> <span style="color:#f92672">+</span> skippedFrames <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; frames!&#34;</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            frameTimeNanos <span style="color:#f92672">=</span> ...; <span style="color:#75715e">// 调整帧时间</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        mLastFrameTimeNanos <span style="color:#f92672">=</span> frameTimeNanos;
</span></span><span style="display:flex;"><span>        mFrameScheduled <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 按优先级顺序执行回调</span>
</span></span><span style="display:flex;"><span>        mFrameInfo.<span style="color:#a6e22e">markInputHandlingStart</span>();
</span></span><span style="display:flex;"><span>        doCallbacks(Choreographer.<span style="color:#a6e22e">CALLBACK_INPUT</span>, frameTimeNanos);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        mFrameInfo.<span style="color:#a6e22e">markAnimationsStart</span>();
</span></span><span style="display:flex;"><span>        doCallbacks(Choreographer.<span style="color:#a6e22e">CALLBACK_ANIMATION</span>, frameTimeNanos);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        mFrameInfo.<span style="color:#a6e22e">markPerformTraversalsStart</span>();
</span></span><span style="display:flex;"><span>        doCallbacks(Choreographer.<span style="color:#a6e22e">CALLBACK_TRAVERSAL</span>, frameTimeNanos);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        doCallbacks(Choreographer.<span style="color:#a6e22e">CALLBACK_COMMIT</span>, frameTimeNanos);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 清理工作</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="五回调执行处理">五、回调执行处理</h4>
<h5 id="1-执行回调核心逻辑">1. 执行回调核心逻辑</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doCallbacks</span>(<span style="color:#66d9ef">int</span> callbackType, <span style="color:#66d9ef">long</span> frameTimeNanos) {
</span></span><span style="display:flex;"><span>    CallbackRecord callbacks;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">synchronized</span> (mLock) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 提取所有到期的回调</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> now <span style="color:#f92672">=</span> frameTimeNanos <span style="color:#f92672">/</span> NANOS_PER_MS;
</span></span><span style="display:flex;"><span>        callbacks <span style="color:#f92672">=</span> mCallbackQueues<span style="color:#f92672">[</span>callbackType<span style="color:#f92672">]</span>.<span style="color:#a6e22e">extractDueCallbacksLocked</span>(now);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (callbacks <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        mCallbacksRunning <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 执行链表中的所有回调</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (CallbackRecord c <span style="color:#f92672">=</span> callbacks; c <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>; c <span style="color:#f92672">=</span> c.<span style="color:#a6e22e">next</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 执行回调</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (c.<span style="color:#a6e22e">action</span> <span style="color:#66d9ef">instanceof</span> Runnable) {
</span></span><span style="display:flex;"><span>                ((Runnable) c.<span style="color:#a6e22e">action</span>).<span style="color:#a6e22e">run</span>();
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                ((FrameCallback) c.<span style="color:#a6e22e">action</span>).<span style="color:#a6e22e">doFrame</span>(frameTimeNanos);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">synchronized</span> (mLock) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 回收CallbackRecord对象</span>
</span></span><span style="display:flex;"><span>            recycleCallbackRecordsLocked(callbacks);
</span></span><span style="display:flex;"><span>            mCallbacksRunning <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="2到期回调提取算法">2.到期回调提取算法</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>CallbackRecord <span style="color:#a6e22e">extractDueCallbacksLocked</span>(<span style="color:#66d9ef">long</span> now) {
</span></span><span style="display:flex;"><span>    CallbackRecord callbacks <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>    CallbackRecord next <span style="color:#f92672">=</span> mHead;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 遍历链表，找出所有dueTime&lt;=now的节点</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (next <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> next.<span style="color:#a6e22e">dueTime</span> <span style="color:#f92672">&lt;=</span> now) {
</span></span><span style="display:flex;"><span>        CallbackRecord temp <span style="color:#f92672">=</span> next;
</span></span><span style="display:flex;"><span>        next <span style="color:#f92672">=</span> next.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>        temp.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> callbacks;  <span style="color:#75715e">// 新节点插入链表头部</span>
</span></span><span style="display:flex;"><span>        callbacks <span style="color:#f92672">=</span> temp;       <span style="color:#75715e">// 新链表头</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 更新原链表</span>
</span></span><span style="display:flex;"><span>    mHead <span style="color:#f92672">=</span> next;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 返回的是倒序链表（最近加入的先执行）</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> callbacks;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="六choreographer的其他作用">六、Choreographer的其他作用</h4>
<h5 id="1-帧率监控">1. 帧率监控</h5>
<p>开发者可以通过postFrameCallback实现帧率监控：</p>
    </div>
    <a href="/android-develop/choreographer%E7%B1%BB%E8%A7%A3%E6%9E%90/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1"></a>
  </div>
</div>

        </div>
      
        <div class="w-100 mb4 relative bg-white">
          <div class="w-100 mb4 nested-copy-line-height relative bg-white">
  <div class="mb3 pa4 gray overflow-hidden bg-white">
    <span class="f6 db">Android-Develops</span>
    <h1 class="f3 near-black">
      <a href="/android-develop/%E5%8C%85%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96/" class="link black dim">
        包体积优化
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h4 id="包体积优化">包体积优化</h4>
<h4 id="一apk结构分析工具">一、APK结构分析工具</h4>
<ol>
<li>Android Studio内置工具
<ul>
<li>使用 Build &gt; Analyze APK</li>
<li>查看各模块占比(代码/资源/原生库/Assets)</li>
</ul>
</li>
<li>命令行工具</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>./gradlew :app:assembleRelease --scan
</span></span></code></pre></div><h4 id="二代码优化">二、代码优化</h4>
<ol>
<li>启用代码混淆与优化</li>
<li>移除未使用代码
<ul>
<li>使用android studio的lint分析未使用代码</li>
<li>添加R8配置文件删除无引用代码</li>
</ul>
</li>
<li>方法数优化
<ul>
<li>启用Multidex前优化</li>
<li>使用D8编译器的dex优化</li>
</ul>
</li>
</ol>
<h4 id="三资源优化">三、资源优化</h4>
<ol>
<li>资源压缩与清理</li>
<li>移除未使用资源</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 检测未使用资源</span>
</span></span><span style="display:flex;"><span>./gradlew lintRelease
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 自动移除</span>
</span></span><span style="display:flex;"><span>./gradlew removeUnusedResources
</span></span></code></pre></div><ol start="3">
<li>矢量图代替位图</li>
<li>Webp格式转换</li>
</ol>
<h4 id="四库优化">四、库优化</h4>
<ol>
<li>仅保留必要ABI</li>
<li>轻量库代替</li>
</ol>
<h4 id="五高级优化技术">五、高级优化技术</h4>
<ol>
<li>资源混淆</li>
<li>资源分包加载</li>
<li>按需加载功能模块</li>
</ol>
<h4 id="六--assets优化">六 、 Assets优化</h4>
<ol>
<li>压缩assets资源：存储时压缩，使用时解压</li>
</ol>
<h4 id="七知识补充">七、知识补充</h4>
<ol>
<li>D8、R8和代码混淆的关系
<ul>
<li>D8负责字节码到Dex的精确转换</li>
<li>R8 = D8 + 裁剪 + 优化 + 混淆</li>
<li>混淆是R8的战术武器：仅负责名称混淆（对体积影响小，对安全性关键）</li>
<li><strong>开启R8 ≈ D8编译 + 三重优化(裁剪/优化/混淆)</strong></li>
</ul>
</li>
</ol>
    </div>
    <a href="/android-develop/%E5%8C%85%E4%BD%93%E7%A7%AF%E4%BC%98%E5%8C%96/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1"></a>
  </div>
</div>

        </div>
      
        <div class="w-100 mb4 relative bg-white">
          <div class="w-100 mb4 nested-copy-line-height relative bg-white">
  <div class="mb3 pa4 gray overflow-hidden bg-white">
    <span class="f6 db">Android-Develops</span>
    <h1 class="f3 near-black">
      <a href="/android-develop/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" class="link black dim">
        内存管理最佳实践
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h4 id="一内存管理原则">一、内存管理原则</h4>
<ol>
<li>理解Android内存模型
<ul>
<li>基于JVM垃圾回收机制，采用分代回收策略</li>
<li>内存不足是触发<code>onTrimMemory()</code>，开发者需响应此回调释放资源</li>
</ul>
</li>
<li>避免内存泄漏根源
<ul>
<li>静态引用：禁止用static持有Activity/Context（用Application Context代替）</li>
<li>非静态内部类：改用静态内部类+弱引用</li>
<li>资源未释放：关闭Cursor、File、Bitmap等资源。gc只释放java对象本身，在jvm堆中，系统资源需要显示释放</li>
<li>集合对象：及时清理无用的集合元素</li>
</ul>
</li>
<li>优化关键组件
<ul>
<li>Activity/Fragment
<ul>
<li>在onDestroy中解除BroadcastReceiver、Handler注册，移除回调</li>
<li>避免在异步任务中直接引用View</li>
</ul>
</li>
<li>Handler
<ul>
<li>使用静态内部类 + WeakReference。</li>
</ul>
</li>
<li>单例模式
<ul>
<li>传递Application Context，而非Activity Context</li>
</ul>
</li>
</ul>
</li>
<li>大对象优化
<ul>
<li>Bitmap
<ul>
<li>使用inSampleSize压缩图片，采用Glide等库管理内存</li>
</ul>
</li>
<li>数据缓存
<ul>
<li>优先使用LruCache和DiskLruCache</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="二内存泄漏排查工具">二、内存泄漏排查工具</h4>
<ol>
<li>Android Profiler</li>
<li>LeakCanary</li>
<li>MAT</li>
<li>StrictMode</li>
</ol>
<h3 id="二内存泄漏排查工具-1"><strong>二、内存泄漏排查工具</strong></h3>
<ol>
<li>
<p><strong>Android Profiler（Android Studio）</strong></p>
<ul>
<li><strong>内存监控</strong>：实时查看堆内存使用情况。</li>
<li><strong>Heap Dump</strong>：捕获堆快照，分析对象引用链。</li>
<li><strong>Allocation Tracker</strong>：跟踪短时间内的内存分配。</li>
</ul>
</li>
<li>
<p><strong>LeakCanary（自动化检测）</strong></p>
<ul>
<li>
<p>集成步骤：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-groovy" data-lang="groovy"><span style="display:flex;"><span>debugImplementation <span style="color:#e6db74">&#39;com.squareup.leakcanary:leakcanary-android:2.9.1&#39;</span>
</span></span></code></pre></div></li>
<li>
<p>自动检测泄漏并生成报告，定位泄漏引用链。</p>
</li>
</ul>
</li>
<li>
<p><strong>MAT（Memory Analyzer Tool）</strong></p>
<ul>
<li>
<p>分析Heap Dump步骤：</p>
<ul>
<li>
<p>用Android Profiler导出<code>.hprof</code>文件。</p>
</li>
<li>
<p>通过<code>hprof-conv</code>转换格式（Android SDK工具）：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>hprof-conv input.hprof output.hprof
</span></span></code></pre></div></li>
<li>
<p>在MAT中打开，通过<strong>Dominator Tree</strong>和<strong>Path to GC Roots</strong>分析泄漏对象。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>StrictMode</strong></p>
<ul>
<li>
<p>检测主线程磁盘/网络操作，间接避免内存问题：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>StrictMode.<span style="color:#a6e22e">setVmPolicy</span>(<span style="color:#66d9ef">new</span> VmPolicy.<span style="color:#a6e22e">Builder</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">detectActivityLeaks</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">detectLeakedClosableObjects</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">penaltyLog</span>()
</span></span><span style="display:flex;"><span>    .<span style="color:#a6e22e">build</span>());
</span></span></code></pre></div></li>
</ul>
</li>
</ol>
    </div>
    <a href="/android-develop/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1"></a>
  </div>
</div>

        </div>
      
        <div class="w-100 mb4 relative bg-white">
          <div class="w-100 mb4 nested-copy-line-height relative bg-white">
  <div class="mb3 pa4 gray overflow-hidden bg-white">
    <span class="f6 db">Android-Develops</span>
    <h1 class="f3 near-black">
      <a href="/android-develop/view%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="link black dim">
        View性能优化
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h3 id="android-view-性能优化体系">Android View 性能优化体系</h3>
<hr>
<h3 id="一规避过度绘制gpu优化">一、规避过度绘制（GPU优化）</h3>
<p>专注于减少GPU的无效像素填充负载</p>
<ul>
<li><strong>概念解析：</strong><br>
GPU在单个像素点重复绘制超过2.5次（1x绘制+1.5x半透明混合）的现象，消耗填充率导致帧率下降</li>
<li><strong>检测工具：</strong><br>
<code>开发者选项-&gt;调试GPU过度绘制</code>（蓝色&lt;1x, 绿色&lt;2x, 粉色&lt;3x, 红色≥4x）</li>
<li><strong>核心策略：</strong>
<ul>
<li><strong>移除无效背景层：</strong>
<ul>
<li>检查并移除Activity根布局或主题中冗余的<code>windowBackground</code></li>
<li>删除被完全覆盖的中间层布局（如FrameLayout）背景</li>
<li>避免在自定义View的<code>onDraw()</code>中绘制被覆盖区域</li>
</ul>
</li>
<li><strong>层级扁平化：</strong>
<ul>
<li>使用<code>ConstraintLayout</code>替代多层嵌套布局</li>
<li>减少RelativeLayout导致的二次测量</li>
</ul>
</li>
<li><strong>透明效果控制：</strong>
<ul>
<li>避免大面积半透明视图（引发GPU混合计算）</li>
<li>硬件层动画结束时立即禁用（<code>setLayerType(LAYER_TYPE_NONE)</code>）</li>
</ul>
</li>
<li><strong>引用关键通用技术：</strong><br>
结合<code>clipRect/quickReject</code>限定绘制区域（详见通用技术章节）</li>
</ul>
</li>
</ul>
<hr>
<h3 id="二绘制指令优化cpu优化">二、绘制指令优化（CPU优化）</h3>
<p>降低CPU生成绘制指令的开销</p>
<ul>
<li><strong>优化焦点：</strong><br>
<code>onDraw()</code>方法的执行效率与资源管理</li>
<li><strong>核心准则：</strong>
<ul>
<li><strong>禁止内存分配：</strong><br>
绝不在<code>onDraw()</code>中创建Paint/Path/Bitmap对象（应在构造方法初始化）</li>
<li><strong>规避耗时操作：</strong><br>
避免复杂计算、IO或解析逻辑</li>
<li><strong>阻断递归触发：</strong><br>
禁止在<code>onDraw()</code>中调用<code>invalidate()</code>或<code>requestLayout()</code></li>
</ul>
</li>
<li><strong>高级技巧：</strong>
<ul>
<li><strong>绘图资源复用：</strong><br>
对矢量图(VectorDrawable)和位图采用不同优化策略
<ul>
<li>小图标优先使用矢量图</li>
<li>位图加载启用<code>inSampleSize</code>采样和<code>RGB_565</code>解码</li>
<li>使用<code>ImageView.setImageDrawable()</code>替代<code>canvas.drawBitmap()</code></li>
</ul>
</li>
<li><strong>透明效果实现：</strong><br>
优先使用<code>View.setAlpha()</code>而非半透明背景色</li>
<li><strong>引用关键通用技术：</strong><br>
精准控制硬件加速生命周期（详见通用技术章节）</li>
</ul>
</li>
</ul>
<hr>
<h3 id="三通用核心技术">三、通用核心技术</h3>
<p>跨优化领域的共性技术方案</p>
<ul>
<li>
<p><strong>区域裁剪技术：</strong></p>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph TB
  A[canvas.clipRect] --&gt; B[限定子View绘制区域]
  C[canvas.quickReject] --&gt; D[跳过屏幕外区域绘制]
  A--&gt;|ViewGroup| E[重写dispatchDraw控制]
  C--&gt;|自定义View| F[onDraw中预判可见性]
</code></pre><ul>
<li>在<code>ViewGroup.drawChild</code>中限定子View绘制边界</li>
<li>列表项等非重叠视图必备优化手段</li>
</ul>
</li>
<li>
<p><strong>硬件加速深度指南：</strong></p>
<ul>
<li>
<p><strong>运作机制：</strong></p>
<ul>
<li>将View缓存为GPU纹理(Texture)</li>
<li>通过<code>setLayerType(LAYER_TYPE_HARDWARE, null)</code>启用</li>
</ul>
</li>
<li>
<p><strong>最佳实践：</strong></p>
    </div>
    <a href="/android-develop/view%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1"></a>
  </div>
</div>

        </div>
      
        <div class="w-100 mb4 relative bg-white">
          <div class="w-100 mb4 nested-copy-line-height relative bg-white">
  <div class="mb3 pa4 gray overflow-hidden bg-white">
    <span class="f6 db">Android-Develops</span>
    <h1 class="f3 near-black">
      <a href="/android-develop/%E5%85%B3%E4%BA%8E%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/" class="link black dim">
        关于硬件加速
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h4 id="一硬件加速核心概念">一、硬件加速核心概念</h4>
<p>硬件加速是将图形渲染中的光栅化从CPU转移到GPU执行的技术。CPU只需要生成<strong>绘制指令集(DisplayList)</strong>，由GPU进行高效的并行光栅化计算，最终写入图形缓冲区提供屏幕显示。</p>
<p>本质：CPU负责逻辑指令，GPU负责繁重像素计算，分工协作提升效率</p>
<p>光栅化：可以高度抽象的概括为<strong>计算屏幕上每个像素点最终显示的ARGB值</strong></p>
<h4 id="二硬件加速启用前后的核心流程对比">二、硬件加速启用前后的核心流程对比</h4>
<ol>
<li><strong>未启用硬件加速</strong>
<ul>
<li><strong>measure &amp; layout</strong>：由CPU在主线程（UI线程）执行</li>
<li><strong>Draw</strong>（关键区别）：
<ul>
<li>CPU：遍历View树，在主线程直接执行每个View的onDraw(Canvas)方法</li>
<li>光栅化：onDraw中的绘制指令也由CPU执行，直接计算出最终的像素值。</li>
<li>缓冲区(Frame Buffer)
<ul>
<li>系统维护一个帧缓冲区。</li>
<li>CPU光栅化好的像素数据直接写入这个帧缓冲区</li>
<li>核心：CPU既处理逻辑计算又处理生成最终像素的繁重计算(光栅化)，然后把结果放进帧缓冲</li>
</ul>
</li>
</ul>
</li>
<li><strong>合成 &amp; 显示</strong>：屏幕读取帧缓冲区的内容显示到屏幕上。这个过程通常涉及双缓冲和Vsync信号来避免撕裂，但其绘制核心是CPU
<ul>
<li>Front Buffer是屏幕当前帧显示的内容，Back Buffer是屏幕下一帧要显示的内容</li>
</ul>
</li>
</ul>
</li>
<li><strong>开启硬件加速</strong>
<ul>
<li><strong>Measure &amp; Layout</strong>：仍然由CPU在主线程执行。</li>
<li><strong>Draw</strong>(关键区别)：
<ul>
<li>CPU：遍历View树，在主线程执行每个View的**<code>onDraw(Canvas)</code>**方法。但是这里的<code>Canvas</code>行为不同了</li>
<li>Display List：onDraw(Canvas)中的绘制指令不再立即光栅化，而是被记录到DisplayList的数据结构中。DisplayList本质是一系列GPU能理解的绘图操作指令的序列化表示</li>
<li>光栅化：由GPU执行，CPU将构建好的<code>DisplayList</code>提交给GPU。GPU驱动程序将这些高级绘图指令<strong>并行地、高效地光栅化</strong>。</li>
</ul>
</li>
<li><strong>缓冲区</strong>(Frame Buffer / GRALLOC Buffers):
<ul>
<li><strong>普通开启硬件加速时的缓冲区：</strong> GPU 将光栅化<strong>好的像素数据写入系统分配的图形缓冲区</strong> (通常是通过 <code>Gralloc</code> 分配管理的 Buffer Queue 中的缓冲区，如 <code>SurfaceTexture</code>)。这些缓冲区<strong>就是屏幕最终合成时使用的像素数据源</strong></li>
<li>核心：CPU负责记录绘制命令(onDraw -&gt; DisplayList)；GPU负责光栅化，结果写入图形缓冲区</li>
<li>Frame Buffer是抽象的缓冲区，而GRALLOC Buffers是物理缓冲区</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="三启用硬件层">三、启用硬件层</h4>
<ol>
<li><strong>目的</strong>：对像素不会频繁变化的View采用空间换时间的方案，避免View内容未变时重复光栅化，用于后续快速合成</li>
<li><strong>作用</strong>：仅当视图内容改变(<code>invalidate()</code>)时或主动更新时：GPU重新光栅化该View的DisplayList -&gt; 更新离屏纹理。而只涉及纹理的变换时，不会重新光栅化DisplayList，而是直接使用纹理缓存进行合成，纹理变换正是GPU擅长的。纹理变换和opengl管线工作流程中的顶点变换是不同的层级概念</li>
<li><strong>最佳实践</strong>
<ol>
<li>适合<strong>小面积静态视图</strong>或<strong>属性动画</strong></li>
<li>避免对大视图（如列表视图）启用，易耗尽显存</li>
</ol>
</li>
</ol>
    </div>
    <a href="/android-develop/%E5%85%B3%E4%BA%8E%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1"></a>
  </div>
</div>

        </div>
      
        <div class="w-100 mb4 relative bg-white">
          <div class="w-100 mb4 nested-copy-line-height relative bg-white">
  <div class="mb3 pa4 gray overflow-hidden bg-white">
    <span class="f6 db">Android-Develops</span>
    <h1 class="f3 near-black">
      <a href="/android-develop/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/" class="link black dim">
        面试问题收集
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <h4 id="一bitmap内存优化">一、Bitmap内存优化</h4>
<p>Bitmap是内存消耗大户，通过以下方法减少占用：</p>
<ol>
<li><strong>降低色彩解析模式</strong><br>
使用RGB565等低色彩模式，将单个像素的字节大小从32位（ARGB8888）减少到16位，显著节省内存。</li>
<li><strong>合理放置资源文件</strong><br>
高分辨率图片应放置在高密度目录（如<code>drawable-xxhdpi</code>），避免系统自动缩放导致内存浪费。</li>
<li><strong>缩小图片尺寸</strong><br>
加载时通过<code>BitmapFactory.Options</code>动态调整采样率（<code>inSampleSize</code>），或使用<code>createScaledBitmap()</code>减少宽高尺寸。</li>
</ol>
<hr>
<h4 id="二viewmodel与livedata机制">二、ViewModel与LiveData机制</h4>
<p>ViewModel和LiveData是Jetpack组件，用于数据生命周期管理和响应式UI更新。</p>
<ol>
<li>
<p><strong>粘性事件（Sticky Event）</strong></p>
<ul>
<li>
<p><strong>定义</strong>：当新观察者订阅<code>LiveData</code>时，若已有存储值，会立即收到最后一次更新（旧数据）。</p>
</li>
<li>
<p><strong>示例</strong>：屏幕旋转后，新Activity观察LiveData时触发UI更新（旧数据）。</p>
</li>
<li>
<p><strong>来源</strong>：基于LiveData的版本号对比机制。代码关键部分如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LiveData</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> mVersion <span style="color:#f92672">=</span> START_VERSION; <span style="color:#75715e">// LiveData当前版本（初始-1）</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LifecycleBoundObserver</span> <span style="color:#66d9ef">implements</span> ObserverWrapper {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> mLastVersion <span style="color:#f92672">=</span> START_VERSION;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">considerNotify</span>(ObserverWrapper observer) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (observer.<span style="color:#a6e22e">mLastVersion</span> <span style="color:#f92672">&lt;</span> mVersion) { <span style="color:#75715e">// 核心判断：版本号落后才分发</span>
</span></span><span style="display:flex;"><span>      observer.<span style="color:#a6e22e">mLastVersion</span> <span style="color:#f92672">=</span> mVersion;
</span></span><span style="display:flex;"><span>      observer.<span style="color:#a6e22e">mObserver</span>.<span style="color:#a6e22e">onChanged</span>((T)data);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p><strong>简单解法</strong>：使用<code>Event</code>包装数据。事件消费后置空值，避免旧数据触发更新。</p>
</li>
</ul>
</li>
<li>
<p><strong>ViewModel临时数据保存机制</strong></p>
<ul>
<li><strong>内存中保存</strong><br>
ViewModel对象存储在<code>ViewModelStore</code>中。当配置变更（如屏幕旋转）时：
<ul>
<li>Activity/Fragment被销毁重建。</li>
<li><code>ViewModelStore</code>被系统保留（绑定到<code>NonConfigurationInstances</code>）。</li>
<li>新建Activity/Fragment时自动恢复ViewModel实例。</li>
</ul>
</li>
<li><strong>数据范围与最佳实践</strong>
<ul>
<li><strong>保留场景</strong>：屏幕旋转、分屏切换、系统语言更改。</li>
<li><strong>不保留场景</strong>：用户退出应用、系统资源不足杀死进程、Activity被finish()。</li>
<li><strong>最佳实践</strong>：
<ol>
<li>ViewModel解决配置变更的<strong>临时数据保存</strong>（内存级）。</li>
<li><code>SavedStateHandle</code>解决进程被杀死时的<strong>关键数据持久化</strong>。</li>
<li>复杂数据应使用数据库等持久化方案。</li>
<li>避免内存泄漏：勿在ViewModel持有Context/View引用，必要时用<code>Application Context</code>代替。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="三view基础原理">三、View基础原理</h4>
<p>深入理解View的测量、布局、绘制机制，是优化UI性能的核心。</p>
<ol>
<li><strong>MeasureSpec计算与布局优化</strong>
<ul>
<li><strong>MeasureSpec原理</strong>：父容器传递给子View的测量要求，由大小和模式组成，取决于父容器的MeasureSpec和子View的LayoutParams。
<ul>
<li>父布局根据自身MeasureSpec和子View LayoutParams，确定子View的MeasureSpec，再调用<code>children.measure()</code>，最终确定自身尺寸。</li>
</ul>
</li>
<li><strong>布局性能优化</strong>：
<ul>
<li>缓存MeasureSpec计算结果：固定尺寸View（如按钮）直接调用<code>setMeasuredDimension()</code>设置宽高。</li>
<li>优化布局流程：减少嵌套层级、懒加载布局、合并重复布局。</li>
<li>避免无效重绘：使用局部刷新机制。</li>
<li>精确控制绘制范围：通过<code>Canvas.clipRect()</code>限制绘制区域。</li>
</ul>
</li>
</ul>
</li>
<li><strong>getMeasuredWidth()与getWidth()区别</strong>
<ul>
<li><strong>getMeasuredWidth()</strong>：测量阶段后分配的宽度（含内边距）。
<ul>
<li>使用时机：<code>onMeasure()</code>后或<code>layout()</code>前。</li>
<li>特点：反映视图的期望宽度；若布局未强制改变尺寸，可能与<code>getWidth</code>相同。</li>
</ul>
</li>
<li><strong>getWidth()</strong>：布局阶段后的最终可见宽度（屏幕实际值）。
<ul>
<li>使用时机：<code>onLayout</code>后。</li>
<li>计算方式：<code>width = right - left</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>requestLayout()与invalidate()区别</strong>
<ul>
<li><strong>requestLayout()</strong>：请求整个视图树的测量（measure）和布局（layout）流程。
<ul>
<li>触发场景：视图尺寸/位置变化、动态添加/移除子视图、<code>setVisibility()</code>导致布局结构变化。</li>
<li>执行流程：从当前视图向上回溯到根视图（如ViewRootImpl），依次执行measure → layout。</li>
</ul>
</li>
<li><strong>invalidate()</strong>：仅标记视图的局部区域为“脏区”，请求下一帧重绘该区域。
<ul>
<li>触发场景：视图内容变化但不影响尺寸/位置（如<code>onDraw()</code>依赖数据更新）。</li>
<li>执行流程：标记脏区 → 加入重绘队列 → 下一帧VSync信号时调用<code>onDraw()</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>View坐标体系</strong>
<ul>
<li><strong>getX()/getY()</strong>：相对当前View左上角的局部坐标（触摸点在View内的位置）。
<ul>
<li>特点：与父容器无关；值可为负（如滑动超出View边界）。</li>
</ul>
</li>
<li><strong>getRawX()/getRawY()</strong>：相对屏幕左上角的全局坐标。
<ul>
<li>特点：包含状态栏高度（<code>getRawY()</code>从屏幕顶部算起）。</li>
</ul>
</li>
<li><strong>getLocationOnScreen()</strong>：获取View左上角在屏幕上的绝对坐标。</li>
</ul>
</li>
<li><strong>View生命周期关键方法</strong>
<ul>
<li><strong>构造函数</strong>：通过代码或XML创建View实例。</li>
<li><strong>onAttachedToWindow()</strong>：View被添加到窗口时调用。
<ul>
<li>用途：初始化资源、注册监听器、启动动画。</li>
</ul>
</li>
<li><strong>onDetachedFromWindow()</strong>：View从窗口移除时调用（如Activity销毁）。
<ul>
<li>关键作用：释放资源、停止动画、注销监听器。</li>
</ul>
</li>
<li><strong>注意事项</strong>：
<ul>
<li><code>onVisibilityChanged()</code>可能在<code>onAttachedToWindow()</code>前/后调用（如View初始化为<code>GONE</code>）。</li>
<li><code>onWindowFocusChanged()</code>可能在<code>onDetachedFromWindow()</code>后调用（避免在此访问资源）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>View性能优化</strong>
<ol>
<li><strong>过度绘制：</strong>
<ul>
<li>概念：GPU在一个像素点上绘制了多次的现象。系统默认允许2.5次（1x绘制 + 1.5x半透明混合）</li>
<li>主要优化策略
<ul>
<li>移除不必要的背景</li>
<li>减少View的层级深度</li>
<li>谨慎使用半透明或**<code>setLayerType(LAYER_TYPE_HARDWARE)</code>**</li>
<li>优化<code>clipRect</code>和<code>quickReject</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>布局优化：</strong>
<ul>
<li>概念：指测量和布局阶段的性能优化。CPU需要遍历View树计算每个View的大小和位置</li>
<li>优化策略：
<ul>
<li>减少嵌套层级</li>
<li>使用高效布局标签（merge、include、ViewStub）</li>
<li>优化<code>onMeasure</code>/<code>onLayout</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>绘制优化：</strong>
<ul>
<li>概念：指实际调用View.onDraw方法渲染像素到屏幕的性能优化。CPU准备绘制指令 -&gt;GPU执行绘制</li>
<li>优化策略
<ul>
<li>优化onDraw()方法：避免内存分配(不在onDraw方法内实例化Paint、Path、Bitmap、Rect对象)，避免耗时操作、避免调用invalidate（避免递归/绘制请求），利用canvas.clipRect和canvas.quickReject(),优先使用矢量图代替位图，使用硬件加速支持的Canvas操作</li>
<li>谨慎开启Hardware_Layer</li>
<li>优化alpha通道和透明度</li>
<li>优化Bitmap加载与显示</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><strong>高级机制与原理</strong>
<ol>
<li>硬件加速：将绘制指令交给GPU，但是部分api不支持</li>
<li>SurfaceView与TextureView：todo</li>
<li>view.post与Handler：todo</li>
</ol>
</li>
</ol>
<hr>
<h4 id="四事件分发机制">四、事件分发机制</h4>
<ol>
<li><strong>滑动实现方式</strong>
<ul>
<li><strong><code>scrollTo()</code>/<code>scrollBy()</code></strong>: scrollTo()是直接跳转到指定位置，scrollBy是相对移动，基于当前位置滑动指定偏移量</li>
<li>通过<code>ViewDragHelper</code>实现复杂拖拽: todo</li>
</ul>
</li>
<li><strong>自定义下拉刷新控件</strong>
<ul>
<li>todo</li>
</ul>
</li>
<li><strong>事件分发机制如何提升效率</strong>
<ul>
<li>todo</li>
</ul>
</li>
<li><strong>嵌套滑动处理</strong>
<ul>
<li>todo</li>
</ul>
</li>
<li><strong>RecyclerView的滑动冲突处理</strong>
<ul>
<li>todo</li>
</ul>
</li>
</ol>
<hr>
<h4 id="五handler">五、Handler</h4>
<ol>
<li></li>
</ol>
<hr>
<h4 id="六性能优化-todo">六、性能优化 （todo）</h4>
<ol>
<li><strong>内存管理与泄漏排查</strong></li>
<li><strong>UI渲染性能(卡顿优化)</strong></li>
<li><strong>启动速度优化</strong></li>
<li><strong>功耗优化基础</strong></li>
<li><strong>包体积优化</strong></li>
</ol>
<hr>
<h4 id="七常用库与框架todo">七、常用库与框架（todo）</h4>
<ol>
<li><strong>网络请求(如Retrofit)</strong></li>
<li><strong>图片加载(如Glide / Picasso)</strong></li>
<li><strong>Gradle基础</strong></li>
</ol>
<hr>
<h4 id="八网络与后台">八、网络与后台</h4>
<ol>
<li><strong>RESTful API概念与使用</strong></li>
<li><strong>异步处理深入（线程安全、后台限制）</strong></li>
<li><strong>缓存策略</strong></li>
</ol>
<hr>
<h4 id="九架构设计">九、架构设计</h4>
<ol>
<li>MVVM/MVI理解与实践</li>
<li>模块化 / 组件化</li>
<li>设计模式应用</li>
</ol>
<hr>
<h4 id="十新技术与趋势">十、新技术与趋势</h4>
<ol>
<li>Compose</li>
<li>KMM / Flutter</li>
</ol>
<hr>
<h4 id="十一jvm--内存模型基础">十一、JVM / 内存模型基础</h4>
<ol>
<li>JVM内存结构</li>
<li>垃圾回收机制基础</li>
<li>常见数据结构与基础算法</li>
</ol>
    </div>
    <a href="/android-develop/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1"></a>
  </div>
</div>

        </div>
      
        <div class="w-100 mb4 relative bg-white">
          <div class="w-100 mb4 nested-copy-line-height relative bg-white">
  <div class="mb3 pa4 gray overflow-hidden bg-white">
    <span class="f6 db">Android-Develops</span>
    <h1 class="f3 near-black">
      <a href="/android-develop/recyclerview%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" class="link black dim">
        RecyclerView缓存机制
      </a>
    </h1>
    <div class="nested-links f5 lh-copy nested-copy-line-height">
      <p>RecyclerView缓存机制</p>
<h4 id="多级缓存体系架构图"><strong>多级缓存体系架构图</strong></h4>
<pre tabindex="0"><code>TEXT

RecyclerView 缓存系统
├── 1. 屏幕内缓存 (Attached Scrap)
│   └── 存放当前可见的ViewHolder（快速复用）
├── 2. 屏幕外缓存 (Cache)
│   └── 保存最近离开屏幕的ViewHolder（默认容量=2）
├── 3. 扩展缓存 (ViewCacheExtension)
│   └── 开发者自定义缓存（特殊用途）
└── 4. 回收池 (RecycledViewPool)
    └── 全局共享的ViewHolder存储（不同类型独立缓存）
</code></pre><p>根据<code>position</code>判断是否命中<code>Cache</code>，根据<code>viewType</code>判断是否命中<code>RecyclerViewPool</code>，会执行<code>onBindViewHolder</code></p>
<p>在 <strong>RecyclerView</strong> 的回收复用机制中，<code>changedScrap</code> 和 <code>attachedScrap</code> 是两个关键临时缓存，而 <strong>Stable IDs</strong> 会改变 ViewHolder 获取的方式。以下是详细解释：</p>
<hr>
<h3 id="1"><strong>1. <code>changedScrap</code> 的作用</strong></h3>
<ul>
<li><strong>用途</strong>：专门配合 <code>notifyItemChanged()</code> 或 <code>notifyDataSetChanged()</code> 使用。</li>
<li><strong>工作机制</strong>：
<ul>
<li>当调用 <code>notifyItemChanged(position)</code> 时，被标记更新的 item 会被临时移到 <code>changedScrap</code> 中。</li>
<li>在布局阶段（如 <code>onLayout</code>），这些 ViewHolder 会被重新绑定数据（调用 <code>onBindViewHolder()</code>），然后放回原位置。</li>
</ul>
</li>
<li><strong>目的</strong>：支持局部更新动画（如淡入淡出），避免直接回收导致视觉中断。</li>
</ul>
<hr>
<h3 id="2"><strong>2. <code>attachedScrap</code> 的作用</strong></h3>
<ul>
<li><strong>用途</strong>：用于 <strong>快速复用可见或即将可见的 ViewHolder</strong>。</li>
<li><strong>工作机制</strong>：
<ul>
<li>在布局过程中（如 <code>LinearLayoutManager.fill()</code>），RecyclerView 会先将当前屏幕上的 ViewHolder <strong>临时移除</strong> 到 <code>attachedScrap</code>。</li>
<li>遍历新布局时，直接从 <code>attachedScrap</code> 中按 <strong>position 匹配</strong> 取回 ViewHolder（无需创建或绑定）。</li>
</ul>
</li>
<li><strong>目的</strong>：避免无效的创建/绑定，提升滚动性能（尤其在快速滑动时）。</li>
</ul>
<hr>
<h3 id="3-stable-ids-如何改变-viewholder-获取方式"><strong>3. Stable IDs 如何改变 ViewHolder 获取方式</strong></h3>
<p>当启用 <strong>Stable IDs</strong>（通过 <code>setHasStableIds(true)</code> + 重写 <code>getItemId()</code>）时：</p>
    </div>
    <a href="/android-develop/recyclerview%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/" class="ba b--moon-gray bg-light-gray br2 color-inherit dib f7 hover-bg-moon-gray link mt2 ph2 pv1"></a>
  </div>
</div>

        </div>
      
    </section>
  </div>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white white-70 dn dib-ns pv2 ph3 no-underline" href="http://localhost:1313/" >
    &copy;  zed的博客 2025 
  </a>
    <div><div class="ananke-socials"></div>
</div>
  </div>
</footer>

  </body>
</html>
