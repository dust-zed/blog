<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Rust on zed的博客</title>
        <link>http://localhost:1313/categories/rust/</link>
        <description>Recent content in Rust on zed的博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Fri, 22 Aug 2025 06:01:17 +0800</lastBuildDate><atom:link href="http://localhost:1313/categories/rust/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Rust中的IO操作</title>
        <link>http://localhost:1313/rust/rust%E4%B8%AD%E7%9A%84io%E6%93%8D%E4%BD%9C/</link>
        <pubDate>Fri, 22 Aug 2025 06:01:17 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/rust%E4%B8%AD%E7%9A%84io%E6%93%8D%E4%BD%9C/</guid>
        <description>&lt;p&gt;在Rust中，I/O操作主要通过&lt;code&gt;Read&lt;/code&gt;和&lt;code&gt;Write&lt;/code&gt;两个核心trait实现，而&lt;code&gt;Cursor&lt;/code&gt;、&lt;code&gt;BufWriter&lt;/code&gt;和&lt;code&gt;ReadBuf&lt;/code&gt;是围绕这些trait的实用工具。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;1-read和write-trait&#34;&gt;1. &lt;code&gt;Read&lt;/code&gt;和&lt;code&gt;Write&lt;/code&gt; trait
&lt;/h4&gt;&lt;h5 id=&#34;stdioread&#34;&gt;&lt;code&gt;std::io::Read&lt;/code&gt;
&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;：从数据源（文件、网络等）读取字节流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心方法&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;read&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; self, buf: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; [&lt;span style=&#34;color:#66d9ef&#34;&gt;u8&lt;/span&gt;]) -&amp;gt; Result&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;尝试读取数据到缓冲区&lt;code&gt;buf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;返回实际读取的字节数(&lt;code&gt;Ok(n)&lt;/code&gt;)，或错误（&lt;code&gt;Err(e)&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;当读取到EOF时返回&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;常用方法&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;read_to_end(&amp;amp;mut vec)&lt;/code&gt;:读取所有字节到&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read_to_string(&amp;amp;mut string)&lt;/code&gt;:读取UTF-8字节到&lt;code&gt;String&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read_exact(&amp;amp;mut buf)&lt;/code&gt;:精确读取&lt;code&gt;buf.len()&lt;/code&gt;字节，否则报错&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;stdiowrite&#34;&gt;&lt;code&gt;std::io::Write&lt;/code&gt;
&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;：将字节流写入目标&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心方法&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;write&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; self, buf: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;u8&lt;/span&gt;]) -&amp;gt; Result&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;flush&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; self) -&amp;gt; Result&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;()&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;write&lt;/code&gt;尝试写入缓冲区&lt;code&gt;buf&lt;/code&gt;，返回实际写入的字节数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flush&lt;/code&gt;确保所有缓冲数据写入目标（如磁盘）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;2-cursort&#34;&gt;2. &lt;code&gt;Cursor&amp;lt;T&amp;gt;&lt;/code&gt;
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;：将内存类型包装成可&lt;code&gt;随机访问&lt;/code&gt;的&lt;code&gt;Read&lt;/code&gt;/&lt;code&gt;Write&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在内存中模拟文件指针（维护&lt;code&gt;position&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;实现Read和Write（需&lt;code&gt;T: AsMut&amp;lt;[u8]&amp;gt;&lt;/code&gt;)，支持&lt;code&gt;Seek&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;零成本抽象，高性能内存操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;使用场景&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;读取数据，或写入到&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;测试时代替真实文件I/O。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3-bufwriterw&#34;&gt;3. &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt;
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;：包装一个&lt;code&gt;Write&lt;/code&gt;对象，提供&lt;strong&gt;写入缓冲&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少系统调用（如磁盘、网络写入）。&lt;/li&gt;
&lt;li&gt;批量写入提高性能（默认缓冲区大小&lt;strong&gt;8KB&lt;/strong&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;行为&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先写入内存缓冲区，满时自动刷新到内部&lt;code&gt;W&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;手动调用&lt;code&gt;flush()&lt;/code&gt;或&lt;code&gt;Drop&lt;/code&gt;时强制刷新缓冲区。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;4-bufreaderr&#34;&gt;4. &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt;
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;：包装&lt;code&gt;Read&lt;/code&gt;对象，提供&lt;strong&gt;读取缓冲&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少频繁系统调用（如读取文件时多次小数据读取）&lt;/li&gt;
&lt;li&gt;支持按行读取（&lt;code&gt;read_line&lt;/code&gt;和&lt;code&gt;lines&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;完整知识图谱&#34;&gt;完整知识图谱
&lt;/h4&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;I/O 核心 Trait
│
├── Read (字节源)
│   ├── 实现类型：File, TcpStream, Vec&amp;lt;u8&amp;gt;, etc.
│   ├── 工具：BufReader (缓冲读取), Take (限制读取长度)
│   └── 扩展：BufRead (提供 read_line, lines 等方法)
│
├── Write (字节目标)
│   ├── 实现类型：File, TcpStream, Vec&amp;lt;u8&amp;gt;, etc.
│   └── 工具：BufWriter (缓冲写入), LineWriter (行缓冲)
│
├── Seek (随机访问)
│   └── 实现类型：File, Cursor&amp;lt;T&amp;gt;
│
└── 内存适配器
    └── Cursor&amp;lt;T&amp;gt; (内存模拟 I/O)
        ├── 支持：Read/Write/Seek
        └── 适用：Vec&amp;lt;u8&amp;gt;, &amp;amp;[u8], String, &amp;amp;str
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h5 id=&#34;关键原则&#34;&gt;关键原则
&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;1. 缓冲使用&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BufReader/BufWriter总是推荐用于文件/网络 I/O。&lt;/li&gt;
&lt;li&gt;Cursor用于内存数据（如解析二进制格式）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 错误处理&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有I/O操作返回&lt;code&gt;Result&lt;/code&gt;，必须处理&lt;code&gt;Err&lt;/code&gt;情况。&lt;/li&gt;
&lt;li&gt;特别注意&lt;code&gt;flush()&lt;/code&gt;的错误（如磁盘满）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3. 性能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小数据写入用&lt;code&gt;BufWriter&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;避免频繁小数据读取（缓冲或批量化）&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>大端序和小端序</title>
        <link>http://localhost:1313/rust/%E5%A4%A7%E7%AB%AF%E5%BA%8F%E5%92%8C%E5%B0%8F%E7%AB%AF%E5%BA%8F/</link>
        <pubDate>Fri, 22 Aug 2025 03:33:16 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/%E5%A4%A7%E7%AB%AF%E5%BA%8F%E5%92%8C%E5%B0%8F%E7%AB%AF%E5%BA%8F/</guid>
        <description>&lt;p&gt;大端序和小端序是两种不同的&lt;strong&gt;字节存储顺序&lt;/strong&gt;，用于描述多字节数据（如整数、浮点数）在计算机内存中的存储方式。它们的区别在于字节的排列顺序：&lt;/p&gt;
&lt;h4 id=&#34;大端序&#34;&gt;大端序
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;高位字节存储在低地址&lt;/strong&gt;，低位字节存储在高地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;小端序&#34;&gt;小端序
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;低位字节存储在低地址&lt;/strong&gt;，高位字节存储在高地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;小端序更符合计算机的处理逻辑&lt;/p&gt;
</description>
        </item>
        <item>
        <title>需要多熟悉的rust语法</title>
        <link>http://localhost:1313/rust/%E9%9C%80%E8%A6%81%E5%A4%9A%E7%86%9F%E6%82%89%E7%9A%84rust%E8%AF%AD%E6%B3%95/</link>
        <pubDate>Tue, 19 Aug 2025 15:02:39 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/%E9%9C%80%E8%A6%81%E5%A4%9A%E7%86%9F%E6%82%89%E7%9A%84rust%E8%AF%AD%E6%B3%95/</guid>
        <description>&lt;h4 id=&#34;绑定运算符&#34;&gt;@(绑定运算符)
&lt;/h4&gt;&lt;p&gt;在Rust中，&lt;code&gt;@&lt;/code&gt;被称为绑定运算符，用于在模式匹配的值绑定到一个变量，同时允许进一步解构内部结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体解析&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt; self.reader.read(buf) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Ok(len) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    self.size &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; len;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Ok(len)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  err &lt;span style=&#34;color:#f92672&#34;&gt;@&lt;/span&gt; Err(_) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; err
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Ok(len)&lt;/code&gt;分支&lt;/strong&gt;：匹配成功的&lt;code&gt;Ok&lt;/code&gt;变体，提取内部的&lt;code&gt;len&lt;/code&gt;值，然后更新&lt;code&gt;self.size&lt;/code&gt;并返回&lt;code&gt;Ok(len)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;**&lt;code&gt;err @ Err(_)&lt;/code&gt;**分支：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Err(_)&lt;/code&gt;匹配任意&lt;code&gt;Err&lt;/code&gt;变体(不关心内部错误的具体值)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@&lt;/code&gt;将整个Err的值(如&lt;code&gt;Err(&amp;quot;io_error&amp;quot;)&lt;/code&gt;)绑定到变量&lt;code&gt;err&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;分支返回&lt;code&gt;err&lt;/code&gt;，即原始的&lt;code&gt;Err&lt;/code&gt;值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解构默认会发生所有权转移，&lt;code&gt;let Data(inner) = &amp;amp;data;&lt;/code&gt;等价于&lt;code&gt;let Data(ref inner) = &amp;amp;data;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;asref&#34;&gt;AsRef
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;AsRef&lt;/code&gt; trait的核心作用是允许一个类型以&lt;strong&gt;零开销&lt;/strong&gt;的方式将自己或引用转换成&lt;strong&gt;另一种类型的引用&lt;/strong&gt;。&lt;code&gt;AsMut&lt;/code&gt;是&lt;code&gt;AsRef&lt;/code&gt;的可变版本&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 核心机制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt;定义了一个方法：&lt;code&gt;fn as_ref(&amp;amp;self) -&amp;gt; &amp;amp;T&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;它接受&lt;code&gt;&amp;amp;self&lt;/code&gt;，返回目标类型&lt;code&gt;&amp;amp;T&lt;/code&gt;的引用&lt;/li&gt;
&lt;li&gt;本质上：将&lt;code&gt;&amp;amp;Self&lt;/code&gt;转换为&lt;code&gt;&amp;amp;T&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 转换类型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;允许的是&lt;code&gt;Self&lt;/code&gt;到&lt;code&gt;T&lt;/code&gt;的引用转换。&lt;/li&gt;
&lt;li&gt;例如：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;String&lt;/code&gt;实现&lt;code&gt;AsRef&amp;lt;str&amp;gt;&lt;/code&gt;: &lt;code&gt;&amp;amp;String -&amp;gt; &amp;amp;str&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 实现&lt;code&gt;AsRef&amp;lt;[T]&amp;gt;&lt;/code&gt;: &lt;code&gt;&amp;amp;Vec&amp;lt;T&amp;gt; -&amp;gt;&amp;amp;[T]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PathBuf&lt;/code&gt;实现&lt;code&gt;AsRef&amp;lt;Path&amp;gt;&lt;/code&gt;: &lt;code&gt;&amp;amp;PathBuf -&amp;gt; &amp;amp;Path&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;**3. 设计目的 **&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;泛型灵活性：让函数接受多种类型参数&lt;/li&gt;
&lt;li&gt;零开销抽象：转换过程无额外堆分配或复制&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;零开销&#34;&gt;零开销
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;什么是零开销&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈操作和微小的寄存器复制是允许的&lt;/li&gt;
&lt;li&gt;没有&lt;strong&gt;堆内存分配&lt;/strong&gt;：绝不调用内存分配器&lt;/li&gt;
&lt;li&gt;没有&lt;strong&gt;深拷贝&lt;/strong&gt;：不复制底层数据本身（即使是栈上的解构也需要合理区分）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;切片引用&#34;&gt;切片引用
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;切片引用本质就是宽指针&lt;/strong&gt;，由&lt;strong&gt;数据指针&lt;/strong&gt;和&lt;strong&gt;长度&lt;/strong&gt;组成&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;condvar&#34;&gt;Condvar
&lt;/h4&gt;&lt;p&gt;在rust中，&lt;code&gt;Condvar&lt;/code&gt;（条件变量）是用于线程间同步的核心工具，通常与&lt;code&gt;Mutex&lt;/code&gt;结合使用。它的核心功能是让线程在某个条件不满足时&lt;strong&gt;主动阻塞&lt;/strong&gt;，直到其他线程修改条件并通知它继续执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作用：解决线程间的&lt;strong&gt;等待-通知&lt;/strong&gt;问题，避免busy looping。&lt;/li&gt;
&lt;li&gt;依赖：必须与&lt;code&gt;Mutex&lt;/code&gt;配合使用（保护共享数据 + 同步条件）&lt;/li&gt;
&lt;li&gt;典型场景：生产者-消费者模型、任务队列调度、资源池管理等。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::sync::{Arc, Mutex, Condvar};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::thread;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;//创建共享数据结构：(Mutex&amp;lt;bool&amp;gt;, Condvar)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; pair &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Arc::new(Mutex::new(&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;), Condvar::new()));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; pair_clone &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Arc::clone(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;pair);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; consumer &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; thread::spawn(&lt;span style=&#34;color:#66d9ef&#34;&gt;move&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (lock, cvar) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;*&lt;/span&gt;pair_clone;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; condition &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lock.lock().unwarp();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//等条件满足
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!*&lt;/span&gt;condition {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;//释放锁并阻塞，被唤醒后(wait返回后)重新获取锁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      condition &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cvar.wait(condition).unwarp();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;println!&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;消费者：条件已满足！继续执行&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//消费者的处理逻辑
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	thread::sleep(Duration::from_secs(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;));&lt;span style=&#34;color:#75715e&#34;&gt;//模拟工作耗时
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  	&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (lock, cvar) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;*&lt;/span&gt;pair;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; condition &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lock.lock().unwarp();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;println!&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;生产者：更新条件并通知消费者...&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;condition &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 通知一个等待的消费者线程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    cvar.notify_one();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	consumer.join().unwrap();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;println!&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;主线程: 所有线程执行完成&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h4 id=&#34;pin&#34;&gt;PIN
&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;haystack&lt;/code&gt;&lt;strong&gt;命名源自英语谚语&lt;/strong&gt;&amp;ldquo;looking for a needle in a haystack&amp;rdquo;&lt;/strong&gt;(大海捞针),&lt;code&gt;haystack&lt;/code&gt;表示被搜索的&lt;strong&gt;主体数据&lt;/strong&gt;，&lt;code&gt;needle&lt;/code&gt;表示待查找的&lt;strong&gt;目标元素&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;rust中有两种解引用的方式：&lt;strong&gt;&lt;code&gt;*&lt;/code&gt;&lt;strong&gt;和&lt;/strong&gt;模式匹配解引用&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;unicodeascii和utf-8等&#34;&gt;Unicode、ASCII和UTF-8等
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Unicode&lt;/strong&gt;为所有字符分配了唯一标识(称为&lt;strong&gt;码点&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UTF-8&lt;/strong&gt;等是需要将这些码点转换为用于存储/传输的&lt;strong&gt;字节序列&lt;/strong&gt;,根据&lt;strong&gt;码点值的范围分类&lt;/strong&gt;，确定字节序列的&lt;strong&gt;长度&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ASCII&lt;/strong&gt;是Unicode和UTF-8的&lt;strong&gt;特殊兼容子集&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;字符数据&#34;&gt;字符数据
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt;前缀标识的数据：表示&lt;code&gt;ASCII&lt;/code&gt;字符集的字节数据，类型为&lt;code&gt;u8&lt;/code&gt;或&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;和&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;：&lt;code&gt;&amp;amp;str&lt;/code&gt;是utf-8编码的切片引用且不可变，&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;是对原始字节的切片引用，可变版本是&lt;code&gt;&amp;amp;mut [u8]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Ripgrep的命令文档</title>
        <link>http://localhost:1313/rust/ripgrep%E7%9A%84%E5%91%BD%E4%BB%A4%E6%96%87%E6%A1%A3/</link>
        <pubDate>Fri, 15 Aug 2025 12:50:54 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/ripgrep%E7%9A%84%E5%91%BD%E4%BB%A4%E6%96%87%E6%A1%A3/</guid>
        <description>&lt;p&gt;用法 （&lt;code&gt;[]&lt;/code&gt;内表示是可选参数):&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rg [OPTIONS] PATTERN [PATH ...]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rg [OPTIONS] -e PATTERN ... [PATH ...]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rg [OPTIONS] -f PATTERNFILE ... [PATH ...]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rg [OPTIONS] --files [PATH ...]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rg [OPTIONS] --type-list&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;command | rg [OPTIONS] PATTERN&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rg [OPTIONS] --help&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rg [OPTIONS] --version&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;参数解释&#34;&gt;参数解释
&lt;/h4&gt;&lt;p&gt;PATTERN: 要搜索的正则表达式，以&lt;code&gt;-&lt;/code&gt;开始的正则需要添加 &lt;code&gt;-e&lt;/code&gt;/&lt;code&gt;--regexp&lt;/code&gt;flag，如&lt;code&gt;rg -e -foo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;PATH&amp;hellip;: 需要检索的文件或目录&lt;/p&gt;
&lt;h4 id=&#34;输入选项input-options&#34;&gt;输入选项(input options)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--&lt;/code&gt;：表示后续以&lt;code&gt;-&lt;/code&gt;开头的&lt;code&gt;word&lt;/code&gt;都不再是&lt;code&gt;flag&lt;/code&gt;而是&lt;code&gt;pattern&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-e PATTERN, --regexp=PATTERN&lt;/code&gt;: 需要搜索的正则表达式，可多次指定&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-f PATTERNFILE, --file=PATTERNFILE&lt;/code&gt;:指定从何文件搜索正则表达式，可多次指定&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--pre=COMMAND&lt;/code&gt; 允许指定一个文件格式转换命令，ripgrep会先将文件通过该命令转换，然后在转换后的内容搜索正则表达式。&lt;code&gt;文件&lt;/code&gt; → &lt;code&gt;COMMAND处理&lt;/code&gt; → &lt;code&gt;获取标准输出&lt;/code&gt; → &lt;code&gt;ripgrep搜索输出内容&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;--pre-glob=GLOB&lt;/code&gt;专为&lt;code&gt;--pre&lt;/code&gt;命令设计，精确的筛选需要预处理的文件，避免对不匹配的文件执行不必要的格式转换，大幅提升性能。&lt;code&gt;rg --pre=pre-pdftotext --pre-glob=&#39;*.pdf&#39; &#39;关键词&#39;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;report.pdf&lt;/code&gt; → 调用 &lt;code&gt;pdftotext&lt;/code&gt; 转换后搜索&lt;/li&gt;
&lt;li&gt;&lt;code&gt;notes.txt&lt;/code&gt; → 直接搜索文本（省去进程创建）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-z, --search-zip&lt;/code&gt;搜索压缩包&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;search-options&#34;&gt;search options
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-s, --case-sensitive&lt;/code&gt;执行搜索时区分大小写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-i, --ignore-case&lt;/code&gt;执行搜索时不区分大小写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--crlf&lt;/code&gt;启动时将CRLF(\r\n)视为行终止符，而不是\n&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--dfa-size-limit=NUM+SUFFIX?&lt;/code&gt;正则表达式的dfa上限，可带单位&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--regex-size-limit=NUM+SUFFIX?&lt;/code&gt;设置&lt;strong&gt;在内存中构建&lt;/strong&gt;的整体正则表达式对象的最大尺寸&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--engine=ENGINE&lt;/code&gt;指定正则表达式引擎&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-E ENCODING, --encoding=ENCODING&lt;/code&gt;强制 ripgrep 使用特定编码处理所有被搜索文件（默认自动检测编码）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-F, --fixedstrings&lt;/code&gt;将所有模式视为字面量而不是正则表达式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v --invert-match&lt;/code&gt;反转匹配，打印不匹配的行，&lt;code&gt;--no-invert-match&lt;/code&gt;为相反的输入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-x --line-regexp&lt;/code&gt;整行匹配&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-w, --word-regexp&lt;/code&gt;独立单词匹配，启用此标志后，ripgrep 只显示被&lt;strong&gt;单词边界&lt;/strong&gt;包围的匹配结果。类似于在正则表达式中自动给搜索词添加 &lt;code&gt;\b&lt;/code&gt; 边界，比&lt;code&gt;-x&lt;/code&gt;优先级高&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-m NUM, --max-count=NUM&lt;/code&gt;  限制每个文件的匹配行数量，到达指定数量就停止当前文件搜索&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--mmap&lt;/code&gt;优先使用&lt;code&gt;mmap&lt;/code&gt;技术进行文件搜索&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-U, --multiline&lt;/code&gt;多行模式，允许匹配内容跨越多个行，突破默认的单行匹配限制&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--multiline-dotall&lt;/code&gt;当启用多行搜索时(&lt;code&gt;-U&lt;/code&gt;)，强制正则表达式中的点号&lt;code&gt;.&lt;/code&gt;匹配&lt;strong&gt;包括换行符&lt;/strong&gt;的所有字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-unicode&lt;/code&gt;禁用unicode模式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--null-data&lt;/code&gt; 将默认的行终止符从换行符&lt;code&gt;\n&lt;/code&gt;改为NUL字符(&lt;code&gt;\0&lt;/code&gt;或ASCII 0)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-P, --pcre2&lt;/code&gt;切换默认的正则引擎更换为&lt;strong&gt;PCRE2&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-S, --smart-case&lt;/code&gt;启用智能大小写匹配模式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--stop-no-nonmatch&lt;/code&gt;找到至少一个匹配行且后续遇到不匹配行就提前停止读取文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-a, --text&lt;/code&gt;强制将所有文件当作纯文本文件处理，禁用其默认的二进制文件检测机制&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-j NUM, --threads=NUM&lt;/code&gt;控制搜索时使用的并行线程数&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;filter-options&#34;&gt;filter options
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--binary&lt;/code&gt; 默认情况下ripgrep使用&lt;code&gt;NUL&lt;/code&gt;字节作为启发式标志。一旦在文件中检测到NUL字节，立即判断为二进制文件，然后立即停止搜索该文件并不显示匹配内容。启用后即使检测到NUL字节，也继续搜索文件，直到找到&lt;strong&gt;首个匹配项&lt;/strong&gt;或搜索到&lt;strong&gt;文件结束&lt;/strong&gt;停止搜索&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-L, --follow&lt;/code&gt; 开启“跟随符号链接”功能（默认关闭）,用 &lt;code&gt;--no-follow&lt;/code&gt; 在本命令中取消 &lt;code&gt;-L&lt;/code&gt; 的效果&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-g GLOB, --glob=GLOB&lt;/code&gt; 通过通配符模式（glob）&lt;strong&gt;包含或排除特定文件和目录&lt;/strong&gt;进行搜索&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--glob-case-insensitive&lt;/code&gt;让所有通过&lt;code&gt;-g/--glob&lt;/code&gt;指定的通配符进行不区分大小写的匹配，&lt;code&gt;--no-glob-case-insensitive&lt;/code&gt;取消此效果&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--iglob=GLOB&lt;/code&gt;允许用户通过&lt;strong&gt;不区分大小写&lt;/strong&gt;的通配符模式来&lt;strong&gt;包含或排除文件/目录&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-., --hidden&lt;/code&gt; 搜索隐藏文件和目录，&lt;code&gt;--no-hidden&lt;/code&gt;取消此效果&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--ignore-file=PATH&lt;/code&gt; 通过外部文件指定忽略规则（&lt;code&gt;gitignore&lt;/code&gt; 格式）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--ignore-file-case-insensitive&lt;/code&gt; 控制&lt;strong&gt;忽略文件规则匹配时是否区分大小写&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d NUM, --max-depth=NUM&lt;/code&gt;指定搜索的目录遍历的深度层级&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--max-filesize=NUM+SUFFIX?&lt;/code&gt;  跳过超过指定大小的文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-ignore&lt;/code&gt; 跳过所有忽略文件，&lt;code&gt;--ignore&lt;/code&gt;取消这效果&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-ignore-dot&lt;/code&gt;  仅跳过 &lt;code&gt;.ignore&lt;/code&gt; 和&lt;code&gt;.rgignore&lt;/code&gt; 文件中的过滤规则，通过 &lt;code&gt;--ignore-dot&lt;/code&gt; 可关闭此功能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-ignore-exclude&lt;/code&gt; 禁用手动配置的排除规则，&lt;code&gt;--ignore-exclude&lt;/code&gt;取消此效果&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-ignore-files&lt;/code&gt; 禁用显式指定的忽略文件，&lt;code&gt;--ignore-files&lt;/code&gt;取消此效果&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-ignore-global&lt;/code&gt; 禁用来自“全局”源的忽略规则（&lt;code&gt;.gitignore&lt;/code&gt; 文件），&lt;code&gt;--ignore-global&lt;/code&gt;取消此效果&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-ignore-parent&lt;/code&gt;不应用从父目录中找到的忽略文件（如 &lt;code&gt;.gitignore&lt;/code&gt;）中的规则，&lt;code&gt;--ignore-parent&lt;/code&gt;取消此效果&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-ignore-vcs&lt;/code&gt; 禁用版本控制系统的忽略规则，&lt;code&gt;-ignore--vcs&lt;/code&gt;取消此效果&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-require-git&lt;/code&gt; 默认只在git仓库才遵守版本控制的忽略文件（如&lt;code&gt;.gitignore&lt;/code&gt;），启用后即使不再git仓库，也会遵守版本控制的忽略文件。&lt;code&gt;--require-git&lt;/code&gt;取消此效果&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-file-system&lt;/code&gt; 遍历目录树搜索文件时，不会跨越任何文件系统边界，&lt;code&gt;--no-one-file-system&lt;/code&gt;取消此效果。在搜索&lt;strong&gt;每个给定的起始路径&lt;/strong&gt;时，遇到&lt;strong&gt;挂载点（通往另一个文件系统的“门”）就停下来，不进去搜索&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-t TYPE, --type=TYPE&lt;/code&gt;  用于限制只搜索特定类型的文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-T TYPE, --type-not=TYPE&lt;/code&gt; 用于&lt;strong&gt;排除&lt;/strong&gt;指定类型的文件不进行搜索&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--type-add=TYPESPEC&lt;/code&gt;  用于创建自定义文件类型匹配规则&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--type-clear=TYPE&lt;/code&gt; 清楚 &lt;code&gt;type-add&lt;/code&gt;创建的自定义文件类型匹配规则&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-u, --unrestricted&lt;/code&gt; 标志通过多次重复（最高3次）逐步降低 ripgrep 的智能过滤级别，使搜索范围越来越广&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;output-options&#34;&gt;output options
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-A NUM, --after-context=NUM&lt;/code&gt;  会显示每条匹配结果&lt;strong&gt;之后&lt;/strong&gt;的 NUM 行内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-B, --before-context=NUM&lt;/code&gt; 会显示每条匹配结果之前的NUM行内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-C NUM, --context=NUM&lt;/code&gt;在匹配结果前后显示NUM行内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;block-buffered&lt;/code&gt;使用内存缓冲区，只有当这个缓冲区积累到一定大小后，才会一次性将其内容**刷新 (flush) **到标准输出 (stdout)。&lt;code&gt;--no-block-buffered&lt;/code&gt;取消此功能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-b, --byte-offset&lt;/code&gt;在输出中添加数字前缀，表示行或匹配文本在文件中的起始字节位置（从0开始计数）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--color=WHEN&lt;/code&gt;此选项决定何时在输出中使用&lt;strong&gt;颜色高亮&lt;/strong&gt;和&lt;strong&gt;ANSI转义序列&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--colors=COLOR_SPEC&lt;/code&gt;选项用于&lt;strong&gt;自定义输出内容的颜色和样式&lt;/strong&gt;，可通过多次指定实现多层样式叠加&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--column&lt;/code&gt;在输出中增加列号信息，&lt;code&gt;--no-column&lt;/code&gt;取消这个功能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--context-separator=SEPARATOR&lt;/code&gt;在使用上下文选项（&lt;code&gt;-A/-B/-C&lt;/code&gt;）时，指定&lt;strong&gt;分隔不同上下文块的显示符号&lt;/strong&gt;,&lt;code&gt;--no-context-separator&lt;/code&gt;取消此功能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--field-match-separator=SEPARATOR&lt;/code&gt;自定义 ripgrep 输出结果中&lt;strong&gt;各字段之间的分隔符号&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--heading&lt;/code&gt;在每个文件匹配结果组的&lt;strong&gt;顶部&lt;/strong&gt;显示一次文件路径，而不是在每行匹配前都重复显示，&lt;code&gt;--no-heading&lt;/code&gt;取消此功能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-h, --help&lt;/code&gt;      &lt;code&gt;-h&lt;/code&gt;是精简帮助模式，&lt;code&gt;--help&lt;/code&gt;是完整帮助模式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--hyperlink-format=FORMAT&lt;/code&gt;  创建可点击的超链接&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Rust学习计划</title>
        <link>http://localhost:1313/rust/rust%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</link>
        <pubDate>Fri, 08 Aug 2025 11:37:40 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/rust%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</guid>
        <description>&lt;h4 id=&#34;一巩固基础&#34;&gt;一、巩固基础
&lt;/h4&gt;&lt;h5 id=&#34;1-精读rust程序设计语言&#34;&gt;1. 精读《Rust程序设计语言》
&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;* 重读 [The Book](https://doc.rust-lang.org/book/)并完成所有课后练习
* 重点章节：所有权、错误处理、泛型、trait、声明周期、智能指针、并发
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;2-标准库深度探索&#34;&gt;2. 标准库深度探索
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;掌握核心traits：&lt;code&gt;From&lt;/code&gt;/&lt;code&gt;Into&lt;/code&gt;, &lt;code&gt;TryFrom&lt;/code&gt;/&lt;code&gt;TryInto&lt;/code&gt;, &lt;code&gt; AsRef&lt;/code&gt;/&lt;code&gt;AsMut&lt;/code&gt;, &lt;code&gt;Deref&lt;/code&gt;等&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;cargo doc --open&lt;/code&gt; 本地标准库文档并阅读源码&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;二项目实践&#34;&gt;二、项目实践
&lt;/h4&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;graph LR
    A[基础项目] --&amp;gt; B[中等项目]
    B --&amp;gt; C[高级项目]
    
    A --&amp;gt; |CLI工具| A1[grep实现]
    A --&amp;gt; |网络| A2[HTTP代理]
    A --&amp;gt; |系统| A3[文件监视器]
    
    B --&amp;gt; |Web| B1[使用Actix/Axum构建API]
    B --&amp;gt; |算法| B2[数据结构实现]
    B --&amp;gt; |并发| B3[线程池实现]
    
    C --&amp;gt; |OS| C1[操作系统内核]
    C --&amp;gt; |分布式| C2[分布式键值存储]
    C --&amp;gt; |编译器| C3[解释器/LSP]
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;三深度进阶&#34;&gt;三、深度进阶
&lt;/h4&gt;&lt;h5 id=&#34;1-内存与优化&#34;&gt;1. 内存与优化
&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;* 学习`pref`性能分析工具
* 实践`#[inline]`, `Box&amp;lt;[T]&amp;gt;` vs `Vec&amp;lt;T&amp;gt;`等优化
* 阅读Rust性能指南
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;2-高级特性精通&#34;&gt;2. 高级特性精通
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;宏编程&lt;/li&gt;
&lt;li&gt;不安全Rust的正确使用&lt;/li&gt;
&lt;li&gt;Pin/Unpin与自引用结构&lt;/li&gt;
&lt;li&gt;Tokio/Async高级模式&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;四社区参与持续进行&#34;&gt;四、社区参与（持续进行）
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;代码贡献&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参与&lt;code&gt;tokio&lt;/code&gt;等知名项目&lt;/li&gt;
&lt;li&gt;解决&lt;code&gt;good-first-issue&lt;/code&gt;标签问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;知识输出&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写技术博客解释Rust概念&lt;/li&gt;
&lt;li&gt;在StackOverflow回答问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;核心学习资源&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-diff&#34; data-lang=&#34;diff&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;+ 2024推荐：
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;- 书籍：《Command-Line Rust》(O&amp;#39;Reilly)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;- 视频：Jon Gjengset的&amp;#34;Crust of Rust&amp;#34;系列
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;- 社区：r/rust 每日阅读
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;- 实践：Advent of Code挑战
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;最后建议&#34;&gt;最后建议
&lt;/h4&gt;&lt;p&gt;当遇到困难时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 cargo clippy 和 cargo miri 辅助诊断&lt;/li&gt;
&lt;li&gt;在 &lt;a class=&#34;link&#34; href=&#34;https://users.rust-lang.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Rust用户论坛&lt;/a&gt; 提问&lt;/li&gt;
&lt;li&gt;阅读标准库相关模块源码（&lt;code&gt;std::collections&lt;/code&gt; 是很好的起点））&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
    </channel>
</rss>
