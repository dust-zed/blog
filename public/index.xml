<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>zed的博客</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on zed的博客</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 13 Jun 2025 09:30:56 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>面试问题收集</title>
      <link>http://localhost:1313/android-develop/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/</link>
      <pubDate>Fri, 13 Jun 2025 09:30:56 +0800</pubDate>
      <guid>http://localhost:1313/android-develop/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86/</guid>
      <description>&lt;h4 id=&#34;一bitmap内存优化&#34;&gt;一、Bitmap内存优化&lt;/h4&gt;&#xA;&lt;p&gt;Bitmap是内存消耗大户，通过以下方法减少占用：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;降低色彩解析模式&lt;/strong&gt;&lt;br&gt;&#xA;使用RGB565等低色彩模式，将单个像素的字节大小从32位（ARGB8888）减少到16位，显著节省内存。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;合理放置资源文件&lt;/strong&gt;&lt;br&gt;&#xA;高分辨率图片应放置在高密度目录（如&lt;code&gt;drawable-xxhdpi&lt;/code&gt;），避免系统自动缩放导致内存浪费。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;缩小图片尺寸&lt;/strong&gt;&lt;br&gt;&#xA;加载时通过&lt;code&gt;BitmapFactory.Options&lt;/code&gt;动态调整采样率（&lt;code&gt;inSampleSize&lt;/code&gt;），或使用&lt;code&gt;createScaledBitmap()&lt;/code&gt;减少宽高尺寸。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h4 id=&#34;二viewmodel与livedata机制&#34;&gt;二、ViewModel与LiveData机制&lt;/h4&gt;&#xA;&lt;p&gt;ViewModel和LiveData是Jetpack组件，用于数据生命周期管理和响应式UI更新。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;粘性事件（Sticky Event）&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：当新观察者订阅&lt;code&gt;LiveData&lt;/code&gt;时，若已有存储值，会立即收到最后一次更新（旧数据）。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：屏幕旋转后，新Activity观察LiveData时触发UI更新（旧数据）。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;来源&lt;/strong&gt;：基于LiveData的版本号对比机制。代码关键部分如下：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;abstract&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LiveData&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; mVersion &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; START_VERSION; &lt;span style=&#34;color:#75715e&#34;&gt;// LiveData当前版本（初始-1）&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LifecycleBoundObserver&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;implements&lt;/span&gt; ObserverWrapper {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; mLastVersion &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; START_VERSION;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;considerNotify&lt;/span&gt;(ObserverWrapper observer) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (observer.&lt;span style=&#34;color:#a6e22e&#34;&gt;mLastVersion&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; mVersion) { &lt;span style=&#34;color:#75715e&#34;&gt;// 核心判断：版本号落后才分发&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      observer.&lt;span style=&#34;color:#a6e22e&#34;&gt;mLastVersion&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mVersion;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      observer.&lt;span style=&#34;color:#a6e22e&#34;&gt;mObserver&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;onChanged&lt;/span&gt;((T)data);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;简单解法&lt;/strong&gt;：使用&lt;code&gt;Event&lt;/code&gt;包装数据。事件消费后置空值，避免旧数据触发更新。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;ViewModel临时数据保存机制&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;内存中保存&lt;/strong&gt;&lt;br&gt;&#xA;ViewModel对象存储在&lt;code&gt;ViewModelStore&lt;/code&gt;中。当配置变更（如屏幕旋转）时：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Activity/Fragment被销毁重建。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ViewModelStore&lt;/code&gt;被系统保留（绑定到&lt;code&gt;NonConfigurationInstances&lt;/code&gt;）。&lt;/li&gt;&#xA;&lt;li&gt;新建Activity/Fragment时自动恢复ViewModel实例。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;数据范围与最佳实践&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;保留场景&lt;/strong&gt;：屏幕旋转、分屏切换、系统语言更改。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;不保留场景&lt;/strong&gt;：用户退出应用、系统资源不足杀死进程、Activity被finish()。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;最佳实践&lt;/strong&gt;：&#xA;&lt;ol&gt;&#xA;&lt;li&gt;ViewModel解决配置变更的&lt;strong&gt;临时数据保存&lt;/strong&gt;（内存级）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;SavedStateHandle&lt;/code&gt;解决进程被杀死时的&lt;strong&gt;关键数据持久化&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;复杂数据应使用数据库等持久化方案。&lt;/li&gt;&#xA;&lt;li&gt;避免内存泄漏：勿在ViewModel持有Context/View引用，必要时用&lt;code&gt;Application Context&lt;/code&gt;代替。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h4 id=&#34;三view基础原理&#34;&gt;三、View基础原理&lt;/h4&gt;&#xA;&lt;p&gt;深入理解View的测量、布局、绘制机制，是优化UI性能的核心。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;MeasureSpec计算与布局优化&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;MeasureSpec原理&lt;/strong&gt;：父容器传递给子View的测量要求，由大小和模式组成，取决于父容器的MeasureSpec和子View的LayoutParams。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;父布局根据自身MeasureSpec和子View LayoutParams，确定子View的MeasureSpec，再调用&lt;code&gt;children.measure()&lt;/code&gt;，最终确定自身尺寸。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;布局性能优化&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;缓存MeasureSpec计算结果：固定尺寸View（如按钮）直接调用&lt;code&gt;setMeasuredDimension()&lt;/code&gt;设置宽高。&lt;/li&gt;&#xA;&lt;li&gt;优化布局流程：减少嵌套层级、懒加载布局、合并重复布局。&lt;/li&gt;&#xA;&lt;li&gt;避免无效重绘：使用局部刷新机制。&lt;/li&gt;&#xA;&lt;li&gt;精确控制绘制范围：通过&lt;code&gt;Canvas.clipRect()&lt;/code&gt;限制绘制区域。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;getMeasuredWidth()与getWidth()区别&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;getMeasuredWidth()&lt;/strong&gt;：测量阶段后分配的宽度（含内边距）。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用时机：&lt;code&gt;onMeasure()&lt;/code&gt;后或&lt;code&gt;layout()&lt;/code&gt;前。&lt;/li&gt;&#xA;&lt;li&gt;特点：反映视图的期望宽度；若布局未强制改变尺寸，可能与&lt;code&gt;getWidth&lt;/code&gt;相同。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;getWidth()&lt;/strong&gt;：布局阶段后的最终可见宽度（屏幕实际值）。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用时机：&lt;code&gt;onLayout&lt;/code&gt;后。&lt;/li&gt;&#xA;&lt;li&gt;计算方式：&lt;code&gt;width = right - left&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;requestLayout()与invalidate()区别&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;requestLayout()&lt;/strong&gt;：请求整个视图树的测量（measure）和布局（layout）流程。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;触发场景：视图尺寸/位置变化、动态添加/移除子视图、&lt;code&gt;setVisibility()&lt;/code&gt;导致布局结构变化。&lt;/li&gt;&#xA;&lt;li&gt;执行流程：从当前视图向上回溯到根视图（如ViewRootImpl），依次执行measure → layout。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;invalidate()&lt;/strong&gt;：仅标记视图的局部区域为“脏区”，请求下一帧重绘该区域。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;触发场景：视图内容变化但不影响尺寸/位置（如&lt;code&gt;onDraw()&lt;/code&gt;依赖数据更新）。&lt;/li&gt;&#xA;&lt;li&gt;执行流程：标记脏区 → 加入重绘队列 → 下一帧VSync信号时调用&lt;code&gt;onDraw()&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;View坐标体系&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;getX()/getY()&lt;/strong&gt;：相对当前View左上角的局部坐标（触摸点在View内的位置）。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;特点：与父容器无关；值可为负（如滑动超出View边界）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;getRawX()/getRawY()&lt;/strong&gt;：相对屏幕左上角的全局坐标。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;特点：包含状态栏高度（&lt;code&gt;getRawY()&lt;/code&gt;从屏幕顶部算起）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;getLocationOnScreen()&lt;/strong&gt;：获取View左上角在屏幕上的绝对坐标。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;View生命周期关键方法&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;构造函数&lt;/strong&gt;：通过代码或XML创建View实例。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;onAttachedToWindow()&lt;/strong&gt;：View被添加到窗口时调用。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用途：初始化资源、注册监听器、启动动画。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;onDetachedFromWindow()&lt;/strong&gt;：View从窗口移除时调用（如Activity销毁）。&#xA;&lt;ul&gt;&#xA;&lt;li&gt;关键作用：释放资源、停止动画、注销监听器。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;onVisibilityChanged()&lt;/code&gt;可能在&lt;code&gt;onAttachedToWindow()&lt;/code&gt;前/后调用（如View初始化为&lt;code&gt;GONE&lt;/code&gt;）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;onWindowFocusChanged()&lt;/code&gt;可能在&lt;code&gt;onDetachedFromWindow()&lt;/code&gt;后调用（避免在此访问资源）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;View性能优化&lt;/strong&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;过度绘制：todo&lt;/li&gt;&#xA;&lt;li&gt;布局优化：todo&lt;/li&gt;&#xA;&lt;li&gt;绘制优化：todo&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;高级机制与原理&lt;/strong&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;硬件加速：将绘制指令交给GPU，但是部分api不支持&lt;/li&gt;&#xA;&lt;li&gt;SurfaceView与TextureView：todo&lt;/li&gt;&#xA;&lt;li&gt;view.post与Handler：todo&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h4 id=&#34;四事件分发机制&#34;&gt;四、事件分发机制&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;滑动实现方式&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;&lt;code&gt;scrollTo()&lt;/code&gt;/&lt;code&gt;scrollBy()&lt;/code&gt;&lt;/strong&gt;: todo&lt;/li&gt;&#xA;&lt;li&gt;通过&lt;code&gt;ViewDragHelper&lt;/code&gt;实现复杂拖拽: todo&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;自定义下拉刷新控件&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;todo&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;事件分发机制如何提升效率&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;todo&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;嵌套滑动处理&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;todo&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;RecyclerView的滑动冲突处理&lt;/strong&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;todo&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h4 id=&#34;五handler&#34;&gt;五、Handler&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h4 id=&#34;六性能优化-todo&#34;&gt;六、性能优化 （todo）&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;1. **内存管理与泄漏排查**&#xA;1. **UI渲染性能(卡顿优化)**&#xA;1. **启动速度优化**&#xA;1. **功耗优化基础**&#xA;1. **包体积优化**&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h4 id=&#34;七常用库与框架todo&#34;&gt;七、常用库与框架（todo）&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;网络请求(如Retrofit)&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;图片加载(如Glide / Picasso)&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Gradle基础&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h4 id=&#34;八网络与后台&#34;&gt;八、网络与后台&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;RESTful API概念与使用&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;异步处理深入（线程安全、后台限制）&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;缓存策略&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h4 id=&#34;九架构设计&#34;&gt;九、架构设计&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;MVVM/MVI理解与实践&lt;/li&gt;&#xA;&lt;li&gt;模块化 / 组件化&lt;/li&gt;&#xA;&lt;li&gt;设计模式应用&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h4 id=&#34;十新技术与趋势&#34;&gt;十、新技术与趋势&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Compose&lt;/li&gt;&#xA;&lt;li&gt;KMM / Flutter&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h4 id=&#34;十一jvm--内存模型基础&#34;&gt;十一、JVM / 内存模型基础&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;JVM内存结构&lt;/li&gt;&#xA;&lt;li&gt;垃圾回收机制基础&lt;/li&gt;&#xA;&lt;li&gt;常见数据结构与基础算法&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>Categories</title>
      <link>http://localhost:1313/categories/</link>
      <pubDate>Wed, 11 Jun 2025 15:38:21 +0800</pubDate>
      <guid>http://localhost:1313/categories/</guid>
      <description></description>
    </item>
    <item>
      <title>RecyclerView缓存机制</title>
      <link>http://localhost:1313/android-develop/recyclerview%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Wed, 11 Jun 2025 15:26:57 +0800</pubDate>
      <guid>http://localhost:1313/android-develop/recyclerview%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;p&gt;RecyclerView缓存机制&lt;/p&gt;&#xA;&lt;h4 id=&#34;多级缓存体系架构图&#34;&gt;&lt;strong&gt;多级缓存体系架构图&lt;/strong&gt;&lt;/h4&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;TEXT&#xA;&#xA;RecyclerView 缓存系统&#xA;├── 1. 屏幕内缓存 (Attached Scrap)&#xA;│   └── 存放当前可见的ViewHolder（快速复用）&#xA;├── 2. 屏幕外缓存 (Cache)&#xA;│   └── 保存最近离开屏幕的ViewHolder（默认容量=2）&#xA;├── 3. 扩展缓存 (ViewCacheExtension)&#xA;│   └── 开发者自定义缓存（特殊用途）&#xA;└── 4. 回收池 (RecycledViewPool)&#xA;    └── 全局共享的ViewHolder存储（不同类型独立缓存）&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据&lt;code&gt;position&lt;/code&gt;判断是否命中&lt;code&gt;Cache&lt;/code&gt;，根据&lt;code&gt;viewType&lt;/code&gt;判断是否命中&lt;code&gt;RecyclerViewPool&lt;/code&gt;，会执行&lt;code&gt;onBindViewHolder&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;在 &lt;strong&gt;RecyclerView&lt;/strong&gt; 的回收复用机制中，&lt;code&gt;changedScrap&lt;/code&gt; 和 &lt;code&gt;attachedScrap&lt;/code&gt; 是两个关键临时缓存，而 &lt;strong&gt;Stable IDs&lt;/strong&gt; 会改变 ViewHolder 获取的方式。以下是详细解释：&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;1&#34;&gt;&lt;strong&gt;1. &lt;code&gt;changedScrap&lt;/code&gt; 的作用&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;用途&lt;/strong&gt;：专门配合 &lt;code&gt;notifyItemChanged()&lt;/code&gt; 或 &lt;code&gt;notifyDataSetChanged()&lt;/code&gt; 使用。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;工作机制&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当调用 &lt;code&gt;notifyItemChanged(position)&lt;/code&gt; 时，被标记更新的 item 会被临时移到 &lt;code&gt;changedScrap&lt;/code&gt; 中。&lt;/li&gt;&#xA;&lt;li&gt;在布局阶段（如 &lt;code&gt;onLayout&lt;/code&gt;），这些 ViewHolder 会被重新绑定数据（调用 &lt;code&gt;onBindViewHolder()&lt;/code&gt;），然后放回原位置。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;目的&lt;/strong&gt;：支持局部更新动画（如淡入淡出），避免直接回收导致视觉中断。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;2&#34;&gt;&lt;strong&gt;2. &lt;code&gt;attachedScrap&lt;/code&gt; 的作用&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;用途&lt;/strong&gt;：用于 &lt;strong&gt;快速复用可见或即将可见的 ViewHolder&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;工作机制&lt;/strong&gt;：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在布局过程中（如 &lt;code&gt;LinearLayoutManager.fill()&lt;/code&gt;），RecyclerView 会先将当前屏幕上的 ViewHolder &lt;strong&gt;临时移除&lt;/strong&gt; 到 &lt;code&gt;attachedScrap&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;遍历新布局时，直接从 &lt;code&gt;attachedScrap&lt;/code&gt; 中按 &lt;strong&gt;position 匹配&lt;/strong&gt; 取回 ViewHolder（无需创建或绑定）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;目的&lt;/strong&gt;：避免无效的创建/绑定，提升滚动性能（尤其在快速滑动时）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;3-stable-ids-如何改变-viewholder-获取方式&#34;&gt;&lt;strong&gt;3. Stable IDs 如何改变 ViewHolder 获取方式&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;p&gt;当启用 &lt;strong&gt;Stable IDs&lt;/strong&gt;（通过 &lt;code&gt;setHasStableIds(true)&lt;/code&gt; + 重写 &lt;code&gt;getItemId()&lt;/code&gt;）时：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Hugo Vercel博客配置</title>
      <link>http://localhost:1313/tutorials/hugo-vercel%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Wed, 11 Jun 2025 12:20:50 +0800</pubDate>
      <guid>http://localhost:1313/tutorials/hugo-vercel%E5%8D%9A%E5%AE%A2%E9%85%8D%E7%BD%AE/</guid>
      <description>&lt;h4 id=&#34;前期准备&#34;&gt;前期准备&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;安装 Hugo&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# macOS (Homebrew)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;brew install hugo&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;注册Vercel账号&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;创建本地博客&#34;&gt;创建本地博客&lt;/h4&gt;&#xA;&lt;h5 id=&#34;11-生成新站点&#34;&gt;1.1 生成新站点&lt;/h5&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;hugo new site myblog&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cd myblog&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;12-添加主题&#34;&gt;1.2 添加主题&lt;/h5&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;theme = &amp;#39;ananke&amp;#39;&amp;#34;&lt;/span&gt; &amp;gt;&amp;gt; config.toml  &lt;span style=&#34;color:#75715e&#34;&gt;# 配置主题&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;自定义域名&#34;&gt;自定义域名&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在Vercel控制控制台 -&amp;gt; &lt;strong&gt;Settings&lt;/strong&gt; -&amp;gt; &lt;strong&gt;Domains&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;li&gt;输入自己的域名(&lt;code&gt;dust-zed.site&lt;/code&gt;,可在阿里云购买)&lt;/li&gt;&#xA;&lt;li&gt;按提示配置DNS解析&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;管理不同类型的文章&#34;&gt;管理不同类型的文章&lt;/h4&gt;&#xA;&lt;h5 id=&#34;31-使用物理目录分类&#34;&gt;3.1 使用物理目录分类&lt;/h5&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;content/&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── blog/           &lt;span style=&#34;color:#75715e&#34;&gt;# 常规博客&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── tutorials/      &lt;span style=&#34;color:#75715e&#34;&gt;# 教程类&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── reviews/        &lt;span style=&#34;color:#75715e&#34;&gt;# 产品评测&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;└── notes/          &lt;span style=&#34;color:#75715e&#34;&gt;# 学习笔记&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;32-创建对应类型文章&#34;&gt;3.2 创建对应类型文章&lt;/h5&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;hugo new tutorials/hugo-vercel博客配置.md&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;33-统一配置文件&#34;&gt;3.3 统一配置文件&lt;/h5&gt;&#xA;&lt;p&gt;在&lt;code&gt;config.toml&lt;/code&gt;中集中管理URL规则&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 所有文章默认路径&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# :slug动态代表内容的URL友好版本标题&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;permalinks&lt;/span&gt;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;posts&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/blog/:year/:month/:slug/&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;tutorials&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/learn/:slug/&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;reviews&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;/products/:category/:slug/&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 分类页面路径&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;taxonomies&lt;/span&gt;]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;category&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;categories&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#a6e22e&#34;&gt;tag&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tags&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;34-自动生成分类列表&#34;&gt;3.4 自动生成分类列表&lt;/h5&gt;&#xA;&lt;h4 id=&#34;升级维护&#34;&gt;升级维护&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;更新主题：&lt;code&gt;git submodule update --remote --merge&lt;/code&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
