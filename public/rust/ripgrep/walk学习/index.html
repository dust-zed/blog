<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="核心架构分析 核心功能 并发遍历(crossbeam_deque) 避免重复处理(same_file) 基础遍历能力(walkdir) DirEntry的设计 #[derive(Debug, Clone)] pub struct DirEntry { dent: DirEntryInner,\t//实际的目录条目 err: Option&lt;Error&gt;,\t//附加的错误信息 } 设计亮点： 错误不阻塞 - 即使有错误也保留条目，只是附加错误信息 内部抽象 - DirEntryInner隐藏具体实现细节 DirEntryInner的设计 从代码可以看到一个精巧的多态设计：\nenum DirEntryInner { Stdin,\t//标准输入的特殊处理 WalkDir(walkdir::DirEntry),\t//来自walkdir crate的条目 Raw(DirEntryRaw),\t//自定义的原始条目 } 统一接口模式 每个方法都通过模式匹配提供统一接口：\nfn path(&amp;self) -&gt; &amp;Path { match *self { Stdin =&gt; Path::new(&#34;&lt;stdin&gt;&#34;), Walkdir(ref x) =&gt; x.path(), Raw(ref x) =&gt; x.path(), } } 这种设计的价值：\n类型安全 - 编译时保存所有变体都被处理 性能优化 - 零成本抽象，运行时无虚函数调用开销 扩展性 - 可以轻松添加新的条目类型 DirEntryRaw 根据代码，可以看到一个重要的跨平台优化策略：\n">
<title>Walk学习</title>

<link rel='canonical' href='http://localhost:1313/rust/ripgrep/walk%E5%AD%A6%E4%B9%A0/'>

<link rel="stylesheet" href="/scss/style.min.946cca6c6259ef94ac55abfae7c7bf3291ea3ed5eea17ef77500b257217c6710.css"><meta property='og:title' content="Walk学习">
<meta property='og:description' content="核心架构分析 核心功能 并发遍历(crossbeam_deque) 避免重复处理(same_file) 基础遍历能力(walkdir) DirEntry的设计 #[derive(Debug, Clone)] pub struct DirEntry { dent: DirEntryInner,\t//实际的目录条目 err: Option&lt;Error&gt;,\t//附加的错误信息 } 设计亮点： 错误不阻塞 - 即使有错误也保留条目，只是附加错误信息 内部抽象 - DirEntryInner隐藏具体实现细节 DirEntryInner的设计 从代码可以看到一个精巧的多态设计：\nenum DirEntryInner { Stdin,\t//标准输入的特殊处理 WalkDir(walkdir::DirEntry),\t//来自walkdir crate的条目 Raw(DirEntryRaw),\t//自定义的原始条目 } 统一接口模式 每个方法都通过模式匹配提供统一接口：\nfn path(&amp;self) -&gt; &amp;Path { match *self { Stdin =&gt; Path::new(&#34;&lt;stdin&gt;&#34;), Walkdir(ref x) =&gt; x.path(), Raw(ref x) =&gt; x.path(), } } 这种设计的价值：\n类型安全 - 编译时保存所有变体都被处理 性能优化 - 零成本抽象，运行时无虚函数调用开销 扩展性 - 可以轻松添加新的条目类型 DirEntryRaw 根据代码，可以看到一个重要的跨平台优化策略：\n">
<meta property='og:url' content='http://localhost:1313/rust/ripgrep/walk%E5%AD%A6%E4%B9%A0/'>
<meta property='og:site_name' content='zed的博客'>
<meta property='og:type' content='article'><meta property='article:section' content='Rust' /><meta property='article:published_time' content='2025-08-26T15:01:45&#43;08:00'/><meta property='article:modified_time' content='2025-08-26T15:01:45&#43;08:00'/>
<meta name="twitter:title" content="Walk学习">
<meta name="twitter:description" content="核心架构分析 核心功能 并发遍历(crossbeam_deque) 避免重复处理(same_file) 基础遍历能力(walkdir) DirEntry的设计 #[derive(Debug, Clone)] pub struct DirEntry { dent: DirEntryInner,\t//实际的目录条目 err: Option&lt;Error&gt;,\t//附加的错误信息 } 设计亮点： 错误不阻塞 - 即使有错误也保留条目，只是附加错误信息 内部抽象 - DirEntryInner隐藏具体实现细节 DirEntryInner的设计 从代码可以看到一个精巧的多态设计：\nenum DirEntryInner { Stdin,\t//标准输入的特殊处理 WalkDir(walkdir::DirEntry),\t//来自walkdir crate的条目 Raw(DirEntryRaw),\t//自定义的原始条目 } 统一接口模式 每个方法都通过模式匹配提供统一接口：\nfn path(&amp;self) -&gt; &amp;Path { match *self { Stdin =&gt; Path::new(&#34;&lt;stdin&gt;&#34;), Walkdir(ref x) =&gt; x.path(), Raw(ref x) =&gt; x.path(), } } 这种设计的价值：\n类型安全 - 编译时保存所有变体都被处理 性能优化 - 零成本抽象，运行时无虚函数调用开销 扩展性 - 可以轻松添加新的条目类型 DirEntryRaw 根据代码，可以看到一个重要的跨平台优化策略：\n">
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column compact"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu_f509edb42ecc0ebd.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">zed的博客</a></h1>
            <h2 class="site-description"></h2>
        </div>
    </header><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/rust' >
                
                
                
                <span>rust</span>
            </a>
        </li>
        
        
        <li >
            <a href='/android-develop/' >
                
                
                
                <span>Android-Develops</span>
            </a>
        </li>
        
        
        <li >
            <a href='/learning-reflection/' >
                
                
                
                <span>Learning-Reflections</span>
            </a>
        </li>
        
        
        <li >
            <a href='/tutorials/' >
                
                
                
                <span>Tutorials</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    

            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/rust/" >
                Rust
            </a>
        
            <a href="/categories/ripgrep/" >
                Ripgrep
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/rust/ripgrep/walk%E5%AD%A6%E4%B9%A0/">Walk学习</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Aug 26, 2025</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 3 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h3 id="核心架构分析">核心架构分析
</h3><h4 id="核心功能">核心功能
</h4><ul>
<li>并发遍历(<code>crossbeam_deque</code>)</li>
<li>避免重复处理(<code>same_file</code>)</li>
<li>基础遍历能力(<code>walkdir</code>)</li>
</ul>
<h4 id="direntry的设计">DirEntry的设计
</h4><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[derive(Debug, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">DirEntry</span> {
</span></span><span style="display:flex;"><span>  dent: <span style="color:#a6e22e">DirEntryInner</span>,		<span style="color:#75715e">//实际的目录条目
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  err: Option<span style="color:#f92672">&lt;</span>Error<span style="color:#f92672">&gt;</span>,			<span style="color:#75715e">//附加的错误信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h5 id="设计亮点">设计亮点：
</h5><ul>
<li>错误不阻塞 - 即使有错误也保留条目，只是附加错误信息</li>
<li>内部抽象 - <code>DirEntryInner</code>隐藏具体实现细节</li>
</ul>
<h4 id="direntryinner的设计">DirEntryInner的设计
</h4><p>从代码可以看到一个精巧的多态设计：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">DirEntryInner</span> {
</span></span><span style="display:flex;"><span>  Stdin,												<span style="color:#75715e">//标准输入的特殊处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  WalkDir(walkdir::DirEntry),		<span style="color:#75715e">//来自walkdir crate的条目
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  Raw(DirEntryRaw),							<span style="color:#75715e">//自定义的原始条目
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h5 id="统一接口模式">统一接口模式
</h5><p>每个方法都通过模式匹配提供统一接口：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">path</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Path</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">match</span> <span style="color:#f92672">*</span>self {
</span></span><span style="display:flex;"><span>    Stdin <span style="color:#f92672">=&gt;</span> Path::new(<span style="color:#e6db74">&#34;&lt;stdin&gt;&#34;</span>),
</span></span><span style="display:flex;"><span>    Walkdir(<span style="color:#66d9ef">ref</span> x) <span style="color:#f92672">=&gt;</span> x.path(),
</span></span><span style="display:flex;"><span>    Raw(<span style="color:#66d9ef">ref</span> x) <span style="color:#f92672">=&gt;</span> x.path(),
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这种设计的价值：</p>
<ol>
<li><strong>类型安全</strong> - 编译时保存所有变体都被处理</li>
<li><strong>性能优化</strong> - 零成本抽象，运行时无虚函数调用开销</li>
<li><strong>扩展性</strong> - 可以轻松添加新的条目类型</li>
</ol>
<h4 id="direntryraw">DirEntryRaw
</h4><p>根据代码，可以看到一个重要的跨平台优化策略：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">DirEntryRaw</span> {
</span></span><span style="display:flex;"><span>  path: <span style="color:#a6e22e">PathBuf</span>,
</span></span><span style="display:flex;"><span>  ty: <span style="color:#a6e22e">fileType</span>,
</span></span><span style="display:flex;"><span>  follow_link: <span style="color:#66d9ef">bool</span>,
</span></span><span style="display:flex;"><span>  depth: <span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//平台特化字段
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">#[cfg(unix)]</span>
</span></span><span style="display:flex;"><span>  ino: <span style="color:#66d9ef">u64</span>,       <span style="color:#75715e">//Unix: 存储inode号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">#[cfg(windows)]</span>
</span></span><span style="display:flex;"><span>  metadata: <span style="color:#a6e22e">fs</span>::Metadata,		<span style="color:#75715e">//Windows:存储完整元数据
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h5 id="平台优化的设计思路">平台优化的设计思路
</h5><p><strong>Unix系统</strong>：</p>
<ul>
<li>只存储<code>inode</code>号，因为Unix文件系统操作相对便宜</li>
<li>需要时再通过系统调用获取完整元数据</li>
</ul>
<p><strong>Windows系统</strong></p>
<ul>
<li>预先存储完整的<code>metadata</code>，因为Windows文件系统调用开销比较大</li>
<li>在目录读取时就获取元数据，避免后续重复调用</li>
</ul>
<h5 id="符号链接处理逻辑">符号链接处理逻辑
</h5><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">path_is_symlink</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>  self.ty.is_symlink() <span style="color:#f92672">||</span> self.follow_link
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里有两种情况认为是符号链接：</p>
<ol>
<li>真正的符号链接(<code>self.ty.is_symlink()</code>)</li>
<li>跟随链接的条目(<code>self.follow_link</code>)</li>
</ol>
<h4 id="walkparallel的并发遍历机制">WalkParallel的并发遍历机制
</h4><p>从代码可以看到<code>WalkParallel</code>的核心设计：</p>
<h5 id="回调模式而非迭代器">回调模式而非迭代器
</h5><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">run</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;s</span>, F<span style="color:#f92672">&gt;</span>(self, mkf: <span style="color:#a6e22e">F</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">where</span>
</span></span><span style="display:flex;"><span>	F: FnMut() -&gt; <span style="color:#a6e22e">FnVisitor</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;s</span><span style="color:#f92672">&gt;</span>,  <span style="color:#75715e">//为每个线程创建一个访问器 {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	self.visit(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> FnBuilder {builder: <span style="color:#a6e22e">mkf</span>})
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>设计原因</strong></p>
<ul>
<li>并行迭代器难以实现<code>Iterator</code>trait</li>
<li>回调模式更适合工作窃取算法</li>
<li>每个线程有独立的访问器，避免同步开销</li>
</ul>
<h5 id="线程池和工作分发">线程池和工作分发
</h5><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">visit</span>(<span style="color:#66d9ef">mut</span> self, builder: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> <span style="color:#66d9ef">dyn</span> ParallelVisitorBuilder<span style="color:#f92672">&lt;</span>&#39;_<span style="color:#f92672">&gt;</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> threads <span style="color:#f92672">=</span> self.threads();
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> stack <span style="color:#f92672">=</span> <span style="color:#a6e22e">vec!</span>[];
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//为每个根路径创建初始工作项
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span> path <span style="color:#66d9ef">in</span> paths {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> (dent, root_device) <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> path <span style="color:#f92672">==</span> Path::new(<span style="color:#e6db74">&#34;-&#34;</span>) {
</span></span><span style="display:flex;"><span>      (DirEntry::new_stdin(), None)
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">//处理文件系统边界检查
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">let</span> root_device <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>self.same_file_system {
</span></span><span style="display:flex;"><span>        None
</span></span><span style="display:flex;"><span>      } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> device_num(<span style="color:#f92672">&amp;</span>path)
</span></span><span style="display:flex;"><span>      };
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="文件系统边界处理">文件系统边界处理
</h5><p>注意<code>same_file_system</code>的处理：</p>
<ul>
<li>获取根路径的设备号(<code>device_num</code>)</li>
<li>遍历时检查是否跨越文件系统边界</li>
<li>这是Unix系统中的重要优化</li>
</ul>
<h4 id="工作窃取并发机制">工作窃取并发机制
</h4><p>从代码可以看到一个精巧的并发遍历实现：</p>
<h5 id="工作窃取队列的设计">工作窃取队列的设计
</h5><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// 为每个线程创建一个 LIFO 队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> deques: Vec<span style="color:#f92672">&lt;</span>Deque<span style="color:#f92672">&lt;</span>Message<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>    std::iter::repeat_with(Deque::new_lifo).take(threads).collect();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 创建窃取器，让所有线程都能从其他队列窃取工作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> stealers <span style="color:#f92672">=</span> Arc::<span style="color:#f92672">&lt;</span>[Stealer<span style="color:#f92672">&lt;</span>Message<span style="color:#f92672">&gt;</span>]<span style="color:#f92672">&gt;</span>::from(
</span></span><span style="display:flex;"><span>    deques.iter().map(Deque::stealer).collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;</span>(),
</span></span><span style="display:flex;"><span>);
</span></span></code></pre></div><p><strong>LIFO队列的选择：</strong></p>
<ul>
<li>深度优先遍历，减少内存占用</li>
<li>保持gitignore匹配器数量较低</li>
<li>对于宽目录树的性能优化</li>
</ul>
<h5 id="stack的窃取策略">Stack的窃取策略
</h5><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">steal</span>(<span style="color:#f92672">&amp;</span>self) -&gt; Option<span style="color:#f92672">&lt;</span>Message<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 公平性：从 index + 1 开始窃取，然后环绕
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> (left, right) <span style="color:#f92672">=</span> self.stealers.split_at(self.index);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> right <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>right[<span style="color:#ae81ff">1</span><span style="color:#f92672">..</span>];  <span style="color:#75715e">// 不从自己窃取
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    right.iter().chain(left.iter())
</span></span><span style="display:flex;"><span>        .map(<span style="color:#f92672">|</span>s<span style="color:#f92672">|</span> s.steal_batch_and_pop(<span style="color:#f92672">&amp;</span>self.deque))
</span></span><span style="display:flex;"><span>        .find_map(<span style="color:#f92672">|</span>s<span style="color:#f92672">|</span> s.success())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>窃取算法特点：</strong></p>
<ul>
<li><strong>公平性</strong> - 轮询其他线程的队列</li>
<li><strong>批量窃取</strong> - <code>steal_batch_and_pop</code>一次窃取多个任务</li>
<li><strong>避免自窃取</strong> - 跳过自己的队列</li>
</ul>
<h5 id="worker的职责分离">Worker的职责分离
</h5><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Worker</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;s</span><span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>  visitor: Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> ParallelVisitor <span style="color:#f92672">+</span> <span style="color:#a6e22e">&#39;s</span><span style="color:#f92672">&gt;</span>,  <span style="color:#75715e">//用户回调
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  stack: <span style="color:#a6e22e">Stack</span>,														<span style="color:#75715e">//工作队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  quit_now: <span style="color:#a6e22e">Arc</span><span style="color:#f92672">&lt;</span>AtomicBool<span style="color:#f92672">&gt;</span>,								<span style="color:#75715e">//全局退出信号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  active_workers: <span style="color:#a6e22e">Arc</span><span style="color:#f92672">&lt;</span>AtomicUsize<span style="color:#f92672">&gt;</span>,					<span style="color:#75715e">//活跃工作线程
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">//...遍历配置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p><strong>设计亮点</strong></p>
<ul>
<li><strong>生产者 + 消费者</strong> - 既处理工作又产生新工作</li>
<li><strong>深度优先</strong> - 使用栈而非队列，优化内存使用</li>
<li><strong>协作式退出</strong> - 通过原子变量协调线程退出</li>
</ul>
<h5 id="worker并发执行机制">Worker并发执行机制
</h5><p><strong>核心工作流程</strong></p>
<ol>
<li><code>Worker::run()</code> - 主循环，持续获取和处理工作</li>
<li><code>Worker::run_one()</code> - 处理单个工作项，包括目录遍历和文件访问</li>
<li><code>Worker::generate_work()</code> - 为子目录生成新的工作项</li>
</ol>
<p><strong>工作窃取队列机制</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get_work</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; Option<span style="color:#f92672">&lt;</span>Work<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> value <span style="color:#f92672">=</span> self.recv();  <span style="color:#75715e">// 从本地队列获取
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> self.is_quit_now() {
</span></span><span style="display:flex;"><span>            value <span style="color:#f92672">=</span> Some(Message::Quit)  <span style="color:#75715e">// 优先处理退出信号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">match</span> value {
</span></span><span style="display:flex;"><span>            Some(Message::Work(work)) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Some(work),
</span></span><span style="display:flex;"><span>            Some(Message::Quit) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                self.send_quit();  <span style="color:#75715e">// 传播退出信号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> None;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            None <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 关键：工作者去激活机制
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> self.deactivate_worker() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 所有工作者都空闲 = 没有更多工作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    self.send_quit();
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">return</span> None;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 等待新工作或窃取其他队列的工作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(v) <span style="color:#f92672">=</span> self.recv() {
</span></span><span style="display:flex;"><span>                        self.activate_worker();
</span></span><span style="display:flex;"><span>                        value <span style="color:#f92672">=</span> Some(v);
</span></span><span style="display:flex;"><span>                        <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                    std::thread::sleep(Duration::from_millis(<span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="智能终止检测">智能终止检测
</h5><ul>
<li><strong>原子计数器</strong><code>active_workers</code>跟踪活跃工作者数量</li>
<li><strong>非激活机制</strong>：当工作者队列为空时，原子性地减少活跃计数</li>
<li><strong>全局终止检测</strong>：当所有工作者都非激活时，说明没有更多的工作</li>
<li><strong>退出信号传播</strong>：使用多米诺效应唤醒所有休眠线程</li>
</ul>
<h5 id="过滤和处理逻辑">过滤和处理逻辑
</h5><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">generate_work</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, ig: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Ignore</span>, depth: <span style="color:#66d9ef">usize</span>, root_device: Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u64</span><span style="color:#f92672">&gt;</span>, result: Result<span style="color:#f92672">&lt;</span>fs::DirEntry, io::Error<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">WalkState</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 1. 错误处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> fs_dent <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> result { <span style="color:#f92672">..</span>. };
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 2. 符号链接处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> self.follow_links <span style="color:#f92672">&amp;&amp;</span> is_symlink {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 检查循环引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Err(err) <span style="color:#f92672">=</span> check_symlink_loop(ig, dent.path(), depth) { <span style="color:#f92672">..</span>. }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 3. 多层过滤
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> should_skip_entry(ig, <span style="color:#f92672">&amp;</span>dent) { <span style="color:#66d9ef">return</span> WalkState::Continue; }  <span style="color:#75715e">// ignore 规则
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> is_stdout { <span style="color:#66d9ef">return</span> WalkState::Continue; }                     <span style="color:#75715e">// stdout 检查
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> should_skip_filesize { <span style="color:#f92672">..</span>. }                                  <span style="color:#75715e">// 文件大小过滤
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> should_skip_filtered { <span style="color:#f92672">..</span>. }                                  <span style="color:#75715e">// 自定义过滤器
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 4. 生成新工作项
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    self.send(Work { dent, ignore: <span style="color:#a6e22e">ig</span>.clone(), root_device });
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="关键设计模式">关键设计模式
</h5><ol>
<li><strong>生产者-消费者模式</strong>
<ul>
<li>每个Worker既是生产者又是消费者</li>
<li>使用LIFO队列保持深度优先遍历的局部性</li>
</ul>
</li>
<li><strong>优雅终止模式</strong>
<ul>
<li>优先级消息：退出信号优先于工作消息</li>
<li>传播机制：一个线程退出会触发所有线程退出</li>
<li>原子状态管理： 使用<code>AtomicBool</code>和<code>AtomicUsize</code>进行线程安全的状态协调</li>
</ul>
</li>
<li><strong>错误恢复策略</strong>
<ul>
<li>单个文件/目录错误不会终止整个遍历</li>
<li>错误通过visitor回调传递给上层处理</li>
<li>符号链接循环检测防止无限递归</li>
</ul>
</li>
</ol>
<p>这个实现展示了 Rust 在系统编程中的强大能力：<strong>零成本抽象</strong>、<strong>内存安全的并发</strong>、<strong>优雅的错误处理</strong>。特别是工作窃取队列和智能终止检测的结合，实现了高效且正确的并行目录遍历。</p>

</section>


    <footer class="article-footer">
    

    </footer>


    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2025 zed的博客
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.30.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.0640c0f9745d7bd65b558574cdb67852b46437c1f807526bf043aebc566fd6e4.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
