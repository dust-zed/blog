<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>tokio on zed的博客</title>
        <link>https://www.dust-zed.site/rust/tokio/</link>
        <description>Recent content in tokio on zed的博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Fri, 05 Sep 2025 18:51:54 +0800</lastBuildDate><atom:link href="https://www.dust-zed.site/rust/tokio/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Waker和Context机制</title>
        <link>https://www.dust-zed.site/rust/tokio/waker%E5%92%8Ccontext%E6%9C%BA%E5%88%B6/</link>
        <pubDate>Fri, 05 Sep 2025 18:51:54 +0800</pubDate>
        
        <guid>https://www.dust-zed.site/rust/tokio/waker%E5%92%8Ccontext%E6%9C%BA%E5%88%B6/</guid>
        <description>&lt;h4 id=&#34;基本概念&#34;&gt;基本概念
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Context&lt;/strong&gt;：提供异步任务执行的上下文信息，最重要的是包含Waker&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Waker&lt;/strong&gt;：用于唤醒被挂起的异步任务的机制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Poll&lt;/strong&gt;：Future的轮询状态, &lt;code&gt;Ready&lt;/code&gt;或&lt;code&gt;Pending&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;context的定义&#34;&gt;Context的定义
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Context&lt;/code&gt; 是Rust标准库中&lt;code&gt;std::task&lt;/code&gt;模块提供的结构体，它主要包含：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对&lt;code&gt;Waker&lt;/code&gt;的引用&lt;/li&gt;
&lt;li&gt;可选的任务本地存储&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在Tokio中，&lt;code&gt;Context&lt;/code&gt;主要用于：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Future &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; MyFuture {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Output&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;poll&lt;/span&gt;(self: &lt;span style=&#34;color:#a6e22e&#34;&gt;Pin&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; Self&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, cx: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Context&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&amp;#39;_&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Poll&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Self::Output&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 使用 cx.waker() 获取 Waker
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 当 I/O 未就绪时，保存 Waker 以便后续唤醒
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;waker的核心实现&#34;&gt;Waker的核心实现
&lt;/h4&gt;&lt;p&gt;在Tokio中，&lt;code&gt;Waker&lt;/code&gt;是异步任务通知机制的核心。先看看Tokio中的关键实现&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;super&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;WakerRef&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;&amp;#39;a&lt;/span&gt;, S: &amp;#39;static&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  waker: &lt;span style=&#34;color:#a6e22e&#34;&gt;ManuallyDrop&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Waker&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  _p: &lt;span style=&#34;color:#a6e22e&#34;&gt;PhantomData&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;&amp;#39;a&lt;/span&gt; Header, S)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;waker的创建&#34;&gt;Waker的创建
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;raw_waker&lt;/span&gt;(header: &lt;span style=&#34;color:#a6e22e&#34;&gt;NonNull&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Header&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;RawWaker&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; ptr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; header.as_ptr() &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  RawWaker::new(ptr, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WAKER_VTABLE&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;waker的vtable&#34;&gt;Waker的VTable
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;WAKER_VTABLE&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;RawWakerVTable&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; RawWakerVTable::new(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    clone_waker,    &lt;span style=&#34;color:#75715e&#34;&gt;// 克隆 Waker
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    wake_by_val,    &lt;span style=&#34;color:#75715e&#34;&gt;// 消费 Waker 并唤醒任务
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    wake_by_ref,    &lt;span style=&#34;color:#75715e&#34;&gt;// 不消费 Waker 的情况下唤醒任务
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    drop_waker,     &lt;span style=&#34;color:#75715e&#34;&gt;// 释放 Waker 资源
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;waker的生命周期&#34;&gt;waker的生命周期
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;创建： 当任务被创建时，会创建一个对应的Waker&lt;/li&gt;
&lt;li&gt;唤醒：当I/O事件就绪或定时器触发&lt;/li&gt;
&lt;li&gt;消费：任务被唤醒后，Waker会被消费掉&lt;/li&gt;
&lt;li&gt;重建：如果需要再次唤醒任务，需要重新创建Waker&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;工作流程示例&#34;&gt;工作流程示例
&lt;/h4&gt;&lt;p&gt;简易的任务唤醒流程：&lt;/p&gt;
&lt;h5 id=&#34;1-任务创建&#34;&gt;1. 任务创建
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; task &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;//异步代码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;tokio::spawn(task);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;2-waker创建&#34;&gt;2. Waker创建
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;Tokio运行时为任务创建Waker&lt;/li&gt;
&lt;li&gt;Waker包含指向任务状态的指针&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;3-io注册&#34;&gt;3. I/O注册
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 当调用类似 TcpStream::read 时
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; ready &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ready!&lt;/span&gt;(self.io.poll_read_ready(cx)&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;4-任务挂起&#34;&gt;4. 任务挂起
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;如果I/O未就绪，保存Waker&lt;/li&gt;
&lt;li&gt;返回&lt;code&gt;Poll::Pending&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;5-事件就绪&#34;&gt;5. 事件就绪
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;I/O事件就绪，保存Waker&lt;/li&gt;
&lt;li&gt;事件循环调用保存的Waker的&lt;code&gt;wake()&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;6-任务恢复&#34;&gt;6. 任务恢复
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;Waker将任务放回就绪队列&lt;/li&gt;
&lt;li&gt;调度器再次轮询该任务&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Pin和Unpin</title>
        <link>https://www.dust-zed.site/rust/tokio/pin%E5%92%8Cunpin/</link>
        <pubDate>Thu, 04 Sep 2025 15:03:11 +0800</pubDate>
        
        <guid>https://www.dust-zed.site/rust/tokio/pin%E5%92%8Cunpin/</guid>
        <description>&lt;h4 id=&#34;pin和unpin的基本概念&#34;&gt;Pin和Unpin的基本概念
&lt;/h4&gt;&lt;h5 id=&#34;pin的作用&#34;&gt;Pin的作用
&lt;/h5&gt;&lt;p&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt;是一个包装器，用于固定(pin)内存中的值，防止它被移动。这对于自引用结构体和异步编程中的Future特别重要。&lt;/p&gt;
&lt;h5 id=&#34;unpin的特质&#34;&gt;Unpin的特质
&lt;/h5&gt;&lt;p&gt;&lt;code&gt;Unpin&lt;/code&gt;是一个自动派生的标记trait，表示类型可以安全地移出&lt;code&gt;Pin&lt;/code&gt;。大多数类型都自动实现了&lt;code&gt;Unpin&lt;/code&gt;。实现了&lt;code&gt;Unpin&lt;/code&gt;的类型可以安全地从&lt;code&gt;Pin&lt;/code&gt;中移出。&lt;/p&gt;
&lt;h4 id=&#34;asyncawait为何需要pin&#34;&gt;async/await为何需要Pin
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;async&lt;/code&gt;块可能包含自引用，&lt;code&gt;async&lt;/code&gt;转变为&lt;code&gt;Future&lt;/code&gt;结构体,它是一个状态机&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;.await&lt;/code&gt;暂停执行时，局部变量会保存在生成的Future中&lt;/li&gt;
&lt;li&gt;如果这些变量相互引用，移动Future会导致悬垂指针&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;生命周期管理层次&#34;&gt;生命周期管理层次
&lt;/h4&gt;&lt;h5 id=&#34;1-变量级别&#34;&gt;1. 变量级别
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;局部变量被移动到Future状态机中&lt;/li&gt;
&lt;li&gt;生命周期与Future实例绑定&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2-future级别&#34;&gt;2. Future级别
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;由执行器拥有和管理&lt;/li&gt;
&lt;li&gt;执行器决定何时poll，何时drop&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;3-执行器级别&#34;&gt;3. 执行器级别
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;管理所有Future的生命周期&lt;/li&gt;
&lt;li&gt;负责调度和管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;4-栈帧与状态机&#34;&gt;4. 栈帧与状态机
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;同步：变量生命周期由栈帧管理&lt;/li&gt;
&lt;li&gt;异步：变量生命周期由状态机管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;任务队列与future&#34;&gt;任务队列与Future
&lt;/h4&gt;&lt;h5 id=&#34;一次性移动&#34;&gt;一次性移动
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;Future被移动到执行器后，由Pin保证不会再次移动&lt;/li&gt;
&lt;li&gt;执行器内部使用指针来引用Future&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;任务队列的实现&#34;&gt;任务队列的实现
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 伪代码：任务队列中的 Future
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Task&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    future: &lt;span style=&#34;color:#a6e22e&#34;&gt;Pin&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;dyn&lt;/span&gt; Future&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Output &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ()&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; Send&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 任务队列存储的是 Box&amp;lt;Task&amp;gt;，而不是直接存储 Future
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; task_queue: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Task&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;.;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;工作窃取调度&#34;&gt;工作窃取调度
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;当任务在线程间转移时，转移的是&lt;code&gt;Box&amp;lt;Task&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Box&lt;/code&gt;的移动不会影响内部Future的内存地址&lt;/li&gt;
&lt;li&gt;Pin 保证的是 &lt;code&gt;Box&lt;/code&gt; 内部的 Future 不会被移出&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Tokio整体结构</title>
        <link>https://www.dust-zed.site/rust/tokio/tokio%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84/</link>
        <pubDate>Wed, 03 Sep 2025 12:28:49 +0800</pubDate>
        
        <guid>https://www.dust-zed.site/rust/tokio/tokio%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84/</guid>
        <description>&lt;h3 id=&#34;tokio架构设计&#34;&gt;Tokio架构设计
&lt;/h3&gt;&lt;p&gt;Tokio是一个基于Rust的一步运行时，其设计非常精妙。&lt;/p&gt;
&lt;h4 id=&#34;1-核心组件&#34;&gt;1. 核心组件
&lt;/h4&gt;&lt;h5 id=&#34;11-reactor反应器&#34;&gt;1.1 Reactor（反应器）
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;I/O多路复用&lt;/strong&gt;：基于操作系统提供的epoll/kqueue/IOCP等机制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件循环&lt;/strong&gt;： 负责监听和分发I/O事件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非阻塞I/O&lt;/strong&gt;：所有I/O操作都是非阻塞的&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;12-scheduler&#34;&gt;1.2 Scheduler
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;工作窃取&lt;/strong&gt;：使用工作窃取算法在多线程间分配任务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多线程执行器&lt;/strong&gt;： 默认使用多线程执行器提高并发性能&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;任务调度&lt;/strong&gt;： 负责任务的调度和执行&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;13-异步任务&#34;&gt;1.3 异步任务
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Future抽象&lt;/strong&gt;：基于Rust的Future trait&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;零成本抽象&lt;/strong&gt;：利用Rust的所有权系统实现零成本抽象&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;任务窃取&lt;/strong&gt;： 任务可以在不同线程间迁移以平衡负载&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-设计哲学&#34;&gt;2. 设计哲学
&lt;/h4&gt;&lt;h5 id=&#34;21-零成本抽象&#34;&gt;2.1 零成本抽象
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;使用Rust的零成本抽象原则&lt;/li&gt;
&lt;li&gt;运行时检查转变为编译时检查&lt;/li&gt;
&lt;li&gt;最小化运行时开销&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;22-模块化设计&#34;&gt;2.2 模块化设计
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;核心组件解耦&lt;/li&gt;
&lt;li&gt;可按需选择功能&lt;/li&gt;
&lt;li&gt;可扩展性强&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;23-性能优先&#34;&gt;2.3 性能优先
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;无锁数据结构&lt;/li&gt;
&lt;li&gt;最小化内存分配&lt;/li&gt;
&lt;li&gt;批处理系统调用&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3-关键实现细节&#34;&gt;3. 关键实现细节
&lt;/h4&gt;&lt;h5 id=&#34;31-任务调度&#34;&gt;3.1 任务调度
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 简化的任务结构
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Task&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 任务状态
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    state: &lt;span style=&#34;color:#a6e22e&#34;&gt;AtomicUsize&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 任务执行体
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    future: &lt;span style=&#34;color:#a6e22e&#34;&gt;Mutex&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Pin&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;dyn&lt;/span&gt; Future&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Output &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ()&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &amp;#39;static&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 任务队列相关
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    next: &lt;span style=&#34;color:#a6e22e&#34;&gt;UnsafeCell&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; Task&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;32-io驱动&#34;&gt;3.2 I/O驱动
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;使用mio库提供跨平台I/O多路复用&lt;/li&gt;
&lt;li&gt;基于readiness模型&lt;/li&gt;
&lt;li&gt;零拷贝支持&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;4-高级特性&#34;&gt;4. 高级特性
&lt;/h4&gt;&lt;h5 id=&#34;41-异步等待&#34;&gt;4.1 异步等待
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 异步函数示例
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;process&lt;/span&gt;(socket: &lt;span style=&#34;color:#a6e22e&#34;&gt;TcpStream&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;io&lt;/span&gt;::Result&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;()&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; buf &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 异步读取
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; socket.read(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; buf).&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 处理数据...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    Ok(())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;42-定时器&#34;&gt;4.2 定时器
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;分层时间轮实现&lt;/li&gt;
&lt;li&gt;高精度定时器&lt;/li&gt;
&lt;li&gt;低开销&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;5-性能优化&#34;&gt;5. 性能优化
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;零成本抽象&lt;/strong&gt;：利用Rust的所有权系统&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无锁编程&lt;/strong&gt;： 减少锁争用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;批处理&lt;/strong&gt;：合并系统调用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存池&lt;/strong&gt;：减少内存分配&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;6-生态系统&#34;&gt;6. 生态系统
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;tokio-util&lt;/strong&gt;：实用工具&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tokio-stream&lt;/strong&gt;：流处理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tokio-tungstenite&lt;/strong&gt;: WebSocket&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tonic&lt;/strong&gt;: gRPC实现&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;7设计取舍&#34;&gt;7.设计取舍
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;复杂性&lt;/strong&gt;：为了性能接收更高的实现复杂度&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;学习曲线&lt;/strong&gt;： 需要理解Rust异步编程模型&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调试难度&lt;/strong&gt;： 异步调试相对困难&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;8最佳实践&#34;&gt;8.最佳实践
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;避免在异步代码中执行阻塞操作&lt;/li&gt;
&lt;li&gt;合理使用&lt;code&gt;spawn_blocking&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;注意任务取消和清理&lt;/li&gt;
&lt;li&gt;合理设置工作线程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Tokio 的设计体现了 Rust 语言的核心理念：零成本抽象、内存安全和并发安全。它的架构设计使其成为构建高性能、可靠网络应用的理想选择。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;异步概念&#34;&gt;异步概念
&lt;/h4&gt;&lt;h5 id=&#34;future-trait基础&#34;&gt;Future Trait基础
&lt;/h5&gt;&lt;p&gt;&lt;code&gt;Future&lt;/code&gt;是Rust异步编程的核心trait，定义在标准库&lt;code&gt;std::future&lt;/code&gt;中：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;trait&lt;/span&gt; Future {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Output&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;poll&lt;/span&gt;(self: &lt;span style=&#34;color:#a6e22e&#34;&gt;Pin&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; Self&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, cx: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Context&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&amp;#39;_&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Poll&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Self::Output&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h6 id=&#34;关键点&#34;&gt;关键点
&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Output&lt;/code&gt;：Future完成时产生的值类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;poll&lt;/code&gt;：检查Future是否完成
&lt;ul&gt;
&lt;li&gt;返回&lt;code&gt;Poll::Ready(Output)&lt;/code&gt;：完成并返回结果&lt;/li&gt;
&lt;li&gt;返回&lt;code&gt;Poll::Pending&lt;/code&gt;：未完成，稍后需要再次轮询&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;asyncawait语法糖&#34;&gt;Async/Await语法糖
&lt;/h5&gt;&lt;p&gt;&lt;code&gt;async/await&lt;/code&gt;是Rust提供的语法糖，让异步代码看起来像同步代码：&lt;/p&gt;
&lt;h6 id=&#34;1-基本用法&#34;&gt;1. 基本用法
&lt;/h6&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fetch_data&lt;/span&gt;() -&amp;gt; Result&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String, io::Error&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;//异步操作
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; read_from_network().&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Ok(data)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h6 id=&#34;2-展开形式&#34;&gt;2. 展开形式
&lt;/h6&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;FetchDataFuture&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    state: &lt;span style=&#34;color:#a6e22e&#34;&gt;State&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;State&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Start,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    AwaitingRead(ReadFuture),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Done,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Future &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; FetchDataFuture {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Output&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Result&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String, io::Error&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;poll&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; self: &lt;span style=&#34;color:#a6e22e&#34;&gt;Pin&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; Self&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, cx: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Context&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&amp;#39;_&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Poll&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Self::Output&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;loop&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt; self.state {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                State::Start &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; read_fut &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; read_from_network();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    self.state &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; State::AwaitingRead(read_fut);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                State::AwaitingRead(&lt;span style=&#34;color:#66d9ef&#34;&gt;ref&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; fut) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt; Pin::new(fut).poll(cx) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        Poll::Ready(Ok(data)) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Poll::Ready(Ok(data));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        Poll::Ready(Err(e)) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Poll::Ready(Err(e));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        Poll::Pending &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Poll::Pending;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                State::Done &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;panic!&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;poll called after completion&amp;#34;&lt;/span&gt;),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;关键概念&#34;&gt;关键概念
&lt;/h4&gt;&lt;h6 id=&#34;1-零成本抽象&#34;&gt;1. 零成本抽象
&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;异步代码在编译时转换为状态机&lt;/li&gt;
&lt;li&gt;没有运行时开销，与手写的回调代码性能相当&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;2-执行器executor&#34;&gt;2. 执行器(Executor)
&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;负责调度和执行Future&lt;/li&gt;
&lt;li&gt;Tokio提供了高性能的执行器实现&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;3-waker机制&#34;&gt;3. Waker机制
&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;当Future返回&lt;code&gt;Poll::Pending&lt;/code&gt;时，会注册一个Waker&lt;/li&gt;
&lt;li&gt;当Future可以继续执行时，通过Waker通知执行器&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&#34;4-task与future&#34;&gt;4. Task与Future
&lt;/h6&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Task&lt;/code&gt;是执行单元，是Tokio调度的基本单位，负责执行一个顶层的Future到完成&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Future&lt;/code&gt;是计算单元，代表一个异步计算，一个Task可以包含多个嵌套的Future，这些嵌套的Future共享同一个Task的执行上下文。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
