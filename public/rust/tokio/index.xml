<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>tokio on zed的博客</title><link>https://www.dust-zed.site/rust/tokio/</link><description>Recent content in tokio on zed的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 19 Sep 2025 13:50:29 +0800</lastBuildDate><atom:link href="https://www.dust-zed.site/rust/tokio/index.xml" rel="self" type="application/rss+xml"/><item><title>Tokio核心模型解析</title><link>https://www.dust-zed.site/rust/tokio/tokio%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%90/</link><pubDate>Fri, 19 Sep 2025 13:50:29 +0800</pubDate><guid>https://www.dust-zed.site/rust/tokio/tokio%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9E%8B%E8%A7%A3%E6%9E%90/</guid><description>&lt;h1 id="tokio-核心模型解析">Tokio 核心模型解析
&lt;/h1>&lt;p>让我们从顶层设计开始，逐步深入 Tokio 的异步运行时模型。&lt;/p>
&lt;h2 id="1-核心抽象模型">1. 核心抽象模型
&lt;/h2>&lt;pre tabindex="0">&lt;code>+-------------------------------------------------+
| Runtime (运行时) |
| +-------------------------------------------+ |
| | Reactor (反应器) | |
| | - I/O 多路复用 (epoll/kqueue/IOCP) | |
| | - 处理 I/O 事件通知 | |
| +-------------------------------------------+ |
| |
| +-------------------------------------------+ |
| | Scheduler (调度器) | |
| | - 多线程工作窃取调度 | |
| | - 任务队列管理 | |
| +-------------------------------------------+ |
| |
| +-------------------------------------------+ |
| | Timer (定时器) | |
| | - 管理定时任务 | |
| | - 基于时间轮的定时器实现 | |
| +-------------------------------------------+ |
+-------------------------------------------------+
&lt;/code>&lt;/pre>&lt;h2 id="2-任务生命周期模型">2. 任务生命周期模型
&lt;/h2>&lt;h3 id="21-任务状态机">2.1 任务状态机
&lt;/h3>&lt;pre tabindex="0">&lt;code class="language-mermaid" data-lang="mermaid">stateDiagram-v2
[*] --&amp;gt; Created: 创建
Created --&amp;gt; Scheduled: 调度
Scheduled --&amp;gt; Running: 执行
Running --&amp;gt; Pending: 等待I/O
Pending --&amp;gt; Scheduled: I/O就绪
Running --&amp;gt; Complete: 完成
Running --&amp;gt; Panicked: 恐慌
Running --&amp;gt; Cancelled: 取消
Pending --&amp;gt; Cancelled: 取消
Panicked --&amp;gt; [*]
Complete --&amp;gt; [*]
Cancelled --&amp;gt; [*]
&lt;/code>&lt;/pre>&lt;h3 id="22-状态位表示">2.2 状态位表示
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 状态位域
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">RUNNING&lt;/span>: &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0b0001&lt;/span>; &lt;span style="color:#75715e">// 任务正在执行
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">COMPLETE&lt;/span>: &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0b0010&lt;/span>; &lt;span style="color:#75715e">// 任务已完成
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">NOTIFIED&lt;/span>: &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0b0100&lt;/span>; &lt;span style="color:#75715e">// 任务已通知调度器
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">JOIN_INTEREST&lt;/span>: &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0b1000&lt;/span>; &lt;span style="color:#75715e">// 有任务在等待Join
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">JOIN_WAKER&lt;/span>: &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0b1_0000&lt;/span>; &lt;span style="color:#75715e">// 已设置Join Waker
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">CANCELLED&lt;/span>: &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0b10_0000&lt;/span>; &lt;span style="color:#75715e">// 任务已取消
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="3-核心数据结构">3. 核心数据结构
&lt;/h2>&lt;h3 id="31-任务结构-rawtask">3.1 任务结构 (RawTask)
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">RawTask&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> header: &lt;span style="color:#a6e22e">Header&lt;/span>, &lt;span style="color:#75715e">// 任务头信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> scheduler: &lt;span style="color:#a6e22e">Scheduler&lt;/span>, &lt;span style="color:#75715e">// 调度器
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> state: &lt;span style="color:#a6e22e">State&lt;/span>, &lt;span style="color:#75715e">// 任务状态
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> future: &lt;span style="color:#a6e22e">Future&lt;/span>, &lt;span style="color:#75715e">// 要执行的Future
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> output: Option&lt;span style="color:#f92672">&amp;lt;&lt;/span>Output&lt;span style="color:#f92672">&amp;gt;&lt;/span>, &lt;span style="color:#75715e">// Future的输出
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="32-调度器模型">3.2 调度器模型
&lt;/h3>&lt;pre tabindex="0">&lt;code>+----------------+ +----------------+ +----------------+
| Local Queue | &amp;lt;-&amp;gt; | Global Queue | &amp;lt;-&amp;gt; | Worker Threads |
+----------------+ +----------------+ +----------------+
^ ^ ^
| | |
v v v
+----------------+ +----------------+ +----------------+
| Task Producer | | Work Stealing | | Task Consumer |
| (spawn) | | (负载均衡) | | (poll) |
+----------------+ +----------------+ +----------------+
&lt;/code>&lt;/pre>&lt;h2 id="4-执行流程">4. 执行流程
&lt;/h2>&lt;h3 id="41-任务创建与调度">4.1 任务创建与调度
&lt;/h3>&lt;pre tabindex="0">&lt;code class="language-mermaid" data-lang="mermaid">sequenceDiagram
participant A as 用户代码
participant B as Runtime
participant C as 调度器
participant D as 工作线程
A-&amp;gt;&amp;gt;B: spawn(future)
B-&amp;gt;&amp;gt;C: 创建任务并加入队列
C-&amp;gt;&amp;gt;D: 工作线程窃取任务
D-&amp;gt;&amp;gt;D: 执行future.poll()
alt Future返回Pending
D-&amp;gt;&amp;gt;B: 注册Waker
else Future返回Ready
D-&amp;gt;&amp;gt;B: 设置输出结果
end
&lt;/code>&lt;/pre>&lt;h3 id="42-io-就绪处理">4.2 I/O 就绪处理
&lt;/h3>&lt;pre tabindex="0">&lt;code class="language-mermaid" data-lang="mermaid">sequenceDiagram
participant A as Reactor
participant B as 调度器
participant C as 任务
A-&amp;gt;&amp;gt;B: I/O 就绪事件
B-&amp;gt;&amp;gt;C: 唤醒关联的Waker
C-&amp;gt;&amp;gt;B: 将任务加入就绪队列
B-&amp;gt;&amp;gt;C: 调度执行
&lt;/code>&lt;/pre>&lt;h2 id="5-关键优化技术">5. 关键优化技术
&lt;/h2>&lt;h3 id="51-无锁队列">5.1 无锁队列
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 使用crossbeam的无锁队列
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">TaskQueue&lt;/span> &lt;span style="color:#f92672">=&lt;/span> crossbeam_deque::Worker&lt;span style="color:#f92672">&amp;lt;&lt;/span>Arc&lt;span style="color:#f92672">&amp;lt;&lt;/span>Task&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="52-工作窃取">5.2 工作窃取
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 工作线程尝试从其他队列窃取任务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">steal_work&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>self) -&amp;gt; Option&lt;span style="color:#f92672">&amp;lt;&lt;/span>Task&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 随机选择受害者队列
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> len &lt;span style="color:#f92672">=&lt;/span> self.workers.len();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> start &lt;span style="color:#f92672">=&lt;/span> self.rng.&lt;span style="color:#66d9ef">usize&lt;/span>(&lt;span style="color:#f92672">..&lt;/span>len);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#66d9ef">in&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">..&lt;/span>len {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> idx &lt;span style="color:#f92672">=&lt;/span> (start &lt;span style="color:#f92672">+&lt;/span> i) &lt;span style="color:#f92672">%&lt;/span> len;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> Some(task) &lt;span style="color:#f92672">=&lt;/span> self.workers[idx].steal() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Some(task);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> None
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="53-零成本抽象">5.3 零成本抽象
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 使用泛型和编译期多态
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">spawn&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>F, T&lt;span style="color:#f92672">&amp;gt;&lt;/span>(future: &lt;span style="color:#a6e22e">F&lt;/span>) -&amp;gt; &lt;span style="color:#a6e22e">JoinHandle&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">where&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> F: &lt;span style="color:#a6e22e">Future&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>Output &lt;span style="color:#f92672">=&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> Send &lt;span style="color:#f92672">+&lt;/span> &amp;#39;static,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T: Send &lt;span style="color:#f92672">+&lt;/span> &amp;#39;static,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 编译时生成特定类型的代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="6-内存模型">6. 内存模型
&lt;/h2>&lt;h3 id="61-任务分配">6.1 任务分配
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 自定义内存分配器优化
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> layout &lt;span style="color:#f92672">=&lt;/span> Layout::new::&lt;span style="color:#f92672">&amp;lt;&lt;/span>Header&lt;span style="color:#f92672">&amp;gt;&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .extend(Layout::new::&lt;span style="color:#f92672">&amp;lt;&lt;/span>Scheduler&lt;span style="color:#f92672">&amp;gt;&lt;/span>())&lt;span style="color:#f92672">?&lt;/span>.&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .extend(Layout::new::&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span>())&lt;span style="color:#f92672">?&lt;/span>.&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> ptr &lt;span style="color:#f92672">=&lt;/span> alloc(layout);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="62-引用计数">6.2 引用计数
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 使用原子引用计数管理任务生命周期
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Task&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> header: &lt;span style="color:#a6e22e">Arc&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>Header&lt;span style="color:#f92672">&amp;gt;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> Drop &lt;span style="color:#66d9ef">for&lt;/span> Task {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">drop&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> Arc::strong_count(&lt;span style="color:#f92672">&amp;amp;&lt;/span>self.header) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 最后一个引用，释放资源
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="7-调试与追踪">7. 调试与追踪
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[cfg(tokio_unstable)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">TaskMeta&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&amp;#39;static &lt;span style="color:#66d9ef">str&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> location: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&amp;#39;static &lt;span style="color:#a6e22e">std&lt;/span>::panic::Location&lt;span style="color:#f92672">&amp;lt;&lt;/span>&amp;#39;static&lt;span style="color:#f92672">&amp;gt;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="8-使用模型">8. 使用模型
&lt;/h2>&lt;h3 id="81-基本使用">8.1 基本使用
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#[tokio::main]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 创建任务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> handle &lt;span style="color:#f92672">=&lt;/span> tokio::spawn(&lt;span style="color:#66d9ef">async&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 异步代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello, Tokio!&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 等待任务完成
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> handle.&lt;span style="color:#66d9ef">await&lt;/span>.unwrap();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">println!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, result);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="82-任务间通信">8.2 任务间通信
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 使用通道进行任务间通信
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> (tx, &lt;span style="color:#66d9ef">mut&lt;/span> rx) &lt;span style="color:#f92672">=&lt;/span> tokio::sync::mpsc::channel(&lt;span style="color:#ae81ff">32&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 生产者任务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>tokio::spawn(&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">move&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tx.send(&lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>).&lt;span style="color:#66d9ef">await&lt;/span>.unwrap();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 消费者任务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>tokio::spawn(&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">move&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> Some(message) &lt;span style="color:#f92672">=&lt;/span> rx.recv().&lt;span style="color:#66d9ef">await&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">println!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;received: &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, message);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="9-性能考量">9. 性能考量
&lt;/h2>&lt;ol>
&lt;li>&lt;strong>任务大小&lt;/strong>：保持任务小巧高效&lt;/li>
&lt;li>&lt;strong>避免阻塞&lt;/strong>：不要在异步上下文中执行阻塞操作&lt;/li>
&lt;li>&lt;strong>批量处理&lt;/strong>：合并小的I/O操作为批量操作&lt;/li>
&lt;li>&lt;strong>合理使用spawn&lt;/strong>：避免创建过多任务&lt;/li>
&lt;/ol>
&lt;h2 id="10-调试技巧">10. 调试技巧
&lt;/h2>&lt;ol>
&lt;li>启用 &lt;code>tokio_unstable&lt;/code> 特性获取更多调试信息&lt;/li>
&lt;li>使用 &lt;code>tracing&lt;/code> 进行分布式追踪&lt;/li>
&lt;li>监控运行时指标（任务数、队列长度等）&lt;/li>
&lt;/ol>
&lt;p>这个模型展示了 Tokio 如何高效地管理异步任务。理解这些核心概念后，您可以更深入地研究特定组件的实现细节。&lt;/p></description></item><item><title>Tokio任务系统解析</title><link>https://www.dust-zed.site/rust/tokio/tokio%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E8%A7%A3%E6%9E%90/</link><pubDate>Fri, 19 Sep 2025 12:38:14 +0800</pubDate><guid>https://www.dust-zed.site/rust/tokio/tokio%E4%BB%BB%E5%8A%A1%E7%B3%BB%E7%BB%9F%E8%A7%A3%E6%9E%90/</guid><description>&lt;p>Tokio的任务系统是其异步运行时的核心，它负责调度和执行异步任务。让我们深入分析其设计和实现。&lt;/p>
&lt;h3 id="1-核心组件">1. 核心组件
&lt;/h3>&lt;h4 id="11-任务表示">1.1 任务表示
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span>(&lt;span style="color:#66d9ef">crate&lt;/span>) &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Task&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>S: &amp;#39;static&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> raw: &lt;span style="color:#a6e22e">RawTask&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _p: &lt;span style="color:#a6e22e">PhantomData&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>S&lt;span style="color:#f92672">&amp;gt;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>RawTask&lt;/code>：实际的任务数据，包含任务状态、调度器等。&lt;/li>
&lt;li>&lt;code>PhantomData&amp;lt;S&amp;gt;&lt;/code>：关联调度器类型，用于类型安全&lt;/li>
&lt;/ul>
&lt;h4 id="12-任务头header">1.2 任务头(Header)
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span>(&lt;span style="color:#66d9ef">crate&lt;/span>) &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Header&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state: &lt;span style="color:#a6e22e">State&lt;/span>, &lt;span style="color:#75715e">// 任务状态
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> queue_next: &lt;span style="color:#a6e22e">UnsafeCell&lt;/span>&lt;span style="color:#f92672">&amp;lt;..&lt;/span>.&lt;span style="color:#f92672">&amp;gt;&lt;/span>, &lt;span style="color:#75715e">// 任务队列指针
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> vtable: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&amp;#39;static &lt;span style="color:#a6e22e">Vtable&lt;/span>, &lt;span style="color:#75715e">// 虚函数表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> owner_id: &lt;span style="color:#a6e22e">UnsafeCell&lt;/span>&lt;span style="color:#f92672">&amp;lt;..&lt;/span>.&lt;span style="color:#f92672">&amp;gt;&lt;/span>, &lt;span style="color:#75715e">// 任务所有者ID
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2-任务生命周期">2. 任务生命周期
&lt;/h4>&lt;h4 id="21-创建任务">2.1 创建任务
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">new_task&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>T, S&lt;span style="color:#f92672">&amp;gt;&lt;/span>(task: &lt;span style="color:#a6e22e">T&lt;/span>, scheduler: &lt;span style="color:#a6e22e">S&lt;/span>, id: &lt;span style="color:#a6e22e">Id&lt;/span>) -&amp;gt; (Task&lt;span style="color:#f92672">&amp;lt;&lt;/span>S&lt;span style="color:#f92672">&amp;gt;&lt;/span>, Notified&lt;span style="color:#f92672">&amp;lt;&lt;/span>S&lt;span style="color:#f92672">&amp;gt;&lt;/span>, JoinHandle&lt;span style="color:#f92672">&amp;lt;&lt;/span>T::Output&lt;span style="color:#f92672">&amp;gt;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">where&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T: &lt;span style="color:#a6e22e">Future&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &amp;#39;static,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> S: &lt;span style="color:#a6e22e">Schedule&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> raw &lt;span style="color:#f92672">=&lt;/span> RawTask::new::&lt;span style="color:#f92672">&amp;lt;&lt;/span>T, S&lt;span style="color:#f92672">&amp;gt;&lt;/span>(task, scheduler, id, spawned_at);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 创建三种句柄
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> task &lt;span style="color:#f92672">=&lt;/span> Task { raw, _p: &lt;span style="color:#a6e22e">PhantomData&lt;/span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> notified &lt;span style="color:#f92672">=&lt;/span> Notified(Task { raw, _p: &lt;span style="color:#a6e22e">PhantomData&lt;/span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> join &lt;span style="color:#f92672">=&lt;/span> JoinHandle::new(raw);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (task, notified, join)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>RawTask&lt;/code>实现了Copy，故这里可以这样做，同时我们需要知道&lt;code>RawTask&lt;/code>的初始引用计数状态。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span>(&lt;span style="color:#66d9ef">super&lt;/span>) &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">new&lt;/span>() -&amp;gt; &lt;span style="color:#a6e22e">State&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> State {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> val: &lt;span style="color:#a6e22e">AtomicUsize&lt;/span>::new(&lt;span style="color:#66d9ef">INTIAL_STATE&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>初始状态设置为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">INITIAL_STATE&lt;/span>: &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">REF_ONE&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>) &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">JOIN_INTEREST&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#66d9ef">NOTIFIED&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这意味着：&lt;/p>
&lt;ol>
&lt;li>初始引用计数是&lt;code>REF_ONE * 3&lt;/code>&lt;/li>
&lt;li>同时设置了 &lt;code>JOIN_INTEREST&lt;/code> 和 &lt;code>NOTIFIED&lt;/code> 标志位&lt;/li>
&lt;/ol>
&lt;p>一个任务创建会返回三个句柄：&lt;/p>
&lt;ol>
&lt;li>&lt;code>Task&lt;/code>：用于取消或释放任务&lt;/li>
&lt;li>&lt;code>Notified&lt;/code>：表示任务已准备好执行&lt;/li>
&lt;li>&lt;code>JoinHandle&lt;/code>：用于等待任务完成并获取结果&lt;/li>
&lt;/ol>
&lt;h3 id="3-核心机制">3. 核心机制
&lt;/h3>&lt;h4 id="31-任务调度">3.1 任务调度
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 在调度器中的执行循环
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">loop&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> task &lt;span style="color:#f92672">=&lt;/span> self.next_task(); &lt;span style="color:#75715e">// 获取下一个就绪任务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> task.run(); &lt;span style="color:#75715e">// 执行任务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="32-唤醒机制">3.2 唤醒机制
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Waker 实现
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Waker&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> header: &lt;span style="color:#a6e22e">NonNull&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>Header&lt;span style="color:#f92672">&amp;gt;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> std::task::Wake &lt;span style="color:#66d9ef">for&lt;/span> Waker {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">wake&lt;/span>(self) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.wake_by_ref();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">wake_by_ref&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>self) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 将任务标记为就绪并重新调度
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">unsafe&lt;/span> { (self.header.as_ref().vtable.schedule)(self.header) };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="4-内存管理">4. 内存管理
&lt;/h3>&lt;h4 id="41-任务分配">4.1 任务分配
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>T: &lt;span style="color:#a6e22e">Future&lt;/span>, S: &lt;span style="color:#a6e22e">Schedule&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> RawTask&lt;span style="color:#f92672">&amp;lt;&lt;/span>T, S&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">new&lt;/span>(future: &lt;span style="color:#a6e22e">T&lt;/span>, scheduler: &lt;span style="color:#a6e22e">S&lt;/span>, id: &lt;span style="color:#a6e22e">Id&lt;/span>) -&amp;gt; &lt;span style="color:#a6e22e">NonNull&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>Header&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 1. 计算内存布局
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 2. 分配内存
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 3. 初始化 Header 和 Future
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 4. 返回指向 Header 的指针
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="42-内存布局">4.2 内存布局
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">+-------------------+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">|&lt;/span> Header &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#75715e">// 包含任务元数据和虚函数表
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">+-------------------+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">|&lt;/span> Scheduler (S) &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#75715e">// 调度器实例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">+-------------------+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">|&lt;/span> Future (T) &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#75715e">// 实际的 Future
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">+-------------------+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">|&lt;/span> Output Slot &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#75715e">// 存储 Future 的输出
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">+-------------------+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">|&lt;/span> Traces &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#75715e">// 调试和跟踪信息
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">+-------------------+&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="5-并发控制">5. 并发控制
&lt;/h3>&lt;h4 id="51-状态管理">5.1 状态管理
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">State&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用原子操作管理状态
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// - 运行中标志
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// - 完成标志
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// - 取消标志
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// - 引用计数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> value: &lt;span style="color:#a6e22e">AtomicUsize&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>具体来说：&lt;/p>
&lt;ul>
&lt;li>高位的比特位用于引用计数(&lt;code>REF_COUNT_MASK&lt;/code>)&lt;/li>
&lt;li>低位的比特位用于任务状态(&lt;code>STATE_MASK&lt;/code>)&lt;/li>
&lt;/ul>
&lt;h4 id="52-锁优化">5.2 锁优化
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 使用无锁算法优化热点路径
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">transition_to_running&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>self) -&amp;gt; &lt;span style="color:#a6e22e">TransitionToRunning&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用原子操作更新状态
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 避免使用互斥锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="7-设计模式">7. 设计模式
&lt;/h3>&lt;h4 id="71-类型擦除">7.1 类型擦除
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 使用虚函数表实现类型擦除
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Vtable&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> poll: &lt;span style="color:#a6e22e">unsafe&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span>(NonNull&lt;span style="color:#f92672">&amp;lt;&lt;/span>Header&lt;span style="color:#f92672">&amp;gt;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dealloc: &lt;span style="color:#a6e22e">unsafe&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span>(NonNull&lt;span style="color:#f92672">&amp;lt;&lt;/span>Header&lt;span style="color:#f92672">&amp;gt;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="72-零成本抽象">7.2 零成本抽象
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 使用泛型和编译期多态
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">impl&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>T, S&lt;span style="color:#f92672">&amp;gt;&lt;/span> Task&lt;span style="color:#f92672">&amp;lt;&lt;/span>T, S&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 零成本抽象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>时间轮算法</title><link>https://www.dust-zed.site/rust/tokio/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95/</link><pubDate>Thu, 11 Sep 2025 21:51:21 +0800</pubDate><guid>https://www.dust-zed.site/rust/tokio/%E6%97%B6%E9%97%B4%E8%BD%AE%E7%AE%97%E6%B3%95/</guid><description>&lt;p>时间轮(Time Wheel)是Tokio定时器实现的核心算法，它通过分层的方式高效管理大量定时器。&lt;/p>
&lt;h3 id="1-基本概念">1. 基本概念
&lt;/h3>&lt;h4 id="11-wheel结构与层级关系">1.1 Wheel结构与层级关系
&lt;/h4>&lt;h5 id="111-时间轮结构">1.1.1 时间轮结构
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span>(&lt;span style="color:#66d9ef">crate&lt;/span>) &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Wheel&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">///当前时间轮已过去的时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span> elapsed: &lt;span style="color:#66d9ef">u64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">///时间轮的分层
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span> levels: Box&lt;span style="color:#f92672">&amp;lt;&lt;/span>[Level; &lt;span style="color:#66d9ef">NUM_LEVELS&lt;/span>]&lt;span style="color:#f92672">&amp;gt;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">///Entries queued for firing
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span> pending: &lt;span style="color:#a6e22e">EntryList&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="112-层级">1.1.2 层级
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Level&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> slot: [EntryList; &lt;span style="color:#66d9ef">LEVEL_MULT&lt;/span>], &lt;span style="color:#75715e">//槽位数组
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> level: &lt;span style="color:#66d9ef">usize&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> occupied: &lt;span style="color:#66d9ef">u64&lt;/span>, &lt;span style="color:#75715e">// bit field指示slot是否占用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="113-槽位">1.1.3 槽位
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Slot&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> head: Option&lt;span style="color:#f92672">&amp;lt;&lt;/span>NonNull&lt;span style="color:#f92672">&amp;lt;&lt;/span>TimerShared&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="12-分层设计">1.2 分层设计
&lt;/h4>&lt;p>Tokio使用多级时间轮（通常为6级），每级包含固定数量的槽位，每级包含固定数量的槽位(slots)：&lt;/p>
&lt;ul>
&lt;li>第0级：64个槽位，每个64^0毫秒&lt;/li>
&lt;li>第1级：64个槽位，每个64^1毫秒&lt;/li>
&lt;li>第2级：32个槽位，每个64^2毫秒&lt;/li>
&lt;li>第3级：32个槽位，每个64^3毫秒&lt;/li>
&lt;li>第4级：32个槽位，每个64^4毫秒&lt;/li>
&lt;li>第5级：32个槽位，每个64^5毫秒&lt;/li>
&lt;/ul>
&lt;h4 id="时间轮的工作流程">时间轮的工作流程
&lt;/h4>&lt;ol>
&lt;li>&lt;strong>添加一个500ms后触发的定时器&lt;/strong>：
&lt;ul>
&lt;li>第0级：500 &amp;gt; 64ms → 不适用&lt;/li>
&lt;li>第1级：500 / 64 = 7.8 → 放入第7个槽位&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>时间推进&lt;/strong>：
&lt;ul>
&lt;li>每毫秒检查第0级&lt;/li>
&lt;li>每64ms检查第1级&lt;/li>
&lt;li>依此类推&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>降级&lt;/strong>：
&lt;ul>
&lt;li>当高层级的时间轮转动时，将定时器重新分配到更精确的层级&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>这种多级设计使得tokio能够：&lt;/p>
&lt;ul>
&lt;li>精确处理短期定时器(毫秒级)&lt;/li>
&lt;li>高效管理长期定时器( 年)&lt;/li>
&lt;li>保持较低的内存占用和计算开销&lt;/li>
&lt;li>根据&lt;code>elapsed&lt;/code>确定需要检查的时间轮层级和槽位&lt;/li>
&lt;/ul>
&lt;p>时间轮和时英钟（时针、分针、秒针）可以进行类比理解。&lt;/p></description></item><item><title>Time的阅读学习记录</title><link>https://www.dust-zed.site/rust/tokio/time%E7%9A%84%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</link><pubDate>Thu, 11 Sep 2025 16:20:08 +0800</pubDate><guid>https://www.dust-zed.site/rust/tokio/time%E7%9A%84%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</guid><description>&lt;h4 id="sourcers">source.rs
&lt;/h4>&lt;ul>
&lt;li>用于管理时间戳转换&lt;/li>
&lt;li>&lt;code>start_time&lt;/code>记录运行时启动的绝对时间点&lt;/li>
&lt;/ul>
&lt;h4 id="entryrs">entry.rs
&lt;/h4>&lt;h5 id="1-核心数据结构">1. 核心数据结构
&lt;/h5>&lt;ul>
&lt;li>&lt;code>TimerEntry&lt;/code>：表示一个定时器条目&lt;/li>
&lt;li>&lt;code>TimerShared&lt;/code>：定时器的共享状态，包含并发控制逻辑&lt;/li>
&lt;li>&lt;code>StateCell&lt;/code>：管理定时器状态的原子操作封装&lt;/li>
&lt;/ul>
&lt;h5 id="2-主要功能">2. 主要功能
&lt;/h5>&lt;h6 id="定时器状态管理">定时器状态管理
&lt;/h6>&lt;ul>
&lt;li>使用原子操作实现无锁状态转换&lt;/li>
&lt;li>支持定时器的注册、取消和触发&lt;/li>
&lt;li>&lt;code>StateCell&lt;/code>有三种状态
&lt;ul>
&lt;li>具体的过期时间戳（定时器已调度，待触发）&lt;/li>
&lt;li>&lt;code>STATE_PENDING_FIRE&lt;/code>（定时器已到期，正准备触发）&lt;/li>
&lt;li>&lt;code>STATE_DEREGISTERED&lt;/code>(已取消/完成)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#960050;background-color:#1e0010">已调度&lt;/span>] &lt;span style="color:#f92672">--&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">时间到&lt;/span> &lt;span style="color:#f92672">-&lt;/span>-&amp;gt; [&lt;span style="color:#960050;background-color:#1e0010">待触发&lt;/span>] &lt;span style="color:#f92672">--&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">触发完成&lt;/span> &lt;span style="color:#f92672">-&lt;/span>-&amp;gt; [&lt;span style="color:#960050;background-color:#1e0010">已取消&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#f92672">^&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#f92672">|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">+------------------&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">取消&lt;/span> &lt;span style="color:#f92672">-------------------+&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>TimerShared&lt;/code>负责管理定时器的共享状态和并发安全，分离了定时器的注册时间，用于时间轮调度&lt;/li>
&lt;li>&lt;code>TimerEntry&lt;/code>是用户可见的句柄，包含完整的生命周期管理&lt;/li>
&lt;/ul>
&lt;h4 id="modrs">mod.rs
&lt;/h4>&lt;p>负责管理所有与时间相关的功能&lt;/p>
&lt;h5 id="核心结构">核心结构
&lt;/h5>&lt;ul>
&lt;li>Driver结构体，时间驱动的主要实现，负责
&lt;ul>
&lt;li>管理时间轮（time wheel）实例&lt;/li>
&lt;li>处理定时器的注册、取消和触发&lt;/li>
&lt;li>与I/O驱动协同工作&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>Inner&lt;/code>和&lt;code>InnerState&lt;/code>
&lt;ul>
&lt;li>包含时间轮实例&lt;/li>
&lt;li>管理驱动状态（如是否已关闭）&lt;/li>
&lt;li>提供线程安全的内部状态访问&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="关键方法">关键方法
&lt;/h5>&lt;p>process_at_time方法&lt;/p>
&lt;ul>
&lt;li>处理当前时间点所有到期的定时器&lt;/li>
&lt;li>处理系统时间回退的情况&lt;/li>
&lt;li>批量唤醒等待的任务&lt;/li>
&lt;/ul>
&lt;p>reregister方法&lt;/p>
&lt;ul>
&lt;li>重新注册定时器到新的时间点&lt;/li>
&lt;li>线程安全的更新定时器&lt;/li>
&lt;li>处理驱动关闭的情况&lt;/li>
&lt;/ul></description></item><item><title>Park 线程挂起的实现</title><link>https://www.dust-zed.site/rust/tokio/park-%E7%BA%BF%E7%A8%8B%E6%8C%82%E8%B5%B7%E7%9A%84%E5%AE%9E%E7%8E%B0/</link><pubDate>Wed, 10 Sep 2025 10:04:26 +0800</pubDate><guid>https://www.dust-zed.site/rust/tokio/park-%E7%BA%BF%E7%A8%8B%E6%8C%82%E8%B5%B7%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid><description>&lt;p>&lt;code>park.rs&lt;/code>是Tokio运行时中用于线程挂起和恢复的核心。&lt;/p>
&lt;h4 id="核心结构">核心结构
&lt;/h4>&lt;h5 id="parkthread-和-unparkthread">ParkThread 和 UnParkThread
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span>(&lt;span style="color:#66d9ef">crate&lt;/span>) &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ParkThread&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inner: &lt;span style="color:#a6e22e">Arc&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>Inner&lt;span style="color:#f92672">&amp;gt;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span>(&lt;span style="color:#66d9ef">crate&lt;/span>) &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">UnParkThread&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> inner: &lt;span style="color:#a6e22e">Arc&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>Inner&lt;span style="color:#f92672">&amp;gt;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>乍一看，这两根本就是相同的结构，但是它们是用在不同地方的，以及impl块有区别。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">tokio_thread_local!&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">CURRENT_PARKER&lt;/span>: &lt;span style="color:#a6e22e">ParkThread&lt;/span> &lt;span style="color:#f92672">=&lt;/span> ParkThread::new();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是最重要的区别，&lt;code>ParkThread&lt;/code>用在了线程局部变量上，而&lt;code>UnParkThread&lt;/code>没有线程局部限制，另外&lt;code>UnParkThread&lt;/code>只实现了&lt;code>unpark&lt;/code>方法，目的是让其他线程只能唤醒。&lt;/p>
&lt;h5 id="inner">Inner
&lt;/h5>&lt;p>&lt;code>Inner&lt;/code>结构体使用原子操作管理线程状态，这种状态管理是构建无锁并发原语的基础。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">EMPTY&lt;/span>: &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#75715e">//初始状态或unpark状态
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">PARKED&lt;/span>: &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">//线程已挂起
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">NOTIFIED&lt;/span>: &lt;span style="color:#66d9ef">usize&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; &lt;span style="color:#75715e">//线程已被通知唤醒
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Inner&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state: &lt;span style="color:#a6e22e">AtomicUsize&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mutex: &lt;span style="color:#a6e22e">Mutex&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>()&lt;span style="color:#f92672">&amp;gt;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> condvar: &lt;span style="color:#a6e22e">Condvar&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>为什么直接用&lt;code>Mutex&amp;lt;Usize&amp;gt;&lt;/code>而是多用了一个&lt;code>AtomicUsize&lt;/code>
&lt;ul>
&lt;li>&lt;code>AtomicUsize&lt;/code>是无锁的，比获取 &lt;code>Mutex&lt;/code>快&lt;/li>
&lt;li>内存顺序保证&lt;/li>
&lt;li>状态更新使用原子操作，减少锁的持有时间&lt;/li>
&lt;li>锁粒度控制，&lt;code>Mutex&lt;/code>只保护条件变量的等待/通知时机&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="具体功能的实现">具体功能的实现
&lt;/h4>&lt;h5 id="park">park()
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">park&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>self) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> self
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .state
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .compare_exchange(&lt;span style="color:#66d9ef">NOTIFIED&lt;/span>, &lt;span style="color:#66d9ef">EMPTY&lt;/span>, SeqCst, SeqCst)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .is_ok() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>; &lt;span style="color:#75715e">// “虚假唤醒”保护，另一个线程unpark，此线程又park，避免了没必要的线程挂起和唤醒操作
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 获取锁,并修改状态至parked
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> m: &lt;span style="color:#a6e22e">std&lt;/span>::sync::MutexGuard&lt;span style="color:#f92672">&amp;lt;&lt;/span>&amp;#39;_, ()&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">=&lt;/span> self.mutex.lock();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">match&lt;/span> self.state.compare_exchange(&lt;span style="color:#66d9ef">EMPTY&lt;/span>, &lt;span style="color:#66d9ef">PARKED&lt;/span>, SeqCst, SeqCst) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Ok(_) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Err(&lt;span style="color:#66d9ef">NOTIFIED&lt;/span>) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> old &lt;span style="color:#f92672">=&lt;/span> self.state.swap(&lt;span style="color:#66d9ef">EMPTY&lt;/span>, SeqCst);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">debug_assert_eq!&lt;/span>(old, &lt;span style="color:#66d9ef">NOTIFIED&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;park state changed unexpectedly&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Err(actual) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">panic!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;inconsistent park state; actual = &lt;/span>&lt;span style="color:#e6db74">{actual}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">loop&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> m &lt;span style="color:#f92672">=&lt;/span> self.condvar.wait(m).unwrap(); &lt;span style="color:#75715e">//释放锁并挂起线程等待notify
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> self
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .state
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .compare_exchange(&lt;span style="color:#66d9ef">NOTIFIED&lt;/span>, &lt;span style="color:#66d9ef">EMPTY&lt;/span>, SeqCst, SeqCst)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .is_ok()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>; &lt;span style="color:#75715e">//确保有效唤醒，NOTIFIED -&amp;gt; EMPTY,忽略错误唤醒
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="双重检查模式">双重检查模式
&lt;/h6>&lt;ul>
&lt;li>第一次检查避免不必要的锁获取&lt;/li>
&lt;li>第二次检查处理竞态条件&lt;/li>
&lt;/ul>
&lt;h6 id="虚假唤醒处理">虚假唤醒处理
&lt;/h6>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">loop&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> m &lt;span style="color:#f92672">=&lt;/span> self.condvar.wait(m).unwrap();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> self.state.compare_exchange(&lt;span style="color:#66d9ef">NOTIFIED&lt;/span>, &lt;span style="color:#66d9ef">EMPTY&lt;/span>, SeqCst, SeqCst).is_ok() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个循环确保只有收到真正的通知才会返回，处理了条件变量的虚假唤醒问题。&lt;/p>
&lt;h5 id="unpark">unpark
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">unpark&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>self) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//无论什么状态都置为NOTIFIED
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">match&lt;/span> self.state.swap(&lt;span style="color:#66d9ef">NOTIFIED&lt;/span>, SeqCst) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">EMPTY&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">NOTIFIED&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">PARKED&lt;/span> &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _ &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">panic!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;inconsistent state in unpark&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//通过lock确保目标线程已经是PARKED了
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> drop(self.mutex.lock());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.condvar.notify_one();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过控制ParkThread和UnParkThread的方法，完成了功能分离，配合之前的&lt;code>ThreadLocal&lt;/code>,完成了线程自己挂起，然后其他线程可以唤醒此线程的功能。同时UnParkThread也可以转为&lt;code>Waker&lt;/code>。&lt;/p>
&lt;h5 id="shutdown">shutdown
&lt;/h5>&lt;p>通知线程该醒了，具体的shutdown操作由调用者处理。&lt;/p>
&lt;h5 id="cachedparkthread">CachedParkThread
&lt;/h5>&lt;ol>
&lt;li>缓存&lt;code>Waker&lt;/code>避免重复分配&lt;/li>
&lt;li>提供&lt;code>block_on&lt;/code>方法，这是运行时执行future的基础&lt;/li>
&lt;li>通过线程局部存储管理每个线程的parker&lt;/li>
&lt;li>&lt;code>_anchor: PhantomData&amp;lt;Rc&amp;lt;()&amp;gt;&amp;gt;&lt;/code>隐含了&lt;code>!Send + !Sync&lt;/code>，CachedParkThread 不可跨线程。&lt;/li>
&lt;/ol></description></item><item><title>Runtime的核心概念</title><link>https://www.dust-zed.site/rust/tokio/runtime%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</link><pubDate>Sat, 06 Sep 2025 18:53:34 +0800</pubDate><guid>https://www.dust-zed.site/rust/tokio/runtime%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</guid><description>&lt;h4 id="1-runtime基本架构">1. Runtime基本架构
&lt;/h4>&lt;p>Tokio的runtime是异步应用的核心，主要负责：&lt;/p>
&lt;ul>
&lt;li>任务调度&lt;/li>
&lt;li>I/O事件循环&lt;/li>
&lt;li>定时器管理&lt;/li>
&lt;li>线程池管理&lt;/li>
&lt;/ul>
&lt;p>让我们看看runtime的主要组件：&lt;/p>
&lt;h5 id="11-runtime结构体">1.1 Runtime结构体
&lt;/h5>&lt;p>&lt;code>Runtime&lt;/code>结构体是整个异步运行时的入口点。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Runtime&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">/// Task scheduler
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span> scheduler: &lt;span style="color:#a6e22e">Scheduler&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">/// handles to runtime, also contains driver handles
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span> handle: &lt;span style="color:#a6e22e">Handle&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">/// Blocking pool handle, used to signal shutdown
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span> blocking_pool: &lt;span style="color:#a6e22e">BlockingPool&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2-核心组件">2. 核心组件
&lt;/h4>&lt;h5 id="21-scheduler">2.1 scheduler
&lt;/h5>&lt;p>&lt;strong>作用：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>负责任务的调度和执行&lt;/li>
&lt;li>管理任务队列和任务状态&lt;/li>
&lt;li>决定任务的执行顺序&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>设计原因&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>将调度逻辑与运行时其他部分解耦&lt;/li>
&lt;li>支持不同的调度策略（单线程/多线程）&lt;/li>
&lt;li>使调度器可以独立测试和优化&lt;/li>
&lt;/ul>
&lt;h5 id="22-handle">2.2 handle
&lt;/h5>&lt;p>&lt;strong>作用：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>提供对运行时的轻量级引用&lt;/li>
&lt;li>允许在运行时外部分发任务&lt;/li>
&lt;li>包含对I/O驱动、定时器等组件的访问&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>设计原因&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>避免直接暴露&lt;code>Runtime&lt;/code>的所有权&lt;/li>
&lt;li>允许多个地方持有对运行时的引用&lt;/li>
&lt;li>支持跨线程发送任务&lt;/li>
&lt;li>便于在异步代码中获取当前运行时&lt;/li>
&lt;/ul>
&lt;h5 id="23-blockingpool">2.3 BlockingPool
&lt;/h5>&lt;p>&lt;strong>作用：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>管理阻塞操作的工作线程池&lt;/li>
&lt;li>执行可能阻塞的操作，如文件I/O或CPU密集型计算&lt;/li>
&lt;li>防止阻塞操作影响异步任务调度&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>设计原因&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>隔离阻塞操作，避免影响事件循环&lt;/li>
&lt;li>提供明确的API来处理阻塞操作&lt;/li>
&lt;li>允许控制阻塞操作的并发度&lt;/li>
&lt;/ul>
&lt;h4 id="3-整体设计考量">3. 整体设计考量
&lt;/h4>&lt;h5 id="1-关注点分离">1. 关注点分离
&lt;/h5>&lt;ul>
&lt;li>&lt;code>scheduler&lt;/code>处理任务调度&lt;/li>
&lt;li>&lt;code>handle&lt;/code>提供运行时访问&lt;/li>
&lt;li>&lt;code>blocking_pool&lt;/code>处理阻塞操作&lt;/li>
&lt;/ul>
&lt;h5 id="2-所有权管理">2. 所有权管理
&lt;/h5>&lt;ul>
&lt;li>&lt;code>Runtime&lt;/code>拥有所有资源的所有权&lt;/li>
&lt;li>&lt;code>Handle&lt;/code>提供了共享访问的方式&lt;/li>
&lt;li>资源在&lt;code>Runtime&lt;/code>被drop时正确清理&lt;/li>
&lt;/ul>
&lt;h5 id="3-性能优化">3. 性能优化
&lt;/h5>&lt;ul>
&lt;li>轻量级的&lt;code>Handle&lt;/code>可以大量复制&lt;/li>
&lt;li>阻塞操作不会阻塞事件循环&lt;/li>
&lt;li>调度器可以根据需要选择单线程或多线程实现&lt;/li>
&lt;/ul>
&lt;h5 id="4-灵活性">4. 灵活性
&lt;/h5>&lt;ul>
&lt;li>支持不同的运行时配置&lt;/li>
&lt;li>可以扩展新的调度策略&lt;/li>
&lt;li>便于测试和模拟&lt;/li>
&lt;/ul>
&lt;h4 id="handle为什么是runtime的轻量级引用">Handle为什么是Runtime的轻量级引用
&lt;/h4>&lt;ol>
&lt;li>
&lt;p>&lt;code>Runtime&lt;/code>中的&lt;code>scheduler&lt;/code>字段&lt;/p>
&lt;ul>
&lt;li>这是主要的&lt;code>Scheduler&lt;/code>实例&lt;/li>
&lt;li>它拥有任务队列和其他资源&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>Handle&lt;/code>中的引用&lt;/p>
&lt;ul>
&lt;li>不是引用&lt;code>Scheduler&lt;/code>本身&lt;/li>
&lt;li>而是引用&lt;code>Scheduler&lt;/code>内部的共享状态&lt;/li>
&lt;li>这些状态通常是通过&lt;code>Arc&lt;/code>包装的独立结构&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>具体实现&lt;/p>
&lt;ul>
&lt;li>&lt;code>CurrentThread&lt;/code>调度器可能使用&lt;code>Rc&amp;lt;RefCell&amp;lt;...&amp;gt;&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;code>MultiThread&lt;/code>调度器使用&lt;code>Arc&lt;/code>进行线程间共享&lt;/li>
&lt;li>这些内部结构在&lt;code>Scheduler&lt;/code>初始化创建&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>所有权关系&lt;/p>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">CurrentThread&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 内部使用 Rc 共享状态
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> shared: &lt;span style="color:#a6e22e">Rc&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>Shared&lt;span style="color:#f92672">&amp;gt;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Handle&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 共享相同的 Rc&amp;lt;Shared&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> shared: &lt;span style="color:#a6e22e">Rc&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>Shared&lt;span style="color:#f92672">&amp;gt;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>创建Handle时，会克隆&lt;code>Arc/Rc&lt;/code>增加引用计数&lt;/li>
&lt;li>这样的设计体现了&lt;code>Scheduler&lt;/code>是&lt;code>Runtime&lt;/code>的核心&lt;/li>
&lt;/ul>
&lt;h4 id="文件io为什么使用阻塞线程池">文件I/O为什么使用阻塞线程池
&lt;/h4>&lt;ul>
&lt;li>网络I/O：现代操作系统提供了专门的非阻塞API（如Linux的epoll，macOS的kqueue）&lt;/li>
&lt;li>文件I/O：大多数操作系统的文件系统API底层仍然是阻塞的&lt;/li>
&lt;li>性能考量：文件操作通常比网络操作快得多；使用非阻塞API反而增加开销；磁盘I/O的延迟通常比网络I/O更可预测。&lt;/li>
&lt;/ul></description></item><item><title>Waker和Context机制</title><link>https://www.dust-zed.site/rust/tokio/waker%E5%92%8Ccontext%E6%9C%BA%E5%88%B6/</link><pubDate>Fri, 05 Sep 2025 18:51:54 +0800</pubDate><guid>https://www.dust-zed.site/rust/tokio/waker%E5%92%8Ccontext%E6%9C%BA%E5%88%B6/</guid><description>&lt;h4 id="基本概念">基本概念
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>Context&lt;/strong>：提供异步任务执行的上下文信息，最重要的是包含Waker&lt;/li>
&lt;li>&lt;strong>Waker&lt;/strong>：用于唤醒被挂起的异步任务的机制&lt;/li>
&lt;li>&lt;strong>Poll&lt;/strong>：Future的轮询状态, &lt;code>Ready&lt;/code>或&lt;code>Pending&lt;/code>&lt;/li>
&lt;/ul>
&lt;h4 id="context的定义">Context的定义
&lt;/h4>&lt;p>&lt;code>Context&lt;/code> 是Rust标准库中&lt;code>std::task&lt;/code>模块提供的结构体，它主要包含：&lt;/p>
&lt;ol>
&lt;li>对&lt;code>Waker&lt;/code>的引用&lt;/li>
&lt;li>可选的任务本地存储&lt;/li>
&lt;/ol>
&lt;p>在Tokio中，&lt;code>Context&lt;/code>主要用于：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> Future &lt;span style="color:#66d9ef">for&lt;/span> MyFuture {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Output&lt;/span> &lt;span style="color:#f92672">=&lt;/span> ();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">poll&lt;/span>(self: &lt;span style="color:#a6e22e">Pin&lt;/span>&lt;span style="color:#f92672">&amp;lt;&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> Self&lt;span style="color:#f92672">&amp;gt;&lt;/span>, cx: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">mut&lt;/span> Context&lt;span style="color:#f92672">&amp;lt;&lt;/span>&amp;#39;_&lt;span style="color:#f92672">&amp;gt;&lt;/span>) -&amp;gt; &lt;span style="color:#a6e22e">Poll&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>Self::Output&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用 cx.waker() 获取 Waker
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 当 I/O 未就绪时，保存 Waker 以便后续唤醒
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="waker的核心实现">Waker的核心实现
&lt;/h4>&lt;p>在Tokio中，&lt;code>Waker&lt;/code>是异步任务通知机制的核心。先看看Tokio中的关键实现&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span>(&lt;span style="color:#66d9ef">super&lt;/span>) &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">WakerRef&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">&amp;#39;a&lt;/span>, S: &amp;#39;static&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> waker: &lt;span style="color:#a6e22e">ManuallyDrop&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>Waker&lt;span style="color:#f92672">&amp;gt;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _p: &lt;span style="color:#a6e22e">PhantomData&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">&amp;#39;a&lt;/span> Header, S)&lt;span style="color:#f92672">&amp;gt;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="waker的创建">Waker的创建
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">raw_waker&lt;/span>(header: &lt;span style="color:#a6e22e">NonNull&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>Header&lt;span style="color:#f92672">&amp;gt;&lt;/span>) -&amp;gt; &lt;span style="color:#a6e22e">RawWaker&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> ptr &lt;span style="color:#f92672">=&lt;/span> header.as_ptr() &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RawWaker::new(ptr, &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">WAKER_VTABLE&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="waker的vtable">Waker的VTable
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">WAKER_VTABLE&lt;/span>: &lt;span style="color:#a6e22e">RawWakerVTable&lt;/span> &lt;span style="color:#f92672">=&lt;/span> RawWakerVTable::new(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clone_waker, &lt;span style="color:#75715e">// 克隆 Waker
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> wake_by_val, &lt;span style="color:#75715e">// 消费 Waker 并唤醒任务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> wake_by_ref, &lt;span style="color:#75715e">// 不消费 Waker 的情况下唤醒任务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> drop_waker, &lt;span style="color:#75715e">// 释放 Waker 资源
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="waker的生命周期">waker的生命周期
&lt;/h5>&lt;ol>
&lt;li>创建： 当任务被创建时，会创建一个对应的Waker&lt;/li>
&lt;li>唤醒：当I/O事件就绪或定时器触发&lt;/li>
&lt;li>消费：任务被唤醒后，Waker会被消费掉&lt;/li>
&lt;li>重建：如果需要再次唤醒任务，需要重新创建Waker&lt;/li>
&lt;/ol>
&lt;h4 id="工作流程示例">工作流程示例
&lt;/h4>&lt;p>简易的任务唤醒流程：&lt;/p>
&lt;h5 id="1-任务创建">1. 任务创建
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> task &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">async&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//异步代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tokio::spawn(task);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="2-waker创建">2. Waker创建
&lt;/h5>&lt;ul>
&lt;li>Tokio运行时为任务创建Waker&lt;/li>
&lt;li>Waker包含指向任务状态的指针&lt;/li>
&lt;/ul>
&lt;h5 id="3-io注册">3. I/O注册
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 当调用类似 TcpStream::read 时
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> ready &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">ready!&lt;/span>(self.io.poll_read_ready(cx)&lt;span style="color:#f92672">?&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="4-任务挂起">4. 任务挂起
&lt;/h5>&lt;ul>
&lt;li>如果I/O未就绪，保存Waker&lt;/li>
&lt;li>返回&lt;code>Poll::Pending&lt;/code>&lt;/li>
&lt;/ul>
&lt;h5 id="5-事件就绪">5. 事件就绪
&lt;/h5>&lt;ul>
&lt;li>I/O事件就绪，保存Waker&lt;/li>
&lt;li>事件循环调用保存的Waker的&lt;code>wake()&lt;/code>方法&lt;/li>
&lt;/ul>
&lt;h5 id="6-任务恢复">6. 任务恢复
&lt;/h5>&lt;ul>
&lt;li>Waker将任务放回就绪队列&lt;/li>
&lt;li>调度器再次轮询该任务&lt;/li>
&lt;/ul></description></item><item><title>Pin和Unpin</title><link>https://www.dust-zed.site/rust/tokio/pin%E5%92%8Cunpin/</link><pubDate>Thu, 04 Sep 2025 15:03:11 +0800</pubDate><guid>https://www.dust-zed.site/rust/tokio/pin%E5%92%8Cunpin/</guid><description>&lt;h4 id="pin和unpin的基本概念">Pin和Unpin的基本概念
&lt;/h4>&lt;h5 id="pin的作用">Pin的作用
&lt;/h5>&lt;p>&lt;code>Pin&amp;lt;P&amp;gt;&lt;/code>是一个包装器，用于固定(pin)内存中的值，防止它被移动。这对于自引用结构体和异步编程中的Future特别重要。&lt;/p>
&lt;h5 id="unpin的特质">Unpin的特质
&lt;/h5>&lt;p>&lt;code>Unpin&lt;/code>是一个自动派生的标记trait，表示类型可以安全地移出&lt;code>Pin&lt;/code>。大多数类型都自动实现了&lt;code>Unpin&lt;/code>。实现了&lt;code>Unpin&lt;/code>的类型可以安全地从&lt;code>Pin&lt;/code>中移出。&lt;/p>
&lt;h4 id="asyncawait为何需要pin">async/await为何需要Pin
&lt;/h4>&lt;ul>
&lt;li>&lt;code>async&lt;/code>块可能包含自引用，&lt;code>async&lt;/code>转变为&lt;code>Future&lt;/code>结构体,它是一个状态机&lt;/li>
&lt;li>当&lt;code>.await&lt;/code>暂停执行时，局部变量会保存在生成的Future中&lt;/li>
&lt;li>如果这些变量相互引用，移动Future会导致悬垂指针&lt;/li>
&lt;/ul>
&lt;h4 id="生命周期管理层次">生命周期管理层次
&lt;/h4>&lt;h5 id="1-变量级别">1. 变量级别
&lt;/h5>&lt;ul>
&lt;li>局部变量被移动到Future状态机中&lt;/li>
&lt;li>生命周期与Future实例绑定&lt;/li>
&lt;/ul>
&lt;h5 id="2-future级别">2. Future级别
&lt;/h5>&lt;ul>
&lt;li>由执行器拥有和管理&lt;/li>
&lt;li>执行器决定何时poll，何时drop&lt;/li>
&lt;/ul>
&lt;h5 id="3-执行器级别">3. 执行器级别
&lt;/h5>&lt;ul>
&lt;li>管理所有Future的生命周期&lt;/li>
&lt;li>负责调度和管理&lt;/li>
&lt;/ul>
&lt;h5 id="4-栈帧与状态机">4. 栈帧与状态机
&lt;/h5>&lt;ul>
&lt;li>同步：变量生命周期由栈帧管理&lt;/li>
&lt;li>异步：变量生命周期由状态机管理&lt;/li>
&lt;/ul>
&lt;h4 id="任务队列与future">任务队列与Future
&lt;/h4>&lt;h5 id="一次性移动">一次性移动
&lt;/h5>&lt;ul>
&lt;li>Future被移动到执行器后，由Pin保证不会再次移动&lt;/li>
&lt;li>执行器内部使用指针来引用Future&lt;/li>
&lt;/ul>
&lt;h5 id="任务队列的实现">任务队列的实现
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 伪代码：任务队列中的 Future
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Task&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> future: &lt;span style="color:#a6e22e">Pin&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>Box&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">dyn&lt;/span> Future&lt;span style="color:#f92672">&amp;lt;&lt;/span>Output &lt;span style="color:#f92672">=&lt;/span> ()&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> Send&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 任务队列存储的是 Box&amp;lt;Task&amp;gt;，而不是直接存储 Future
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> task_queue: Vec&lt;span style="color:#f92672">&amp;lt;&lt;/span>Box&lt;span style="color:#f92672">&amp;lt;&lt;/span>Task&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">..&lt;/span>.;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="工作窃取调度">工作窃取调度
&lt;/h5>&lt;ul>
&lt;li>当任务在线程间转移时，转移的是&lt;code>Box&amp;lt;Task&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;code>Box&lt;/code>的移动不会影响内部Future的内存地址&lt;/li>
&lt;li>Pin 保证的是 &lt;code>Box&lt;/code> 内部的 Future 不会被移出&lt;/li>
&lt;/ul></description></item><item><title>Tokio整体结构</title><link>https://www.dust-zed.site/rust/tokio/tokio%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84/</link><pubDate>Wed, 03 Sep 2025 12:28:49 +0800</pubDate><guid>https://www.dust-zed.site/rust/tokio/tokio%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84/</guid><description>&lt;h3 id="tokio架构设计">Tokio架构设计
&lt;/h3>&lt;p>Tokio是一个基于Rust的一步运行时，其设计非常精妙。&lt;/p>
&lt;h4 id="1-核心组件">1. 核心组件
&lt;/h4>&lt;h5 id="11-reactor反应器">1.1 Reactor（反应器）
&lt;/h5>&lt;ul>
&lt;li>&lt;strong>I/O多路复用&lt;/strong>：基于操作系统提供的epoll/kqueue/IOCP等机制&lt;/li>
&lt;li>&lt;strong>事件循环&lt;/strong>： 负责监听和分发I/O事件&lt;/li>
&lt;li>&lt;strong>非阻塞I/O&lt;/strong>：所有I/O操作都是非阻塞的&lt;/li>
&lt;/ul>
&lt;h5 id="12-scheduler">1.2 Scheduler
&lt;/h5>&lt;ul>
&lt;li>&lt;strong>工作窃取&lt;/strong>：使用工作窃取算法在多线程间分配任务&lt;/li>
&lt;li>&lt;strong>多线程执行器&lt;/strong>： 默认使用多线程执行器提高并发性能&lt;/li>
&lt;li>&lt;strong>任务调度&lt;/strong>： 负责任务的调度和执行&lt;/li>
&lt;/ul>
&lt;h5 id="13-异步任务">1.3 异步任务
&lt;/h5>&lt;ul>
&lt;li>&lt;strong>Future抽象&lt;/strong>：基于Rust的Future trait&lt;/li>
&lt;li>&lt;strong>零成本抽象&lt;/strong>：利用Rust的所有权系统实现零成本抽象&lt;/li>
&lt;li>&lt;strong>任务窃取&lt;/strong>： 任务可以在不同线程间迁移以平衡负载&lt;/li>
&lt;/ul>
&lt;h4 id="2-设计哲学">2. 设计哲学
&lt;/h4>&lt;h5 id="21-零成本抽象">2.1 零成本抽象
&lt;/h5>&lt;ul>
&lt;li>使用Rust的零成本抽象原则&lt;/li>
&lt;li>运行时检查转变为编译时检查&lt;/li>
&lt;li>最小化运行时开销&lt;/li>
&lt;/ul>
&lt;h5 id="22-模块化设计">2.2 模块化设计
&lt;/h5>&lt;ul>
&lt;li>核心组件解耦&lt;/li>
&lt;li>可按需选择功能&lt;/li>
&lt;li>可扩展性强&lt;/li>
&lt;/ul>
&lt;h5 id="23-性能优先">2.3 性能优先
&lt;/h5>&lt;ul>
&lt;li>无锁数据结构&lt;/li>
&lt;li>最小化内存分配&lt;/li>
&lt;li>批处理系统调用&lt;/li>
&lt;/ul>
&lt;h4 id="3-关键实现细节">3. 关键实现细节
&lt;/h4>&lt;h5 id="31-任务调度">3.1 任务调度
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 简化的任务结构
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Task&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 任务状态
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> state: &lt;span style="color:#a6e22e">AtomicUsize&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 任务执行体
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> future: &lt;span style="color:#a6e22e">Mutex&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>Pin&lt;span style="color:#f92672">&amp;lt;&lt;/span>Box&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">dyn&lt;/span> Future&lt;span style="color:#f92672">&amp;lt;&lt;/span>Output &lt;span style="color:#f92672">=&lt;/span> ()&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &amp;#39;static&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 任务队列相关
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> next: &lt;span style="color:#a6e22e">UnsafeCell&lt;/span>&lt;span style="color:#f92672">&amp;lt;*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> Task&lt;span style="color:#f92672">&amp;gt;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="32-io驱动">3.2 I/O驱动
&lt;/h5>&lt;ul>
&lt;li>使用mio库提供跨平台I/O多路复用&lt;/li>
&lt;li>基于readiness模型&lt;/li>
&lt;li>零拷贝支持&lt;/li>
&lt;/ul>
&lt;h4 id="4-高级特性">4. 高级特性
&lt;/h4>&lt;h5 id="41-异步等待">4.1 异步等待
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 异步函数示例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">process&lt;/span>(socket: &lt;span style="color:#a6e22e">TcpStream&lt;/span>) -&amp;gt; &lt;span style="color:#a6e22e">io&lt;/span>::Result&lt;span style="color:#f92672">&amp;lt;&lt;/span>()&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> buf &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#ae81ff">1024&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 异步读取
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> socket.read(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> buf).&lt;span style="color:#66d9ef">await&lt;/span>&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 处理数据...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Ok(())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="42-定时器">4.2 定时器
&lt;/h5>&lt;ul>
&lt;li>分层时间轮实现&lt;/li>
&lt;li>高精度定时器&lt;/li>
&lt;li>低开销&lt;/li>
&lt;/ul>
&lt;h4 id="5-性能优化">5. 性能优化
&lt;/h4>&lt;ol>
&lt;li>&lt;strong>零成本抽象&lt;/strong>：利用Rust的所有权系统&lt;/li>
&lt;li>&lt;strong>无锁编程&lt;/strong>： 减少锁争用&lt;/li>
&lt;li>&lt;strong>批处理&lt;/strong>：合并系统调用&lt;/li>
&lt;li>&lt;strong>内存池&lt;/strong>：减少内存分配&lt;/li>
&lt;/ol>
&lt;h4 id="6-生态系统">6. 生态系统
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>tokio-util&lt;/strong>：实用工具&lt;/li>
&lt;li>&lt;strong>tokio-stream&lt;/strong>：流处理&lt;/li>
&lt;li>&lt;strong>tokio-tungstenite&lt;/strong>: WebSocket&lt;/li>
&lt;li>&lt;strong>tonic&lt;/strong>: gRPC实现&lt;/li>
&lt;/ul>
&lt;h4 id="7设计取舍">7.设计取舍
&lt;/h4>&lt;ol>
&lt;li>&lt;strong>复杂性&lt;/strong>：为了性能接收更高的实现复杂度&lt;/li>
&lt;li>&lt;strong>学习曲线&lt;/strong>： 需要理解Rust异步编程模型&lt;/li>
&lt;li>&lt;strong>调试难度&lt;/strong>： 异步调试相对困难&lt;/li>
&lt;/ol>
&lt;h4 id="8最佳实践">8.最佳实践
&lt;/h4>&lt;ol>
&lt;li>避免在异步代码中执行阻塞操作&lt;/li>
&lt;li>合理使用&lt;code>spawn_blocking&lt;/code>&lt;/li>
&lt;li>注意任务取消和清理&lt;/li>
&lt;li>合理设置工作线程&lt;/li>
&lt;/ol>
&lt;p>Tokio 的设计体现了 Rust 语言的核心理念：零成本抽象、内存安全和并发安全。它的架构设计使其成为构建高性能、可靠网络应用的理想选择。&lt;/p>
&lt;hr>
&lt;h4 id="异步概念">异步概念
&lt;/h4>&lt;h5 id="future-trait基础">Future Trait基础
&lt;/h5>&lt;p>&lt;code>Future&lt;/code>是Rust异步编程的核心trait，定义在标准库&lt;code>std::future&lt;/code>中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">trait&lt;/span> Future {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Output&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">poll&lt;/span>(self: &lt;span style="color:#a6e22e">Pin&lt;/span>&lt;span style="color:#f92672">&amp;lt;&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> Self&lt;span style="color:#f92672">&amp;gt;&lt;/span>, cx: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">mut&lt;/span> Context&lt;span style="color:#f92672">&amp;lt;&lt;/span>&amp;#39;_&lt;span style="color:#f92672">&amp;gt;&lt;/span>) -&amp;gt; &lt;span style="color:#a6e22e">Poll&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>Self::Output&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="关键点">关键点
&lt;/h6>&lt;ul>
&lt;li>&lt;code>Output&lt;/code>：Future完成时产生的值类型&lt;/li>
&lt;li>&lt;code>poll&lt;/code>：检查Future是否完成
&lt;ul>
&lt;li>返回&lt;code>Poll::Ready(Output)&lt;/code>：完成并返回结果&lt;/li>
&lt;li>返回&lt;code>Poll::Pending&lt;/code>：未完成，稍后需要再次轮询&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="asyncawait语法糖">Async/Await语法糖
&lt;/h5>&lt;p>&lt;code>async/await&lt;/code>是Rust提供的语法糖，让异步代码看起来像同步代码：&lt;/p>
&lt;h6 id="1-基本用法">1. 基本用法
&lt;/h6>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">fetch_data&lt;/span>() -&amp;gt; Result&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, io::Error&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//异步操作
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> data &lt;span style="color:#f92672">=&lt;/span> read_from_network().&lt;span style="color:#66d9ef">await&lt;/span>&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Ok(data)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="2-展开形式">2. 展开形式
&lt;/h6>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">FetchDataFuture&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> state: &lt;span style="color:#a6e22e">State&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">State&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Start,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AwaitingRead(ReadFuture),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Done,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> Future &lt;span style="color:#66d9ef">for&lt;/span> FetchDataFuture {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Output&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Result&lt;span style="color:#f92672">&amp;lt;&lt;/span>String, io::Error&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">poll&lt;/span>(&lt;span style="color:#66d9ef">mut&lt;/span> self: &lt;span style="color:#a6e22e">Pin&lt;/span>&lt;span style="color:#f92672">&amp;lt;&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> Self&lt;span style="color:#f92672">&amp;gt;&lt;/span>, cx: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">mut&lt;/span> Context&lt;span style="color:#f92672">&amp;lt;&lt;/span>&amp;#39;_&lt;span style="color:#f92672">&amp;gt;&lt;/span>) -&amp;gt; &lt;span style="color:#a6e22e">Poll&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>Self::Output&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">loop&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">match&lt;/span> self.state {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> State::Start &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> read_fut &lt;span style="color:#f92672">=&lt;/span> read_from_network();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.state &lt;span style="color:#f92672">=&lt;/span> State::AwaitingRead(read_fut);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> State::AwaitingRead(&lt;span style="color:#66d9ef">ref&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> fut) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">match&lt;/span> Pin::new(fut).poll(cx) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Poll::Ready(Ok(data)) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Poll::Ready(Ok(data));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Poll::Ready(Err(e)) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Poll::Ready(Err(e));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Poll::Pending &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Poll::Pending;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> State::Done &lt;span style="color:#f92672">=&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">panic!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;poll called after completion&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="关键概念">关键概念
&lt;/h4>&lt;h6 id="1-零成本抽象">1. 零成本抽象
&lt;/h6>&lt;ul>
&lt;li>异步代码在编译时转换为状态机&lt;/li>
&lt;li>没有运行时开销，与手写的回调代码性能相当&lt;/li>
&lt;/ul>
&lt;h6 id="2-执行器executor">2. 执行器(Executor)
&lt;/h6>&lt;ul>
&lt;li>负责调度和执行Future&lt;/li>
&lt;li>Tokio提供了高性能的执行器实现&lt;/li>
&lt;/ul>
&lt;h6 id="3-waker机制">3. Waker机制
&lt;/h6>&lt;ul>
&lt;li>当Future返回&lt;code>Poll::Pending&lt;/code>时，会注册一个Waker&lt;/li>
&lt;li>当Future可以继续执行时，通过Waker通知执行器&lt;/li>
&lt;/ul>
&lt;h6 id="4-task与future">4. Task与Future
&lt;/h6>&lt;ul>
&lt;li>&lt;code>Task&lt;/code>是执行单元，是Tokio调度的基本单位，负责执行一个顶层的Future到完成&lt;/li>
&lt;li>&lt;code>Future&lt;/code>是计算单元，代表一个异步计算，一个Task可以包含多个嵌套的Future，这些嵌套的Future共享同一个Task的执行上下文。&lt;/li>
&lt;/ul></description></item></channel></rss>