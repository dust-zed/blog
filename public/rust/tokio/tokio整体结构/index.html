<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="Tokio架构设计 Tokio是一个基于Rust的一步运行时，其设计非常精妙。\n1. 核心组件 1.1 Reactor（反应器） I/O多路复用：基于操作系统提供的epoll/kqueue/IOCP等机制 事件循环： 负责监听和分发I/O事件 非阻塞I/O：所有I/O操作都是非阻塞的 1.2 Scheduler 工作窃取：使用工作窃取算法在多线程间分配任务 多线程执行器： 默认使用多线程执行器提高并发性能 任务调度： 负责任务的调度和执行 1.3 异步任务 Future抽象：基于Rust的Future trait 零成本抽象：利用Rust的所有权系统实现零成本抽象 任务窃取： 任务可以在不同线程间迁移以平衡负载 2. 设计哲学 2.1 零成本抽象 使用Rust的零成本抽象原则 运行时检查转变为编译时检查 最小化运行时开销 2.2 模块化设计 核心组件解耦 可按需选择功能 可扩展性强 2.3 性能优先 无锁数据结构 最小化内存分配 批处理系统调用 3. 关键实现细节 3.1 任务调度 // 简化的任务结构 struct Task { // 任务状态 state: AtomicUsize, // 任务执行体 future: Mutex&lt;Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt; + &#39;static&gt;&gt;&gt;, // 任务队列相关 next: UnsafeCell&lt;*const Task&gt;, } 3.2 I/O驱动 使用mio库提供跨平台I/O多路复用 基于readiness模型 零拷贝支持 4. 高级特性 4.1 异步等待 // 异步函数示例 async fn process(socket: TcpStream) -&gt; io::Result&lt;()&gt; { let mut buf = [0; 1024]; // 异步读取 let n = socket.read(&amp;mut buf).await?; // 处理数据... Ok(()) } 4.2 定时器 分层时间轮实现 高精度定时器 低开销 5. 性能优化 零成本抽象：利用Rust的所有权系统 无锁编程： 减少锁争用 批处理：合并系统调用 内存池：减少内存分配 6. 生态系统 tokio-util：实用工具 tokio-stream：流处理 tokio-tungstenite: WebSocket tonic: gRPC实现 7.设计取舍 复杂性：为了性能接收更高的实现复杂度 学习曲线： 需要理解Rust异步编程模型 调试难度： 异步调试相对困难 8.最佳实践 避免在异步代码中执行阻塞操作 合理使用spawn_blocking 注意任务取消和清理 合理设置工作线程 Tokio 的设计体现了 Rust 语言的核心理念：零成本抽象、内存安全和并发安全。它的架构设计使其成为构建高性能、可靠网络应用的理想选择。\n">
<title>Tokio整体结构</title>

<link rel='canonical' href='http://localhost:1313/rust/tokio/tokio%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84/'>

<link rel="stylesheet" href="/scss/style.min.946cca6c6259ef94ac55abfae7c7bf3291ea3ed5eea17ef77500b257217c6710.css"><meta property='og:title' content="Tokio整体结构">
<meta property='og:description' content="Tokio架构设计 Tokio是一个基于Rust的一步运行时，其设计非常精妙。\n1. 核心组件 1.1 Reactor（反应器） I/O多路复用：基于操作系统提供的epoll/kqueue/IOCP等机制 事件循环： 负责监听和分发I/O事件 非阻塞I/O：所有I/O操作都是非阻塞的 1.2 Scheduler 工作窃取：使用工作窃取算法在多线程间分配任务 多线程执行器： 默认使用多线程执行器提高并发性能 任务调度： 负责任务的调度和执行 1.3 异步任务 Future抽象：基于Rust的Future trait 零成本抽象：利用Rust的所有权系统实现零成本抽象 任务窃取： 任务可以在不同线程间迁移以平衡负载 2. 设计哲学 2.1 零成本抽象 使用Rust的零成本抽象原则 运行时检查转变为编译时检查 最小化运行时开销 2.2 模块化设计 核心组件解耦 可按需选择功能 可扩展性强 2.3 性能优先 无锁数据结构 最小化内存分配 批处理系统调用 3. 关键实现细节 3.1 任务调度 // 简化的任务结构 struct Task { // 任务状态 state: AtomicUsize, // 任务执行体 future: Mutex&lt;Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt; + &#39;static&gt;&gt;&gt;, // 任务队列相关 next: UnsafeCell&lt;*const Task&gt;, } 3.2 I/O驱动 使用mio库提供跨平台I/O多路复用 基于readiness模型 零拷贝支持 4. 高级特性 4.1 异步等待 // 异步函数示例 async fn process(socket: TcpStream) -&gt; io::Result&lt;()&gt; { let mut buf = [0; 1024]; // 异步读取 let n = socket.read(&amp;mut buf).await?; // 处理数据... Ok(()) } 4.2 定时器 分层时间轮实现 高精度定时器 低开销 5. 性能优化 零成本抽象：利用Rust的所有权系统 无锁编程： 减少锁争用 批处理：合并系统调用 内存池：减少内存分配 6. 生态系统 tokio-util：实用工具 tokio-stream：流处理 tokio-tungstenite: WebSocket tonic: gRPC实现 7.设计取舍 复杂性：为了性能接收更高的实现复杂度 学习曲线： 需要理解Rust异步编程模型 调试难度： 异步调试相对困难 8.最佳实践 避免在异步代码中执行阻塞操作 合理使用spawn_blocking 注意任务取消和清理 合理设置工作线程 Tokio 的设计体现了 Rust 语言的核心理念：零成本抽象、内存安全和并发安全。它的架构设计使其成为构建高性能、可靠网络应用的理想选择。\n">
<meta property='og:url' content='http://localhost:1313/rust/tokio/tokio%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84/'>
<meta property='og:site_name' content='zed的博客'>
<meta property='og:type' content='article'><meta property='article:section' content='Rust' /><meta property='article:published_time' content='2025-09-03T12:28:49&#43;08:00'/><meta property='article:modified_time' content='2025-09-03T12:28:49&#43;08:00'/>
<meta name="twitter:title" content="Tokio整体结构">
<meta name="twitter:description" content="Tokio架构设计 Tokio是一个基于Rust的一步运行时，其设计非常精妙。\n1. 核心组件 1.1 Reactor（反应器） I/O多路复用：基于操作系统提供的epoll/kqueue/IOCP等机制 事件循环： 负责监听和分发I/O事件 非阻塞I/O：所有I/O操作都是非阻塞的 1.2 Scheduler 工作窃取：使用工作窃取算法在多线程间分配任务 多线程执行器： 默认使用多线程执行器提高并发性能 任务调度： 负责任务的调度和执行 1.3 异步任务 Future抽象：基于Rust的Future trait 零成本抽象：利用Rust的所有权系统实现零成本抽象 任务窃取： 任务可以在不同线程间迁移以平衡负载 2. 设计哲学 2.1 零成本抽象 使用Rust的零成本抽象原则 运行时检查转变为编译时检查 最小化运行时开销 2.2 模块化设计 核心组件解耦 可按需选择功能 可扩展性强 2.3 性能优先 无锁数据结构 最小化内存分配 批处理系统调用 3. 关键实现细节 3.1 任务调度 // 简化的任务结构 struct Task { // 任务状态 state: AtomicUsize, // 任务执行体 future: Mutex&lt;Pin&lt;Box&lt;dyn Future&lt;Output = ()&gt; + &#39;static&gt;&gt;&gt;, // 任务队列相关 next: UnsafeCell&lt;*const Task&gt;, } 3.2 I/O驱动 使用mio库提供跨平台I/O多路复用 基于readiness模型 零拷贝支持 4. 高级特性 4.1 异步等待 // 异步函数示例 async fn process(socket: TcpStream) -&gt; io::Result&lt;()&gt; { let mut buf = [0; 1024]; // 异步读取 let n = socket.read(&amp;mut buf).await?; // 处理数据... Ok(()) } 4.2 定时器 分层时间轮实现 高精度定时器 低开销 5. 性能优化 零成本抽象：利用Rust的所有权系统 无锁编程： 减少锁争用 批处理：合并系统调用 内存池：减少内存分配 6. 生态系统 tokio-util：实用工具 tokio-stream：流处理 tokio-tungstenite: WebSocket tonic: gRPC实现 7.设计取舍 复杂性：为了性能接收更高的实现复杂度 学习曲线： 需要理解Rust异步编程模型 调试难度： 异步调试相对困难 8.最佳实践 避免在异步代码中执行阻塞操作 合理使用spawn_blocking 注意任务取消和清理 合理设置工作线程 Tokio 的设计体现了 Rust 语言的核心理念：零成本抽象、内存安全和并发安全。它的架构设计使其成为构建高性能、可靠网络应用的理想选择。\n">
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column compact"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu_f509edb42ecc0ebd.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">zed的博客</a></h1>
            <h2 class="site-description"></h2>
        </div>
    </header><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/android-develop' >
                
                
                
                <span>android-develop</span>
            </a>
        </li>
        
        
        <li >
            <a href='/rust' >
                
                
                
                <span>rust</span>
            </a>
        </li>
        
        
        <li >
            <a href='/learning-reflection/' >
                
                
                
                <span>Learning-Reflections</span>
            </a>
        </li>
        
        
        <li >
            <a href='/tutorials/' >
                
                
                
                <span>Tutorials</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    

            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/rust/" >
                Rust
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/rust/tokio/tokio%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84/">Tokio整体结构</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Sep 03, 2025</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 2 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h3 id="tokio架构设计">Tokio架构设计
</h3><p>Tokio是一个基于Rust的一步运行时，其设计非常精妙。</p>
<h4 id="1-核心组件">1. 核心组件
</h4><h5 id="11-reactor反应器">1.1 Reactor（反应器）
</h5><ul>
<li><strong>I/O多路复用</strong>：基于操作系统提供的epoll/kqueue/IOCP等机制</li>
<li><strong>事件循环</strong>： 负责监听和分发I/O事件</li>
<li><strong>非阻塞I/O</strong>：所有I/O操作都是非阻塞的</li>
</ul>
<h5 id="12-scheduler">1.2 Scheduler
</h5><ul>
<li><strong>工作窃取</strong>：使用工作窃取算法在多线程间分配任务</li>
<li><strong>多线程执行器</strong>： 默认使用多线程执行器提高并发性能</li>
<li><strong>任务调度</strong>： 负责任务的调度和执行</li>
</ul>
<h5 id="13-异步任务">1.3 异步任务
</h5><ul>
<li><strong>Future抽象</strong>：基于Rust的Future trait</li>
<li><strong>零成本抽象</strong>：利用Rust的所有权系统实现零成本抽象</li>
<li><strong>任务窃取</strong>： 任务可以在不同线程间迁移以平衡负载</li>
</ul>
<h4 id="2-设计哲学">2. 设计哲学
</h4><h5 id="21-零成本抽象">2.1 零成本抽象
</h5><ul>
<li>使用Rust的零成本抽象原则</li>
<li>运行时检查转变为编译时检查</li>
<li>最小化运行时开销</li>
</ul>
<h5 id="22-模块化设计">2.2 模块化设计
</h5><ul>
<li>核心组件解耦</li>
<li>可按需选择功能</li>
<li>可扩展性强</li>
</ul>
<h5 id="23-性能优先">2.3 性能优先
</h5><ul>
<li>无锁数据结构</li>
<li>最小化内存分配</li>
<li>批处理系统调用</li>
</ul>
<h4 id="3-关键实现细节">3. 关键实现细节
</h4><h5 id="31-任务调度">3.1 任务调度
</h5><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// 简化的任务结构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Task</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 任务状态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    state: <span style="color:#a6e22e">AtomicUsize</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 任务执行体
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    future: <span style="color:#a6e22e">Mutex</span><span style="color:#f92672">&lt;</span>Pin<span style="color:#f92672">&lt;</span>Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> ()<span style="color:#f92672">&gt;</span> <span style="color:#f92672">+</span> &#39;static<span style="color:#f92672">&gt;&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 任务队列相关
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    next: <span style="color:#a6e22e">UnsafeCell</span><span style="color:#f92672">&lt;*</span><span style="color:#66d9ef">const</span> Task<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="32-io驱动">3.2 I/O驱动
</h5><ul>
<li>使用mio库提供跨平台I/O多路复用</li>
<li>基于readiness模型</li>
<li>零拷贝支持</li>
</ul>
<h4 id="4-高级特性">4. 高级特性
</h4><h5 id="41-异步等待">4.1 异步等待
</h5><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// 异步函数示例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">process</span>(socket: <span style="color:#a6e22e">TcpStream</span>) -&gt; <span style="color:#a6e22e">io</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> buf <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>; <span style="color:#ae81ff">1024</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 异步读取
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> n <span style="color:#f92672">=</span> socket.read(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> buf).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 处理数据...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Ok(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="42-定时器">4.2 定时器
</h5><ul>
<li>分层时间轮实现</li>
<li>高精度定时器</li>
<li>低开销</li>
</ul>
<h4 id="5-性能优化">5. 性能优化
</h4><ol>
<li><strong>零成本抽象</strong>：利用Rust的所有权系统</li>
<li><strong>无锁编程</strong>： 减少锁争用</li>
<li><strong>批处理</strong>：合并系统调用</li>
<li><strong>内存池</strong>：减少内存分配</li>
</ol>
<h4 id="6-生态系统">6. 生态系统
</h4><ul>
<li><strong>tokio-util</strong>：实用工具</li>
<li><strong>tokio-stream</strong>：流处理</li>
<li><strong>tokio-tungstenite</strong>: WebSocket</li>
<li><strong>tonic</strong>: gRPC实现</li>
</ul>
<h4 id="7设计取舍">7.设计取舍
</h4><ol>
<li><strong>复杂性</strong>：为了性能接收更高的实现复杂度</li>
<li><strong>学习曲线</strong>： 需要理解Rust异步编程模型</li>
<li><strong>调试难度</strong>： 异步调试相对困难</li>
</ol>
<h4 id="8最佳实践">8.最佳实践
</h4><ol>
<li>避免在异步代码中执行阻塞操作</li>
<li>合理使用<code>spawn_blocking</code></li>
<li>注意任务取消和清理</li>
<li>合理设置工作线程</li>
</ol>
<p>Tokio 的设计体现了 Rust 语言的核心理念：零成本抽象、内存安全和并发安全。它的架构设计使其成为构建高性能、可靠网络应用的理想选择。</p>
<hr>
<h4 id="异步概念">异步概念
</h4><h5 id="future-trait基础">Future Trait基础
</h5><p><code>Future</code>是Rust异步编程的核心trait，定义在标准库<code>std::future</code>中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Future {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll</span>(self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;</span>&#39;_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Self::Output<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h6 id="关键点">关键点
</h6><ul>
<li><code>Output</code>：Future完成时产生的值类型</li>
<li><code>poll</code>：检查Future是否完成
<ul>
<li>返回<code>Poll::Ready(Output)</code>：完成并返回结果</li>
<li>返回<code>Poll::Pending</code>：未完成，稍后需要再次轮询</li>
</ul>
</li>
</ul>
<h5 id="asyncawait语法糖">Async/Await语法糖
</h5><p><code>async/await</code>是Rust提供的语法糖，让异步代码看起来像同步代码：</p>
<h6 id="1-基本用法">1. 基本用法
</h6><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">fetch_data</span>() -&gt; Result<span style="color:#f92672">&lt;</span>String, io::Error<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//异步操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">let</span> data <span style="color:#f92672">=</span> read_from_network().<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>  Ok(data)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h6 id="2-展开形式">2. 展开形式
</h6><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">FetchDataFuture</span> {
</span></span><span style="display:flex;"><span>    state: <span style="color:#a6e22e">State</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">State</span> {
</span></span><span style="display:flex;"><span>    Start,
</span></span><span style="display:flex;"><span>    AwaitingRead(ReadFuture),
</span></span><span style="display:flex;"><span>    Done,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> Future <span style="color:#66d9ef">for</span> FetchDataFuture {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Output</span> <span style="color:#f92672">=</span> Result<span style="color:#f92672">&lt;</span>String, io::Error<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">poll</span>(<span style="color:#66d9ef">mut</span> self: <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">mut</span> Self<span style="color:#f92672">&gt;</span>, cx: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">mut</span> Context<span style="color:#f92672">&lt;</span>&#39;_<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">Poll</span><span style="color:#f92672">&lt;</span>Self::Output<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">match</span> self.state {
</span></span><span style="display:flex;"><span>                State::Start <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">let</span> read_fut <span style="color:#f92672">=</span> read_from_network();
</span></span><span style="display:flex;"><span>                    self.state <span style="color:#f92672">=</span> State::AwaitingRead(read_fut);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                State::AwaitingRead(<span style="color:#66d9ef">ref</span> <span style="color:#66d9ef">mut</span> fut) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">match</span> Pin::new(fut).poll(cx) {
</span></span><span style="display:flex;"><span>                        Poll::Ready(Ok(data)) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">return</span> Poll::Ready(Ok(data));
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                        Poll::Ready(Err(e)) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">return</span> Poll::Ready(Err(e));
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                        Poll::Pending <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>                            <span style="color:#66d9ef">return</span> Poll::Pending;
</span></span><span style="display:flex;"><span>                        }
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                State::Done <span style="color:#f92672">=&gt;</span> <span style="color:#a6e22e">panic!</span>(<span style="color:#e6db74">&#34;poll called after completion&#34;</span>),
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="关键概念">关键概念
</h4><h6 id="1-零成本抽象">1. 零成本抽象
</h6><ul>
<li>异步代码在编译时转换为状态机</li>
<li>没有运行时开销，与手写的回调代码性能相当</li>
</ul>
<h6 id="2-执行器executor">2. 执行器(Executor)
</h6><ul>
<li>负责调度和执行Future</li>
<li>Tokio提供了高性能的执行器实现</li>
</ul>
<h6 id="3-waker机制">3. Waker机制
</h6><ul>
<li>当Future返回<code>Poll::Pending</code>时，会注册一个Waker</li>
<li>当Future可以继续执行时，通过Waker通知执行器</li>
</ul>
<h6 id="4-task与future">4. Task与Future
</h6><ul>
<li><code>Task</code>是执行单元，是Tokio调度的基本单位，负责执行一个顶层的Future到完成</li>
<li><code>Future</code>是计算单元，代表一个异步计算，一个Task可以包含多个嵌套的Future，这些嵌套的Future共享同一个Task的执行上下文。</li>
</ul>

</section>


    <footer class="article-footer">
    

    </footer>


    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2025 zed的博客
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.30.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.0640c0f9745d7bd65b558574cdb67852b46437c1f807526bf043aebc566fd6e4.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
