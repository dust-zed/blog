<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Rust on zed的博客</title>
        <link>http://localhost:1313/rust/</link>
        <description>Recent content in Rust on zed的博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Mon, 13 Oct 2025 10:33:08 +0800</lastBuildDate><atom:link href="http://localhost:1313/rust/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Benchmark学习</title>
        <link>http://localhost:1313/rust/benchmark%E5%AD%A6%E4%B9%A0/</link>
        <pubDate>Mon, 13 Oct 2025 10:33:08 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/benchmark%E5%AD%A6%E4%B9%A0/</guid>
        <description>&lt;h4 id=&#34;benchmark核心&#34;&gt;benchmark核心
&lt;/h4&gt;&lt;p&gt;所有语言的&lt;strong&gt;Benchmark&lt;/strong&gt;都在做：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计时 - 测量执行时间&lt;/li&gt;
&lt;li&gt;重复 - 多次运行取平均&lt;/li&gt;
&lt;li&gt;统计 - 计算均值、标准差&lt;/li&gt;
&lt;li&gt;对比 - 比较不同实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;通用流程&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;预热 → 测量 → 统计 → 报告 （防优化）
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;预热&lt;/strong&gt;: 跳过缓存未命中的初测&lt;/p&gt;
&lt;h4 id=&#34;criterion&#34;&gt;Criterion
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Criterion&lt;/code&gt;是rust中最现代化的benchmark库，接下来跟着例子一步步深入了benchmark。&lt;/p&gt;
&lt;h4 id=&#34;入门&#34;&gt;入门
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#![allow(unused)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; criterion::{black_box, criterion_group, criterion_main, Criterion};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; mycrate::fibonacci;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;criterion_benchmark&lt;/span&gt;(c: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Criterion) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    c.bench_function(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fib 20&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;b&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; b.iter(&lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; fibonacci(black_box(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;))));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;criterion_group!&lt;/span&gt;(benches, criterion_benchmark);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;criterion_main!&lt;/span&gt;(benches);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;1-bench_function方法&#34;&gt;1. &lt;code&gt;bench_function&lt;/code&gt;方法
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;c.bench_function(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fib 20&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;b&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; b.iter(&lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; fibonacci(black_box(&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;))));
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：定义一个基准测试用例&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参数&lt;/strong&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fib 20&lt;/code&gt;： 测试用例的名称（用于结果报告）&lt;/li&gt;
&lt;li&gt;闭包函数：包含实际的测试逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;闭包内部&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt;:   &lt;code&gt;Bencher&lt;/code&gt;对象(自动传入)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b.iter(|| ...)&lt;/code&gt;：运行被测代码多次并测量时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;black_box(20)&lt;/code&gt;：阻止编译器优化(确保真实计算)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fibonacci(20)&lt;/code&gt;：实际被测函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2-criterion_group宏&#34;&gt;2. &lt;code&gt;criterion_group!&lt;/code&gt;宏
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;criterion_group!&lt;/span&gt;(benches, criterion_benchmark);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：创建基准测试组&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参数&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;benches&lt;/code&gt;：组名称（自定义标识符）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;criterion_benchmark&lt;/code&gt;：包含测试的函数名（本例中的基准函数）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特性&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;将多个基准测试组织成组&lt;/li&gt;
&lt;li&gt;支持添加多个测试函数&lt;/li&gt;
&lt;li&gt;生成对应的 &lt;code&gt;bench_&lt;/code&gt; 开头的函数（如&lt;code&gt;benches_benchmark&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;3-criterion_main宏&#34;&gt;3. &lt;code&gt;criterion_main!&lt;/code&gt;宏
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;criterion_main!&lt;/span&gt;(benches);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：生成基准测试的入口函数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参数&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;benches&lt;/code&gt;：前面定义的测试组名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;自动生成&lt;code&gt;main()&lt;/code&gt;函数&lt;/li&gt;
&lt;li&gt;配置并运行所有指定的测试组&lt;/li&gt;
&lt;li&gt;处理命令行参数（如 &lt;code&gt;--filter&lt;/code&gt;, &lt;code&gt;--savebaseline&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;4-benches的来源&#34;&gt;4. &lt;code&gt;benches&lt;/code&gt;的来源
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;criterion_group!&lt;/span&gt;(benches, &lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;.);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//             ^^^^^^ 这里定义
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;criterion_main!&lt;/span&gt;(benches);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//             ^^^^^^ 这里使用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;benches&lt;/code&gt; 是由 &lt;code&gt;criterion_group!&lt;/code&gt; &lt;strong&gt;宏创建的自定义标识符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;criterion_main!&lt;/code&gt; 中引用时：
&lt;ol&gt;
&lt;li&gt;查找同名测试组&lt;/li&gt;
&lt;li&gt;将组内测试函数添加到执行队列&lt;/li&gt;
&lt;li&gt;生成报告和图表&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;进阶&#34;&gt;进阶
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 使用 benchmark_group 组织测试
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; group &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c.benchmark_group(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;data_structures&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;group.sample_size(&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;);  &lt;span style=&#34;color:#75715e&#34;&gt;// 配置采样
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;group.measurement_time(Duration::from_secs(&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ... 多个相关测试
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;group.finish();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;benchmark_group方法&#34;&gt;&lt;code&gt;benchmark_group&lt;/code&gt;方法
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;作用： 创建共享配置的容器，作为多个相关测试的配置载体&lt;/li&gt;
&lt;li&gt;必须被包含在 &lt;code&gt;criterion_group!&lt;/code&gt; 注册的测试函数中，并由其调度执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;理解统计输出&#34;&gt;理解统计输出
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;time:   &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;123.45 µs 125.67 µs 128.90 µs&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ↑          ↑          ↑
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      下界      中位数       上界
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;change: &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;-5.23% +2.34% +10.23%&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ↑        ↑       ↑
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      最好    预期变化  最坏
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Found &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; outliers among &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt; measurements
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; high mild    ← 稍微偏高
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; high severe  ← 严重偏高
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;例子&#34;&gt;例子
&lt;/h4&gt;&lt;h5 id=&#34;1-参数化测试&#34;&gt;1. 参数化测试
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 测试不同输入大小
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; group &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c.benchmark_group(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;fibonacci&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;25&lt;/span&gt;].iter() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    group.bench_with_input(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        BenchmarkId::from_parameter(i),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        i,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;b, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; b.iter(&lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; fibonacci(black_box(i)))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    );
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;group.finish();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;2-对比多个实现&#34;&gt;2. 对比多个实现
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; group &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c.benchmark_group(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;sum&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;group.bench_function(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;for_loop&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;b&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    b.iter(&lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; sum_for_loop(black_box(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;data)))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;group.bench_function(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;iterator&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;b&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    b.iter(&lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; sum_iterator(black_box(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;data)))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;group.finish();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;吞吐量测量&#34;&gt;吞吐量测量
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; group &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c.benchmark_group(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;throughput&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 设置吞吐量单位
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;group.throughput(Throughput::Bytes(data.len() &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;u64&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;group.bench_function(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;process&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;b&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    b.iter(&lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; process(black_box(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;data)))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 报告会显示 MB/s
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;自定义配置&#34;&gt;自定义配置
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;group.sample_size(&lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;);              &lt;span style=&#34;color:#75715e&#34;&gt;// 样本数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;group.warm_up_time(Duration::from_secs(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;));  &lt;span style=&#34;color:#75715e&#34;&gt;// 预热时间
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;group.measurement_time(Duration::from_secs(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)); &lt;span style=&#34;color:#75715e&#34;&gt;// 测量时间
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;group.noise_threshold(&lt;span style=&#34;color:#ae81ff&#34;&gt;0.05&lt;/span&gt;);          &lt;span style=&#34;color:#75715e&#34;&gt;// 噪音阈值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>Rust中经典实现</title>
        <link>http://localhost:1313/rust/rust%E4%B8%AD%E7%BB%8F%E5%85%B8%E5%AE%9E%E7%8E%B0/</link>
        <pubDate>Sat, 11 Oct 2025 23:40:18 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/rust%E4%B8%AD%E7%BB%8F%E5%85%B8%E5%AE%9E%E7%8E%B0/</guid>
        <description></description>
        </item>
        <item>
        <title>PhantomData的作用</title>
        <link>http://localhost:1313/rust/phantomdata%E7%9A%84%E4%BD%9C%E7%94%A8/</link>
        <pubDate>Fri, 19 Sep 2025 10:20:18 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/phantomdata%E7%9A%84%E4%BD%9C%E7%94%A8/</guid>
        <description>&lt;p&gt;&lt;code&gt;PhantomData&lt;/code&gt;在Rust中是为泛型提供逻辑上的补充，它帮助编译器理解和验证泛型参数的使用方式。&lt;/p&gt;
&lt;h4 id=&#34;核心作用&#34;&gt;核心作用
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;PhantomData&lt;/code&gt;是一个零类型大小（ZST），它不会在运行时占用任何内存，但在编译期提供重要信息：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;类型标记&lt;/strong&gt;：告诉编译器“这个类型逻辑上拥有&lt;code&gt;T&lt;/code&gt;”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生命周期追踪&lt;/strong&gt;：帮组编译器验证生命周期的正确性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;变体控制&lt;/strong&gt;:影响泛型参数的协变/逆变行为&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Drop检查&lt;/strong&gt;：影响&lt;code&gt;Drop&lt;/code&gt;检查器的行为&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在&lt;code&gt;JoinHandle&amp;lt;T&amp;gt;&lt;/code&gt;中的具体作用&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;JoinHandle&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    raw: &lt;span style=&#34;color:#a6e22e&#34;&gt;RawTask&lt;/span&gt;,         &lt;span style=&#34;color:#75715e&#34;&gt;// 原始任务指针，不直接包含 T
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    _p: &lt;span style=&#34;color:#a6e22e&#34;&gt;PhantomData&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,   &lt;span style=&#34;color:#75715e&#34;&gt;// 逻辑上表示这个句柄拥有 T 的所有权
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里&lt;code&gt;PhantomData&amp;lt;T&amp;gt;&lt;/code&gt;表示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;所有权标记&lt;/strong&gt;: &lt;code&gt;JoinHandle&amp;lt;T&amp;gt;&lt;/code&gt;逻辑上“拥有”一个&lt;code&gt;T&lt;/code&gt;类型的值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类型关联&lt;/strong&gt;: 将&lt;code&gt;RawTask&lt;/code&gt;与返回类型&lt;code&gt;T&lt;/code&gt;关联起来&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Drop检查&lt;/strong&gt;： 确保当&lt;code&gt;JoinHandle&amp;lt;T&amp;gt;&lt;/code&gt;被drop时，&lt;code&gt;T&lt;/code&gt;的析构函数会被正确调用&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;其他常见使用场景&#34;&gt;其他常见使用场景
&lt;/h4&gt;&lt;h5 id=&#34;1-不安全的代码中标记所有权&#34;&gt;1. 不安全的代码中标记所有权：
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyPtr&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ptr: &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;u8&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  _marker: &lt;span style=&#34;color:#a6e22e&#34;&gt;PhantomData&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, &lt;span style=&#34;color:#75715e&#34;&gt;//逻辑上拥有T
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;2-生命周期标记&#34;&gt;2. 生命周期标记
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Slice&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;&amp;#39;a&lt;/span&gt;, T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    data: &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; T,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    len: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    _marker: &lt;span style=&#34;color:#a6e22e&#34;&gt;PhantomData&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;&amp;#39;a&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,  &lt;span style=&#34;color:#75715e&#34;&gt;// 表示包含对 T 的生命周期 &amp;#39;a 的引用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;3-变体控制&#34;&gt;3. 变体控制
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Producer&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    data: &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; (),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    _marker: &lt;span style=&#34;color:#a6e22e&#34;&gt;PhantomData&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt;() -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,  &lt;span style=&#34;color:#75715e&#34;&gt;// 使 T 协变
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;4-类型安全抽象&#34;&gt;4. 类型安全抽象
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Token&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    _private: &lt;span style=&#34;color:#a6e22e&#34;&gt;PhantomData&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,  &lt;span style=&#34;color:#75715e&#34;&gt;// 创建类型级别的标记
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;总结&#34;&gt;总结
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;PhantomData&lt;/code&gt;是Rust类型系统中一个强大工具，它允许在不实际存储值的情况下，表达类型之间的关系和约束。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>对Callback的理解</title>
        <link>http://localhost:1313/rust/%E5%AF%B9callback%E7%9A%84%E7%90%86%E8%A7%A3/</link>
        <pubDate>Fri, 12 Sep 2025 03:02:50 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/%E5%AF%B9callback%E7%9A%84%E7%90%86%E8%A7%A3/</guid>
        <description>&lt;p&gt;个人理解：回调的本质就是将函数作为参数传递，而函数 近似 &lt;strong&gt;操作&lt;/strong&gt;。所以, 有别于普通参数传递的是&lt;strong&gt;数据&lt;/strong&gt;，&lt;code&gt;Callback&lt;/code&gt;传递的是&lt;strong&gt;操作&lt;/strong&gt;或&lt;strong&gt;逻辑&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;优势&#34;&gt;优势
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;解耦&lt;/strong&gt;: 完成逻辑的分离,要&lt;strong&gt;做什么(调用者)&lt;strong&gt;与&lt;/strong&gt;何时做分离(被调用者)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存高效&lt;/strong&gt;：避免一次性加载所有数据到内存，特别适合处理流式数据或大量数据(例如避免放到集合在遍历)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;灵活性&lt;/strong&gt;：允许调用者自定义处理逻辑，提高代码复用性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实时处理&lt;/strong&gt;：数据可以立即处理，降低延迟&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源控制&lt;/strong&gt;：可以轻松实现提前终止、错误处理等控制流&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组合性&lt;/strong&gt;：可以方便地组合多个回调函数，实现复杂的数据处理管道&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件驱动&lt;/strong&gt;：天然适合事件驱动的编程模式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;接口一致性&lt;/strong&gt;：提供统一的接口处理不同类型的操作&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;控制反转&#34;&gt;控制反转
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;普通函数调用：调用者控制执行流程&lt;/li&gt;
&lt;li&gt;回调：被调用者决定何时执行操作&lt;/li&gt;
&lt;li&gt;控制权从调用者转移到被调用者&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>内存排序</title>
        <link>http://localhost:1313/rust/%E5%86%85%E5%AD%98%E6%8E%92%E5%BA%8F/</link>
        <pubDate>Mon, 08 Sep 2025 11:16:22 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/%E5%86%85%E5%AD%98%E6%8E%92%E5%BA%8F/</guid>
        <description>&lt;h4 id=&#34;1-为什么需要内存排序&#34;&gt;1. 为什么需要内存排序
&lt;/h4&gt;&lt;p&gt;在多线程编程中，编译器和处理器会进行各种优化(如指令重排序)来提供性能。内存排序定义了这些优化在多线程环境中的行为。&lt;/p&gt;
&lt;h4 id=&#34;rust中的内存排序级别&#34;&gt;Rust中的内存排序级别
&lt;/h4&gt;&lt;p&gt;Rust通过&lt;code&gt;std::sync::atomic::Ordering&lt;/code&gt;提供了几种内存排序级别：&lt;/p&gt;
&lt;h5 id=&#34;21-relaxed&#34;&gt;2.1 Relaxed
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;最弱的内存排序&lt;/li&gt;
&lt;li&gt;只保证当前操作的原子性&lt;/li&gt;
&lt;li&gt;不保证操作之间的顺序&lt;/li&gt;
&lt;li&gt;适用场景：简单的计数器、统计信息&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::sync::atomic::{AtomicUsize, Ordering};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; counter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; AtomicUsize::new(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;counter.fetch_add(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, Ordering::Relaxed);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;22-release和acquire&#34;&gt;2.2 Release和Acquire
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Release&lt;/code&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;写屏障&lt;/strong&gt;，确保Release操作之前的所有内存操作（读/写）都完成&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可见性保证&lt;/strong&gt;，确保这些修改对其他线程可见&lt;/li&gt;
&lt;li&gt;发布数据到共享内存，标记数据准备就绪&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Acquire&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;读屏障&lt;/strong&gt;：确保在Acquire操作之后的所有内存操作（读/写）都能看到之前Release操作的所有修改&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可见性保证&lt;/strong&gt;：确保看到其他线程Release操作之前的所有修改&lt;/li&gt;
&lt;li&gt;从共享内存读取数据，检查数据是否就绪&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;23-acqrel&#34;&gt;2.3 AcqRel
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;组合语义，同时具有&lt;code&gt;Release&lt;/code&gt;和&lt;code&gt;Acquire&lt;/code&gt;的语义&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;24-seqcst&#34;&gt;2.4 Seqcst
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;最强保证&lt;/strong&gt;：除了&lt;code&gt;Acquire/Release&lt;/code&gt;外，还保证全局一致性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;额外保证&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;所有线程看到的操作顺序一致，所有线程看到的操作顺序是一致的
&lt;ul&gt;
&lt;li&gt;要么看到 (3) -&amp;gt; (1) -&amp;gt; (4) -&amp;gt; (2)&lt;/li&gt;
&lt;li&gt;要么看到 (1) -&amp;gt; (3) -&amp;gt; (2) -&amp;gt; (4)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;建立全局操作顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;小结&#34;&gt;小结
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Relaxed&lt;/code&gt;是只针对原子变量的，其他内存排序是针对共享内存的，充当着内存屏障的作用。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>普通对象和trait对象</title>
        <link>http://localhost:1313/rust/%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E5%92%8Ctrait%E5%AF%B9%E8%B1%A1/</link>
        <pubDate>Fri, 05 Sep 2025 18:49:07 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E5%92%8Ctrait%E5%AF%B9%E8%B1%A1/</guid>
        <description>&lt;h4 id=&#34;普通对象的内存结构&#34;&gt;普通对象的内存结构
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;只包含数据成员&lt;/li&gt;
&lt;li&gt;方法不占用内存空间&lt;/li&gt;
&lt;li&gt;方法调用是静态分发的，方法存储在代码段中，调用时直接跳转到固定地址&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Point&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  x: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  y: &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;///内存结构
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+------+------+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; x: &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; y: &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 8 字节 (i32 是 4 字节)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+------+------+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;trait对象内存结构&#34;&gt;trait对象内存结构
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;由两个指针组成
&lt;ul&gt;
&lt;li&gt;数据指针：指向实际数据的指针&lt;/li&gt;
&lt;li&gt;虚表指针：指向虚表的指针&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;虚表包含
&lt;ul&gt;
&lt;li&gt;析构函数指针&lt;/li&gt;
&lt;li&gt;类型大小和对齐信息&lt;/li&gt;
&lt;li&gt;trait中所有方法的函数指针&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;trait&lt;/span&gt; Shape {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;area&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;self) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;scale&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; self, factor: &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Circle&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    radius: &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Shape &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; Circle {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;area&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;self) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        std::&lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;::consts::&lt;span style=&#34;color:#66d9ef&#34;&gt;PI&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; self.radius &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; self.radius
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;scale&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; self, factor: &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self.radius &lt;span style=&#34;color:#f92672&#34;&gt;*=&lt;/span&gt; factor;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; circle: Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;dyn&lt;/span&gt; Shape&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Box::new(Circle { radius: &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt; });
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;内存布局&#34;&gt;内存布局
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+------------------+&lt;/span&gt;     &lt;span style=&#34;color:#f92672&#34;&gt;+------------------+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;数据指针&lt;/span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;-&amp;gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; radius: &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+------------------+&lt;/span&gt;     &lt;span style=&#34;color:#f92672&#34;&gt;+------------------+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;虚表指针&lt;/span&gt;          &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;-&amp;gt; &lt;span style=&#34;color:#f92672&#34;&gt;+------------------+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+------------------+&lt;/span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;指向&lt;/span&gt; Circle &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;的虚表&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#f92672&#34;&gt;+------------------+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                        &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; drop_in_place    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 析构函数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                        &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; size             &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 类型大小
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                        &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; align            &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 对齐方式
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                        &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; area() &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;函数指针&lt;/span&gt;   &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 第一个 trait 方法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                        &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; scale() &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;函数指针&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 第二个 trait 方法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                        &lt;span style=&#34;color:#f92672&#34;&gt;+------------------+&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;方法调用过程&#34;&gt;方法调用过程
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;普通对象方法&lt;/strong&gt;: 普通对象方法存储在代码段中，不占用对象内存，调用时直接跳转到固定地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;trait对象方法&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;获取虚表指针&lt;/li&gt;
&lt;li&gt;从虚表中获取函数指针&lt;/li&gt;
&lt;li&gt;调用函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Rust中基础网络编程</title>
        <link>http://localhost:1313/rust/rust%E4%B8%AD%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
        <pubDate>Fri, 05 Sep 2025 02:04:09 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/rust%E4%B8%AD%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid>
        <description>&lt;h3 id=&#34;rust-网络编程基础tcp-与-udp&#34;&gt;Rust 网络编程基础：TCP 与 UDP
&lt;/h3&gt;&lt;h4 id=&#34;tcp-与-udp-基础概念&#34;&gt;TCP 与 UDP 基础概念
&lt;/h4&gt;&lt;h5 id=&#34;tcp-传输控制协议&#34;&gt;TCP (传输控制协议)
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;面向连接&lt;/strong&gt;：通信前需要建立连接，使用 &lt;code&gt;TcpStream&lt;/code&gt; 表示连接&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可靠性&lt;/strong&gt;：保证数据按序到达，自动处理丢包重传&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流式协议&lt;/strong&gt;：数据没有明确边界，需要应用层处理消息分帧&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流量控制&lt;/strong&gt;：内置流量控制和拥塞控制机制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;适用场景&lt;/strong&gt;：文件传输、网页浏览、电子邮件等需要可靠传输的场景&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;udp-用户数据报协议&#34;&gt;UDP (用户数据报协议)
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;无连接&lt;/strong&gt;：每个数据包独立发送，使用 &lt;code&gt;UdpSocket&lt;/code&gt; 进行通信&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不可靠&lt;/strong&gt;：不保证数据包顺序和可达性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据报&lt;/strong&gt;：每个数据包有明确边界&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;低延迟&lt;/strong&gt;：没有连接建立和确认开销&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;适用场景&lt;/strong&gt;：实时音视频、在线游戏、DNS 查询等对延迟敏感的应用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rust-中的-tcp-编程&#34;&gt;Rust 中的 TCP 编程
&lt;/h3&gt;&lt;h4 id=&#34;服务端&#34;&gt;服务端
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; tokio::net::{TcpListener, TcpStream};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;server&lt;/span&gt;(addr: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;str&lt;/span&gt;) -&amp;gt; Result&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;(), Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;dyn&lt;/span&gt; std::error::Error&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; listener &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; TcpListener::bind(addr).&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;println!&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Server listening on &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, addr);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;loop&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; stream, addr) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; listener.accept().&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;println!&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Client connected from: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, addr);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 为每个连接创建新任务
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        tokio::spawn(&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;move&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;// 处理连接
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            handle_connection(stream).&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;客户端&#34;&gt;客户端
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; tokio::net::TcpStream;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;client&lt;/span&gt;(addr: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;str&lt;/span&gt;) -&amp;gt; Result&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;(), Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;dyn&lt;/span&gt; std::error::Error&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; stream &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; TcpStream::connect(addr).&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;println!&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Connected to server at &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, addr);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 发送和接收数据...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    Ok(())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;rust-中的-udp-编程&#34;&gt;Rust 中的 UDP 编程
&lt;/h3&gt;&lt;h4 id=&#34;服务端-1&#34;&gt;服务端
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; tokio::net::UdpSocket;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;server&lt;/span&gt;(addr: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;str&lt;/span&gt;) -&amp;gt; Result&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;(), Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;dyn&lt;/span&gt; std::error::Error&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; socket &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; UdpSocket::bind(addr).&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;println!&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;UDP server listening on &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, addr);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; buf &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;vec!&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;u8&lt;/span&gt;; &lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;loop&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (len, addr) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; socket.recv_from(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; buf).&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;println!&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Received &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; bytes from &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, len, addr);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 处理数据并回复
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        socket.send_to(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;buf[&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len], &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;addr).&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;客户端-1&#34;&gt;客户端
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; tokio::net::UdpSocket;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::net::SocketAddr;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;client&lt;/span&gt;(server_addr: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;str&lt;/span&gt;) -&amp;gt; Result&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;(), Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;dyn&lt;/span&gt; std::error::Error&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 绑定到任意可用端口
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; bind_addr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; server_addr.contains(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;:&amp;#39;&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;[::]:0&amp;#34;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// IPv6
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0.0.0.0:0&amp;#34;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// IPv4
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; socket &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; UdpSocket::bind(bind_addr).&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; server_addr: &lt;span style=&#34;color:#a6e22e&#34;&gt;SocketAddr&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; server_addr.parse()&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 可选：连接到服务器地址，之后可以使用 send/recv 而非 send_to/recv_from
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    socket.connect(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;server_addr).&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 发送数据
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    socket.send(&lt;span style=&#34;color:#e6db74&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello, UDP!&amp;#34;&lt;/span&gt;).&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 接收响应
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; buf &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;u8&lt;/span&gt;; &lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; socket.recv(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; buf).&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;println!&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Received: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, String::from_utf8_lossy(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;buf[&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;len]));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Ok(())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;关键区别总结&#34;&gt;关键区别总结
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;连接处理&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP 需要显式接受连接 (&lt;code&gt;accept&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;UDP 直接发送/接收数据报&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据边界&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP 是流式协议，需要应用层处理消息边界&lt;/li&gt;
&lt;li&gt;UDP 保持消息边界，每个 &lt;code&gt;recv_from&lt;/code&gt; 对应一个完整的消息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可靠性&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP 保证可靠传输&lt;/li&gt;
&lt;li&gt;UDP 不保证，需要应用层处理丢包和乱序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;性能&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP 有连接建立和确认开销&lt;/li&gt;
&lt;li&gt;UDP 延迟更低，适合实时应用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;端口和连接&#34;&gt;端口和连接
&lt;/h4&gt;&lt;h5 id=&#34;1-监听端口&#34;&gt;1. 监听端口
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;一个端口只能被一个进程监听&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2-连接与端口的关系&#34;&gt;2. 连接与端口的关系
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;一个端口可以承载多个连接&lt;/li&gt;
&lt;li&gt;每个连接由四元组唯一标识
&lt;ul&gt;
&lt;li&gt;源IP&lt;/li&gt;
&lt;li&gt;源端口&lt;/li&gt;
&lt;li&gt;目标IP&lt;/li&gt;
&lt;li&gt;目标端口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;套接字与连接&#34;&gt;套接字与连接
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;每个Tcp连接对应一个唯一的套接字&lt;/li&gt;
&lt;li&gt;监听套接字负责接受新连接&lt;/li&gt;
&lt;li&gt;已连接套接字处理具体的传输&lt;/li&gt;
&lt;li&gt;Tcp的“有连接”本质是指&lt;strong&gt;通信双方维护共同的状态信息&lt;/strong&gt;，而Udp的“无连接”是指&lt;strong&gt;每个数据包都是独立处理的&lt;/strong&gt;，不依赖之前的通信状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;选择建议&#34;&gt;选择建议
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;选择 TCP 当：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;需要可靠的数据传输&lt;/li&gt;
&lt;li&gt;数据传输的完整性比实时性更重要&lt;/li&gt;
&lt;li&gt;传输大量数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择 UDP 当：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;低延迟比可靠性更重要&lt;/li&gt;
&lt;li&gt;可以容忍少量数据丢失&lt;/li&gt;
&lt;li&gt;需要广播或多播功能&lt;/li&gt;
&lt;li&gt;传输小数据包且频繁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两种协议各有优势，选择哪种取决于您的具体应用需求。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>为何抽象</title>
        <link>http://localhost:1313/rust/%E4%B8%BA%E4%BD%95%E6%8A%BD%E8%B1%A1/</link>
        <pubDate>Wed, 03 Sep 2025 22:56:23 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/%E4%B8%BA%E4%BD%95%E6%8A%BD%E8%B1%A1/</guid>
        <description>&lt;h4 id=&#34;抽象的核心目的&#34;&gt;抽象的核心目的
&lt;/h4&gt;&lt;p&gt;抽象的主要目的是&lt;strong&gt;管理变化&lt;/strong&gt;，具体来说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;识别变化点&lt;/strong&gt;：确定哪些部分可能会变化&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;隔离变化&lt;/strong&gt;：将变化限制在局部&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;统一接口&lt;/strong&gt;：为不同的实现提供一致的交互方式&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;抽象的核心价值&#34;&gt;抽象的核心价值
&lt;/h4&gt;&lt;p&gt;在变化中寻求平衡稳定&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;稳定层&lt;/strong&gt;：抽象定义“做什么”（接口/契约）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;变化层&lt;/strong&gt;：实现处理“怎么做”（具体细节）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;solid原则&#34;&gt;SOLID原则
&lt;/h4&gt;&lt;h5 id=&#34;1-单一职责原则&#34;&gt;1. 单一职责原则
&lt;/h5&gt;&lt;p&gt;一个类应该只有一个引起它变化的原因&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个类应该只负责一项职责&lt;/li&gt;
&lt;li&gt;将不同的功能分离到不同的类中&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2-开闭原则&#34;&gt;2. 开闭原则
&lt;/h5&gt;&lt;p&gt;软件实体（类、模块、函数等）应该对扩展开放，对修改关闭&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过添加新代码开扩展功能，而不是修改现有代码&lt;/li&gt;
&lt;li&gt;使用抽象来定义契约&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;3-里氏替换原则&#34;&gt;3. 里氏替换原则
&lt;/h5&gt;&lt;p&gt;子类型必须能够替换其父类型而不影响程序的正确性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子类应该扩展父类的行为，而不是改变它&lt;/li&gt;
&lt;li&gt;子类不应该加强前置条件或削弱后置条件&lt;/li&gt;
&lt;li&gt;子类不应该抛出父类不会抛出的异常&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;4-接口隔离原则&#34;&gt;4. 接口隔离原则
&lt;/h5&gt;&lt;p&gt;客户端不应该被迫依赖他们不使用的接口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将大接口拆分为更小、更具体的接口&lt;/li&gt;
&lt;li&gt;类不应该实现他们不需要的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;5-依赖倒置&#34;&gt;5. 依赖倒置
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;高层模块&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;→&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;依赖&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;→&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;抽象接口&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;←&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;实现&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;←&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;低层模块&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
        </item>
        <item>
        <title>Rust知识问答</title>
        <link>http://localhost:1313/rust/rust%E7%9F%A5%E8%AF%86%E9%97%AE%E7%AD%94/</link>
        <pubDate>Mon, 01 Sep 2025 17:16:28 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/rust%E7%9F%A5%E8%AF%86%E9%97%AE%E7%AD%94/</guid>
        <description>&lt;h5 id=&#34;为什么fnonce只能调用一次&#34;&gt;为什么FnOnce只能调用一次
&lt;/h5&gt;&lt;h6 id=&#34;源码分析&#34;&gt;源码分析
&lt;/h6&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;trait&lt;/span&gt; FnOnce&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Args&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Output&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;rust-call&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;call_once&lt;/span&gt;(self, args: &lt;span style=&#34;color:#a6e22e&#34;&gt;Args&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Self&lt;/span&gt;::Output;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;self&lt;/code&gt;的含义
&lt;ul&gt;
&lt;li&gt;接收实现了&lt;code&gt;FnOnce&lt;/code&gt;的具体类型的值&lt;/li&gt;
&lt;li&gt;这个值会被移动(move)进方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h6 id=&#34;具体例子&#34;&gt;具体例子
&lt;/h6&gt;&lt;p&gt;假设我们有一个闭包:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; String::from(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; f &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;println!&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, s);  &lt;span style=&#34;color:#75715e&#34;&gt;// 获取 s 的所有权
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    s.len()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当这个闭包实现&lt;code&gt;FnOnce&lt;/code&gt;时&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 编译器生成的代码类似这样：
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Closure&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    s: String,  &lt;span style=&#34;color:#75715e&#34;&gt;// 捕获的环境变量
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; FnOnce&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;()&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; Closure {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Output&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;call_once&lt;/span&gt;(self, _args: ()) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;println!&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, self.s);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self.s.len()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h6 id=&#34;调用示例&#34;&gt;调用示例
&lt;/h6&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; f();  &lt;span style=&#34;color:#75715e&#34;&gt;// 等价于 FnOnce::call_once(f, ())
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 这里不能再调用 f()，因为 f 已经被移动
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最终f所有权被转移进&lt;code&gt;call_once&lt;/code&gt;，并随着call_once的结束而&lt;code&gt;drop&lt;/code&gt;了，f被释放了，内部捕获的所有权自然也被释放。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FnOnce&lt;/code&gt;、&lt;code&gt;FnMut&lt;/code&gt;、&lt;code&gt;Fn&lt;/code&gt;这些是根据如何捕获环境而区分的，并不影响函数签名，&lt;code&gt;FnMut&lt;/code&gt;也可以接收&lt;strong&gt;所有权参数&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&#34;什么是零成本抽象&#34;&gt;什么是零成本抽象
&lt;/h5&gt;&lt;p&gt;零成本抽象的核心就是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;编译期完成工作&lt;/strong&gt;：类型检查、泛型单态化、内联优化等在编译时完成&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;零运行时开销&lt;/strong&gt;：不引入额外的运行时检查或间接调用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无额外内存分配&lt;/strong&gt;：避免不必要的堆分配，尽可能使用栈内存&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;透明优化&lt;/strong&gt;：高级抽象在编译后生成的机器码与手写底层代码相当&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这正是 Rust 能在提供高级语言特性的同时，仍能保持与 C/C++ 相媲美的性能的关键所在。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>文件系统</title>
        <link>http://localhost:1313/rust/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link>
        <pubDate>Mon, 01 Sep 2025 17:12:26 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid>
        <description>&lt;h4 id=&#34;文件系统&#34;&gt;文件系统
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;metadata&lt;/code&gt;:本质上就是描述文件信息的数据&lt;/li&gt;
&lt;li&gt;环境变量和配置文件
&lt;ul&gt;
&lt;li&gt;配置文件：存储&lt;strong&gt;默认配置&lt;/strong&gt;或&lt;strong&gt;静态配置&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;环境变量：提供&lt;strong&gt;动态覆盖&lt;/strong&gt;或&lt;strong&gt;环境特定配置&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;挂载（Mount）&lt;/strong&gt;： 将&lt;strong&gt;存储设备&lt;/strong&gt;或&lt;strong&gt;文件系统&lt;/strong&gt;连接到操作系统目录树中特定位置的过程。这个连接点称为&lt;strong&gt;挂载点（Mount Point）&lt;/strong&gt;。类比门和仓库的关系。&lt;/li&gt;
&lt;li&gt;文件设备号&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>架构设计</title>
        <link>http://localhost:1313/rust/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</link>
        <pubDate>Mon, 01 Sep 2025 17:05:55 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</guid>
        <description>&lt;h4 id=&#34;如何做好职责分离&#34;&gt;如何做好职责分离
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;从“怎么实现”到“怎么组合”
&lt;ul&gt;
&lt;li&gt;一体式思维：写一个函数完成所有功能&lt;/li&gt;
&lt;li&gt;分离式思维：要设计几个组件，然后组合它们实现功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;从“功能优先”到“测试优先”
&lt;ul&gt;
&lt;li&gt;一体式思维：先实现功能，再考虑测试&lt;/li&gt;
&lt;li&gt;分离式思维：先考虑怎么测试，倒推出职责分离&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ripgrep&lt;/code&gt;的分离式架构
&lt;ul&gt;
&lt;li&gt;cli参数 → &lt;code&gt;LowArgs&lt;/code&gt; → &lt;code&gt;HiArgs&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;搜索目标：分为文件发现和目标搜索&lt;/li&gt;
&lt;li&gt;文件遍历再次分离：WalkDir（负责目录树形结构转为线性的Iter）→ WalkEventDir（负责发送事件）→ Walk（添加忽略规则）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>语法速查</title>
        <link>http://localhost:1313/rust/%E8%AF%AD%E6%B3%95%E9%80%9F%E6%9F%A5/</link>
        <pubDate>Mon, 01 Sep 2025 16:22:39 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/%E8%AF%AD%E6%B3%95%E9%80%9F%E6%9F%A5/</guid>
        <description>&lt;h4 id=&#34;集合或迭代器&#34;&gt;集合或迭代器
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;drain()&lt;/code&gt;方法：核心功能是移除集合中指定范围的元素，同时保持集合的连续性，是一种比**多次调用remove()**更高效的批量处理方式&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;所有权&#34;&gt;所有权
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;所有权&lt;/strong&gt;和&lt;strong&gt;可变性&lt;/strong&gt;是独立的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;所有权完整性&lt;/strong&gt;保护针对集合
&lt;ul&gt;
&lt;li&gt;集合需要保证所有元素位置有效&lt;/li&gt;
&lt;li&gt;集合在内存中是连续的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;结构体允许&lt;strong&gt;字段被转移走所有权&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;结构体字段具有独立性，布局在编译时可知&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;所有者离开作用域，值将被丢弃&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;变量和类型&#34;&gt;变量和类型
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ref&lt;/code&gt;和&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;amp;用于创建引用&lt;/li&gt;
&lt;li&gt;&amp;amp;用于模式匹配时，行使的是解构操作（一般作用是隐式解引用）&lt;/li&gt;
&lt;li&gt;ref用于模式匹配，获取引用而不是获取所有权&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&#39;a : &#39;b&lt;/code&gt;表示 &lt;code&gt;&#39;a&lt;/code&gt;  &amp;gt;= &lt;code&gt;&#39;b&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;T: &#39;static&lt;/code&gt;:表示类型&lt;strong&gt;T内部字段&lt;/strong&gt;要么没有引用，要么引用都是&lt;code&gt;&#39;static&lt;/code&gt;的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;trait My Trait: &#39;static&lt;/code&gt;或&lt;code&gt;Box&amp;lt;dyn MyTrait + &#39;static&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;实现类型&lt;/strong&gt;必须满足：&lt;code&gt;Self: &#39;static&lt;/code&gt;或者没有引用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(PathBuf, Path)&lt;/code&gt;、&lt;code&gt;(String, str)&lt;/code&gt;和&lt;code&gt;(BytesMut/Vec&amp;lt;u8&amp;gt;, &amp;amp;[u8]&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Path，str都是DST类型&lt;/li&gt;
&lt;li&gt;PathBuf和String都是拥有所有权的&lt;/li&gt;
&lt;li&gt;文件路径长度和字符串长度在编译时未知&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;buf&lt;/code&gt;和&lt;code&gt;&amp;amp;buf[..]&lt;/code&gt;的区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;buf&lt;/code&gt;获取整个数组的引用，类型是&lt;code&gt;&amp;amp;[u8; N]&lt;/code&gt;或&lt;code&gt;&amp;amp;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;（固定大小数组）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;buf[..]&lt;/code&gt;获取数组的切片引用，类型是&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;（动态大小切片）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;格式化输出语法&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{[&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;参数索引&lt;/span&gt;]:[&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;填充字符&lt;/span&gt;][&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;对齐方式&lt;/span&gt;][&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;宽度&lt;/span&gt;][.&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;精度&lt;/span&gt;][&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;类型&lt;/span&gt;]}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;fmt::Formatter&lt;/code&gt;是一个功能强大的格式化缓冲区，可以输出到字符串、stdout、文件等&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;结构体&#34;&gt;结构体
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Rust不允许将struct中某个字段标记为可变&lt;/li&gt;
&lt;li&gt;Rust中源文件（&lt;code&gt;.rs&lt;/code&gt;）隐性的视为一个模块，区别于&lt;code&gt;mod&lt;/code&gt;的显式声明&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;闭包&#34;&gt;闭包
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;根据闭包捕获环境方式可分为三种，注意区分闭包 &lt;strong&gt;捕获的环境变量&lt;/strong&gt;和&lt;strong&gt;闭包的参数&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FnOnce&lt;/code&gt;获取所有权&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FnMut&lt;/code&gt;获取可变引用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Fn&lt;/code&gt;获取不可变引用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;并发编程&#34;&gt;并发编程
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;并发编程主要有两种核心范式：&lt;strong&gt;共享状态并发&lt;/strong&gt;和&lt;strong&gt;消息传递并发&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::thread::scope&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;相当于&lt;code&gt;thread::spwan&lt;/code&gt; + &lt;code&gt;thread::join&lt;/code&gt;，但是它们只能借用&lt;code&gt;&#39;static&lt;/code&gt;或者&lt;code&gt;move&lt;/code&gt;变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scope&lt;/code&gt;没有以上限制，有编译器的支持&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mutex&lt;/code&gt;和&lt;code&gt;MutexGuard&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Mutex&lt;/code&gt;是互斥锁本身&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MutexGuard&lt;/code&gt;指访问受互斥锁保护数据的“许可证”或“钥匙”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;park()/unpark&lt;/code&gt;和&lt;code&gt;sleep()&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;park()/unpark()&lt;/code&gt;精准的控制线程的睡眠（park）与唤醒（unpark）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sleep()&lt;/code&gt;基于时间自动唤醒，无法提前唤醒&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Rust中的IO操作</title>
        <link>http://localhost:1313/rust/rust%E4%B8%AD%E7%9A%84io%E6%93%8D%E4%BD%9C/</link>
        <pubDate>Fri, 22 Aug 2025 06:01:17 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/rust%E4%B8%AD%E7%9A%84io%E6%93%8D%E4%BD%9C/</guid>
        <description>&lt;p&gt;在Rust中，I/O操作主要通过&lt;code&gt;Read&lt;/code&gt;和&lt;code&gt;Write&lt;/code&gt;两个核心trait实现，而&lt;code&gt;Cursor&lt;/code&gt;、&lt;code&gt;BufWriter&lt;/code&gt;和&lt;code&gt;ReadBuf&lt;/code&gt;是围绕这些trait的实用工具。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;1-read和write-trait&#34;&gt;1. &lt;code&gt;Read&lt;/code&gt;和&lt;code&gt;Write&lt;/code&gt; trait
&lt;/h4&gt;&lt;h5 id=&#34;stdioread&#34;&gt;&lt;code&gt;std::io::Read&lt;/code&gt;
&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;：从数据源（文件、网络等）读取字节流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心方法&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;read&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; self, buf: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; [&lt;span style=&#34;color:#66d9ef&#34;&gt;u8&lt;/span&gt;]) -&amp;gt; Result&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;尝试读取数据到缓冲区&lt;code&gt;buf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;返回实际读取的字节数(&lt;code&gt;Ok(n)&lt;/code&gt;)，或错误（&lt;code&gt;Err(e)&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;当读取到EOF时返回&lt;code&gt;Ok(0)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;常用方法&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;read_to_end(&amp;amp;mut vec)&lt;/code&gt;:读取所有字节到&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read_to_string(&amp;amp;mut string)&lt;/code&gt;:读取UTF-8字节到&lt;code&gt;String&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read_exact(&amp;amp;mut buf)&lt;/code&gt;:精确读取&lt;code&gt;buf.len()&lt;/code&gt;字节，否则报错&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;stdiowrite&#34;&gt;&lt;code&gt;std::io::Write&lt;/code&gt;
&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;：将字节流写入目标&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心方法&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;write&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; self, buf: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;u8&lt;/span&gt;]) -&amp;gt; Result&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;flush&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; self) -&amp;gt; Result&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;()&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;write&lt;/code&gt;尝试写入缓冲区&lt;code&gt;buf&lt;/code&gt;，返回实际写入的字节数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flush&lt;/code&gt;确保所有缓冲数据写入目标（如磁盘）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;2-cursort&#34;&gt;2. &lt;code&gt;Cursor&amp;lt;T&amp;gt;&lt;/code&gt;
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;：将内存类型包装成可&lt;code&gt;随机访问&lt;/code&gt;的&lt;code&gt;Read&lt;/code&gt;/&lt;code&gt;Write&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在内存中模拟文件指针（维护&lt;code&gt;position&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;实现Read和Write（需&lt;code&gt;T: AsMut&amp;lt;[u8]&amp;gt;&lt;/code&gt;)，支持&lt;code&gt;Seek&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;零成本抽象，高性能内存操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;使用场景&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;读取数据，或写入到&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;测试时代替真实文件I/O。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3-bufwriterw&#34;&gt;3. &lt;code&gt;BufWriter&amp;lt;W&amp;gt;&lt;/code&gt;
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;：包装一个&lt;code&gt;Write&lt;/code&gt;对象，提供&lt;strong&gt;写入缓冲&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少系统调用（如磁盘、网络写入）。&lt;/li&gt;
&lt;li&gt;批量写入提高性能（默认缓冲区大小&lt;strong&gt;8KB&lt;/strong&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;行为&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先写入内存缓冲区，满时自动刷新到内部&lt;code&gt;W&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;手动调用&lt;code&gt;flush()&lt;/code&gt;或&lt;code&gt;Drop&lt;/code&gt;时强制刷新缓冲区。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;4-bufreaderr&#34;&gt;4. &lt;code&gt;BufReader&amp;lt;R&amp;gt;&lt;/code&gt;
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;：包装&lt;code&gt;Read&lt;/code&gt;对象，提供&lt;strong&gt;读取缓冲&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少频繁系统调用（如读取文件时多次小数据读取）&lt;/li&gt;
&lt;li&gt;支持按行读取（&lt;code&gt;read_line&lt;/code&gt;和&lt;code&gt;lines&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;完整知识图谱&#34;&gt;完整知识图谱
&lt;/h4&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;I/O 核心 Trait
│
├── Read (字节源)
│   ├── 实现类型：File, TcpStream, Vec&amp;lt;u8&amp;gt;, etc.
│   ├── 工具：BufReader (缓冲读取), Take (限制读取长度)
│   └── 扩展：BufRead (提供 read_line, lines 等方法)
│
├── Write (字节目标)
│   ├── 实现类型：File, TcpStream, Vec&amp;lt;u8&amp;gt;, etc.
│   └── 工具：BufWriter (缓冲写入), LineWriter (行缓冲)
│
├── Seek (随机访问)
│   └── 实现类型：File, Cursor&amp;lt;T&amp;gt;
│
└── 内存适配器
    └── Cursor&amp;lt;T&amp;gt; (内存模拟 I/O)
        ├── 支持：Read/Write/Seek
        └── 适用：Vec&amp;lt;u8&amp;gt;, &amp;amp;[u8], String, &amp;amp;str
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h5 id=&#34;关键原则&#34;&gt;关键原则
&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;1. 缓冲使用&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BufReader/BufWriter总是推荐用于文件/网络 I/O。&lt;/li&gt;
&lt;li&gt;Cursor用于内存数据（如解析二进制格式）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 错误处理&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有I/O操作返回&lt;code&gt;Result&lt;/code&gt;，必须处理&lt;code&gt;Err&lt;/code&gt;情况。&lt;/li&gt;
&lt;li&gt;特别注意&lt;code&gt;flush()&lt;/code&gt;的错误（如磁盘满）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3. 性能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;小数据写入用&lt;code&gt;BufWriter&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;避免频繁小数据读取（缓冲或批量化）&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>大端序和小端序</title>
        <link>http://localhost:1313/rust/%E5%A4%A7%E7%AB%AF%E5%BA%8F%E5%92%8C%E5%B0%8F%E7%AB%AF%E5%BA%8F/</link>
        <pubDate>Fri, 22 Aug 2025 03:33:16 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/%E5%A4%A7%E7%AB%AF%E5%BA%8F%E5%92%8C%E5%B0%8F%E7%AB%AF%E5%BA%8F/</guid>
        <description>&lt;p&gt;大端序和小端序是两种不同的&lt;strong&gt;字节存储顺序&lt;/strong&gt;，用于描述多字节数据（如整数、浮点数）在计算机内存中的存储方式。它们的区别在于字节的排列顺序：&lt;/p&gt;
&lt;h4 id=&#34;大端序&#34;&gt;大端序
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;高位字节存储在低地址&lt;/strong&gt;，低位字节存储在高地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;小端序&#34;&gt;小端序
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;低位字节存储在低地址&lt;/strong&gt;，高位字节存储在高地址&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;小端序更符合计算机的处理逻辑&lt;/p&gt;
</description>
        </item>
        <item>
        <title>需要多熟悉的rust语法</title>
        <link>http://localhost:1313/rust/%E9%9C%80%E8%A6%81%E5%A4%9A%E7%86%9F%E6%82%89%E7%9A%84rust%E8%AF%AD%E6%B3%95/</link>
        <pubDate>Tue, 19 Aug 2025 15:02:39 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/%E9%9C%80%E8%A6%81%E5%A4%9A%E7%86%9F%E6%82%89%E7%9A%84rust%E8%AF%AD%E6%B3%95/</guid>
        <description>&lt;h4 id=&#34;绑定运算符&#34;&gt;@(绑定运算符)
&lt;/h4&gt;&lt;p&gt;在Rust中，&lt;code&gt;@&lt;/code&gt;被称为绑定运算符，用于在模式匹配的值绑定到一个变量，同时允许进一步解构内部结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体解析&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;match&lt;/span&gt; self.reader.read(buf) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Ok(len) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    self.size &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; len;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Ok(len)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  err &lt;span style=&#34;color:#f92672&#34;&gt;@&lt;/span&gt; Err(_) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; err
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;Ok(len)&lt;/code&gt;分支&lt;/strong&gt;：匹配成功的&lt;code&gt;Ok&lt;/code&gt;变体，提取内部的&lt;code&gt;len&lt;/code&gt;值，然后更新&lt;code&gt;self.size&lt;/code&gt;并返回&lt;code&gt;Ok(len)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;**&lt;code&gt;err @ Err(_)&lt;/code&gt;**分支：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Err(_)&lt;/code&gt;匹配任意&lt;code&gt;Err&lt;/code&gt;变体(不关心内部错误的具体值)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@&lt;/code&gt;将整个Err的值(如&lt;code&gt;Err(&amp;quot;io_error&amp;quot;)&lt;/code&gt;)绑定到变量&lt;code&gt;err&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;分支返回&lt;code&gt;err&lt;/code&gt;，即原始的&lt;code&gt;Err&lt;/code&gt;值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;解构默认会发生所有权转移，&lt;code&gt;let Data(inner) = &amp;amp;data;&lt;/code&gt;等价于&lt;code&gt;let Data(ref inner) = &amp;amp;data;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;asref&#34;&gt;AsRef
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;AsRef&lt;/code&gt; trait的核心作用是允许一个类型以&lt;strong&gt;零开销&lt;/strong&gt;的方式将自己或引用转换成&lt;strong&gt;另一种类型的引用&lt;/strong&gt;。&lt;code&gt;AsMut&lt;/code&gt;是&lt;code&gt;AsRef&lt;/code&gt;的可变版本&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 核心机制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AsRef&amp;lt;T&amp;gt;&lt;/code&gt;定义了一个方法：&lt;code&gt;fn as_ref(&amp;amp;self) -&amp;gt; &amp;amp;T&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;它接受&lt;code&gt;&amp;amp;self&lt;/code&gt;，返回目标类型&lt;code&gt;&amp;amp;T&lt;/code&gt;的引用&lt;/li&gt;
&lt;li&gt;本质上：将&lt;code&gt;&amp;amp;Self&lt;/code&gt;转换为&lt;code&gt;&amp;amp;T&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 转换类型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;允许的是&lt;code&gt;Self&lt;/code&gt;到&lt;code&gt;T&lt;/code&gt;的引用转换。&lt;/li&gt;
&lt;li&gt;例如：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;String&lt;/code&gt;实现&lt;code&gt;AsRef&amp;lt;str&amp;gt;&lt;/code&gt;: &lt;code&gt;&amp;amp;String -&amp;gt; &amp;amp;str&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 实现&lt;code&gt;AsRef&amp;lt;[T]&amp;gt;&lt;/code&gt;: &lt;code&gt;&amp;amp;Vec&amp;lt;T&amp;gt; -&amp;gt;&amp;amp;[T]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PathBuf&lt;/code&gt;实现&lt;code&gt;AsRef&amp;lt;Path&amp;gt;&lt;/code&gt;: &lt;code&gt;&amp;amp;PathBuf -&amp;gt; &amp;amp;Path&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;**3. 设计目的 **&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;泛型灵活性：让函数接受多种类型参数&lt;/li&gt;
&lt;li&gt;零开销抽象：转换过程无额外堆分配或复制&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;零开销&#34;&gt;零开销
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;什么是零开销&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈操作和微小的寄存器复制是允许的&lt;/li&gt;
&lt;li&gt;没有&lt;strong&gt;堆内存分配&lt;/strong&gt;：绝不调用内存分配器&lt;/li&gt;
&lt;li&gt;没有&lt;strong&gt;深拷贝&lt;/strong&gt;：不复制底层数据本身（即使是栈上的解构也需要合理区分）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;切片引用&#34;&gt;切片引用
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;切片引用本质就是宽指针&lt;/strong&gt;，由&lt;strong&gt;数据指针&lt;/strong&gt;和&lt;strong&gt;长度&lt;/strong&gt;组成&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;condvar&#34;&gt;Condvar
&lt;/h4&gt;&lt;p&gt;在rust中，&lt;code&gt;Condvar&lt;/code&gt;（条件变量）是用于线程间同步的核心工具，通常与&lt;code&gt;Mutex&lt;/code&gt;结合使用。它的核心功能是让线程在某个条件不满足时&lt;strong&gt;主动阻塞&lt;/strong&gt;，直到其他线程修改条件并通知它继续执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作用：解决线程间的&lt;strong&gt;等待-通知&lt;/strong&gt;问题，避免busy looping。&lt;/li&gt;
&lt;li&gt;依赖：必须与&lt;code&gt;Mutex&lt;/code&gt;配合使用（保护共享数据 + 同步条件）&lt;/li&gt;
&lt;li&gt;典型场景：生产者-消费者模型、任务队列调度、资源池管理等。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::sync::{Arc, Mutex, Condvar};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::thread;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;//创建共享数据结构：(Mutex&amp;lt;bool&amp;gt;, Condvar)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; pair &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Arc::new(Mutex::new(&lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;), Condvar::new()));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; pair_clone &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Arc::clone(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;pair);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; consumer &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; thread::spawn(&lt;span style=&#34;color:#66d9ef&#34;&gt;move&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (lock, cvar) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;*&lt;/span&gt;pair_clone;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; condition &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lock.lock().unwarp();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//等条件满足
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!*&lt;/span&gt;condition {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#75715e&#34;&gt;//释放锁并阻塞，被唤醒后(wait返回后)重新获取锁
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      condition &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cvar.wait(condition).unwarp();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;println!&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;消费者：条件已满足！继续执行&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//消费者的处理逻辑
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	thread::sleep(Duration::from_secs(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;));&lt;span style=&#34;color:#75715e&#34;&gt;//模拟工作耗时
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  	&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (lock, cvar) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;*&lt;/span&gt;pair;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; condition &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lock.lock().unwarp();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;println!&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;生产者：更新条件并通知消费者...&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;condition &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 通知一个等待的消费者线程
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    cvar.notify_one();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	consumer.join().unwrap();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;println!&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;主线程: 所有线程执行完成&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h4 id=&#34;pin&#34;&gt;PIN
&lt;/h4&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;haystack&lt;/code&gt;&lt;strong&gt;命名源自英语谚语&lt;/strong&gt;&amp;ldquo;looking for a needle in a haystack&amp;rdquo;&lt;/strong&gt;(大海捞针),&lt;code&gt;haystack&lt;/code&gt;表示被搜索的&lt;strong&gt;主体数据&lt;/strong&gt;，&lt;code&gt;needle&lt;/code&gt;表示待查找的&lt;strong&gt;目标元素&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;rust中有两种解引用的方式：&lt;strong&gt;&lt;code&gt;*&lt;/code&gt;&lt;strong&gt;和&lt;/strong&gt;模式匹配解引用&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;unicodeascii和utf-8等&#34;&gt;Unicode、ASCII和UTF-8等
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Unicode&lt;/strong&gt;为所有字符分配了唯一标识(称为&lt;strong&gt;码点&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UTF-8&lt;/strong&gt;等是需要将这些码点转换为用于存储/传输的&lt;strong&gt;字节序列&lt;/strong&gt;,根据&lt;strong&gt;码点值的范围分类&lt;/strong&gt;，确定字节序列的&lt;strong&gt;长度&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ASCII&lt;/strong&gt;是Unicode和UTF-8的&lt;strong&gt;特殊兼容子集&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;字符数据&#34;&gt;字符数据
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt;前缀标识的数据：表示&lt;code&gt;ASCII&lt;/code&gt;字符集的字节数据，类型为&lt;code&gt;u8&lt;/code&gt;或&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;和&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;：&lt;code&gt;&amp;amp;str&lt;/code&gt;是utf-8编码的切片引用且不可变，&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;是对原始字节的切片引用，可变版本是&lt;code&gt;&amp;amp;mut [u8]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;为什么可以手动调用dropx而不能调用xdrop&#34;&gt;为什么可以手动调用drop(x)而不能调用x.drop()
&lt;/h4&gt;&lt;p&gt;关键在于&lt;strong&gt;所有权&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::mem::drop&amp;lt;T&amp;gt;(_x: T)&lt;/code&gt;转移了所有权，_x离开drop函数作用域，&lt;strong&gt;自动触发析构逻辑&lt;/strong&gt;（调用&lt;code&gt;Drop::drop&lt;/code&gt; trait的实现）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;drop(&amp;amp;mut self)&lt;/code&gt;没有发生所有权的转移，如果允许手动调用&lt;code&gt;x.drop&lt;/code&gt;,编译期在作用域结束时仍会再次调用&lt;code&gt;drop&lt;/code&gt;，双重释放，导致内存安全问题。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Rust学习计划</title>
        <link>http://localhost:1313/rust/rust%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</link>
        <pubDate>Fri, 08 Aug 2025 11:37:40 +0800</pubDate>
        
        <guid>http://localhost:1313/rust/rust%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</guid>
        <description>&lt;h2 id=&#34;1-基础能力建设&#34;&gt;1. 基础能力建设
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Rust 语言精通&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;深入理解所有权、生命周期、trait 系统&lt;/li&gt;
&lt;li&gt;掌握 unsafe Rust 和 FFI&lt;/li&gt;
&lt;li&gt;研究标准库实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;算法与数据结构&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现常用数据结构和算法&lt;/li&gt;
&lt;li&gt;学习字符串搜索算法（Boyer-Moore, Aho-Corasick 等）&lt;/li&gt;
&lt;li&gt;理解时间/空间复杂度分析&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;系统编程&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;深入理解操作系统原理&lt;/li&gt;
&lt;li&gt;学习文件系统、内存管理、并发模型&lt;/li&gt;
&lt;li&gt;掌握性能分析和调优技术&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-工程实践&#34;&gt;2. 工程实践
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;开源贡献&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从修复小 bug 开始参与开源项目&lt;/li&gt;
&lt;li&gt;学习阅读和理解大型代码库&lt;/li&gt;
&lt;li&gt;参与代码审查，学习他人代码&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;代码质量&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编写全面的测试用例&lt;/li&gt;
&lt;li&gt;实践持续集成&lt;/li&gt;
&lt;li&gt;学习设计模式和架构原则&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;性能优化&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;学习使用性能分析工具（perf, dtrace 等）&lt;/li&gt;
&lt;li&gt;理解 CPU 缓存、分支预测等底层细节&lt;/li&gt;
&lt;li&gt;实践基准测试和性能调优&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-学习资源&#34;&gt;3. 学习资源
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;必读书籍&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《Rust 程序设计语言》&lt;/li&gt;
&lt;li&gt;《Rust 权威指南》&lt;/li&gt;
&lt;li&gt;《代码整洁之道》&lt;/li&gt;
&lt;li&gt;《深入理解计算机系统》&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;学习路径&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;graph TD
  A[Rust 基础] --&amp;gt; B[标准库实现]
  B --&amp;gt; C[开源项目贡献]
  C --&amp;gt; D[性能优化]
  D --&amp;gt; E[系统设计]
  E --&amp;gt; F[独立项目]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4-实践项目&#34;&gt;4. 实践项目
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;命令行工具&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现简单的 grep 功能&lt;/li&gt;
&lt;li&gt;添加正则表达式支持&lt;/li&gt;
&lt;li&gt;优化性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;并发处理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现工作窃取线程池&lt;/li&gt;
&lt;li&gt;学习无锁编程&lt;/li&gt;
&lt;li&gt;实现并行算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;性能优化&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 SIMD 指令优化字符串处理&lt;/li&gt;
&lt;li&gt;实现内存池&lt;/li&gt;
&lt;li&gt;优化 I/O 性能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-思维习惯&#34;&gt;5. 思维习惯
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;持续学习&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每天阅读优秀源码&lt;/li&gt;
&lt;li&gt;定期参与技术讨论&lt;/li&gt;
&lt;li&gt;写技术博客分享心得&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;代码审查&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;学习他人代码风格&lt;/li&gt;
&lt;li&gt;接受并理解批评&lt;/li&gt;
&lt;li&gt;不断重构和改进&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;问题解决&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;深入理解问题本质&lt;/li&gt;
&lt;li&gt;设计多种解决方案&lt;/li&gt;
&lt;li&gt;基准测试验证优化效果&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;6-具体行动建议&#34;&gt;6. 具体行动建议
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;每天花 1 小时阅读 Rust 标准库源码&lt;/li&gt;
&lt;li&gt;每周研究一个开源项目的架构设计&lt;/li&gt;
&lt;li&gt;每月完成一个具有挑战性的编程练习&lt;/li&gt;
&lt;li&gt;每季度参与一次开源贡献&lt;/li&gt;
&lt;li&gt;每年开发一个展示个人技术水平的项目&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;记住，成为顶尖开发者是场马拉松，而非短跑。保持耐心和持续学习的心态是关键。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;每日阅读-rust-标准库源码计划&#34;&gt;每日阅读 Rust 标准库源码计划
&lt;/h1&gt;&lt;p&gt;是的，借助 AI 阅读 Rust 标准库源码是个很好的学习方式。以下是一个具体的学习计划：&lt;/p&gt;
&lt;h2 id=&#34;学习策略&#34;&gt;学习策略
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;基础阶段（1-2周）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从简单的模块开始，如 &lt;code&gt;std::option&lt;/code&gt; 和 &lt;code&gt;std::result&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重点关注标准库中的 trait 实现和常用类型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;中级阶段（3-8周）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;研究集合类型：&lt;code&gt;Vec&lt;/code&gt;、&lt;code&gt;HashMap&lt;/code&gt;、&lt;code&gt;String&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;学习迭代器和闭包实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;高级阶段（9周+）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;并发原语：&lt;code&gt;Arc&lt;/code&gt;、&lt;code&gt;Mutex&lt;/code&gt;、&lt;code&gt;RwLock&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;异步运行时和 future 实现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;使用-ai-辅助学习&#34;&gt;使用 AI 辅助学习
&lt;/h2&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 示例：使用 AI 分析标准库代码
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 1. 选择要学习的模块
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; module &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;std::collections::hash_map&amp;#34;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 2. 让 AI 解释核心概念
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Q: 请解释 HashMap 的 robin hood hashing 实现
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Q: 这个 unsafe 块的作用是什么？
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 3. 做笔记和总结
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;take_notes&lt;/span&gt;(concept: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;str&lt;/span&gt;, examples: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;str&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 记录学习要点
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;每日学习流程&#34;&gt;每日学习流程
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;准备阶段（5分钟）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确定今天要学习的模块&lt;/li&gt;
&lt;li&gt;设置学习目标&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;核心学习（45分钟）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阅读源码（25分钟）&lt;/li&gt;
&lt;li&gt;使用 AI 解答疑问（15分钟）&lt;/li&gt;
&lt;li&gt;做笔记（5分钟）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;复习阶段（10分钟）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总结今日所学&lt;/li&gt;
&lt;li&gt;记录未解决的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;实用技巧&#34;&gt;实用技巧
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;使用 &lt;code&gt;rustup doc --std&lt;/code&gt; 查看本地文档&lt;/li&gt;
&lt;li&gt;在 playground 中编写测试代码&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;cargo-expand&lt;/code&gt; 查看宏展开&lt;/li&gt;
&lt;li&gt;关注标准库中的测试用例&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;推荐的学习顺序&#34;&gt;推荐的学习顺序
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;std::option&lt;/code&gt; 和 &lt;code&gt;std::result&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::iter&lt;/code&gt; 和迭代器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::collections&lt;/code&gt; 中的集合类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::sync&lt;/code&gt; 和 &lt;code&gt;std::thread&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::future&lt;/code&gt; 和异步编程&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;制定-rust-标准库学习目标的方法&#34;&gt;制定 Rust 标准库学习目标的方法
&lt;/h1&gt;&lt;h2 id=&#34;1-按模块划分目标&#34;&gt;1. 按模块划分目标
&lt;/h2&gt;&lt;h3 id=&#34;基础模块1-2周模块&#34;&gt;基础模块（1-2周/模块）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;std::option&lt;/code&gt; 和 &lt;code&gt;std::result&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理解 &lt;code&gt;Option&lt;/code&gt; 和 &lt;code&gt;Result&lt;/code&gt; 的实现&lt;/li&gt;
&lt;li&gt;学习组合子方法（&lt;a class=&#34;link&#34; href=&#34;cci:1://file:///Users/zed/ripgrep/crates/ignore/src/lib.rs:466:4-475:5&#34; &gt;map&lt;/a&gt;, &lt;a class=&#34;link&#34; href=&#34;cci:1://file:///Users/zed/ripgrep/crates/core/flags/parse.rs:41:4-52:5&#34; &gt;and_then&lt;/a&gt;, &lt;code&gt;unwrap_or&lt;/code&gt;等）&lt;/li&gt;
&lt;li&gt;目标：能解释为什么 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt; 在内存中与 &lt;code&gt;T&lt;/code&gt; 大小相同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;std::iter&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;理解 &lt;code&gt;Iterator&lt;/code&gt; trait 的设计&lt;/li&gt;
&lt;li&gt;学习常见迭代器适配器&lt;/li&gt;
&lt;li&gt;目标：能实现自定义迭代器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-按主题划分目标&#34;&gt;2. 按主题划分目标
&lt;/h2&gt;&lt;h3 id=&#34;所有权和生命周期2周&#34;&gt;所有权和生命周期（2周）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;研究 &lt;code&gt;std::mem&lt;/code&gt; 模块&lt;/li&gt;
&lt;li&gt;分析 &lt;code&gt;Box&lt;/code&gt;, &lt;code&gt;Rc&lt;/code&gt;, &lt;code&gt;Arc&lt;/code&gt; 的实现&lt;/li&gt;
&lt;li&gt;目标：能解释 Rust 的所有权系统如何影响标准库设计&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;并发编程3周&#34;&gt;并发编程（3周）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;学习 &lt;code&gt;std::sync&lt;/code&gt; 中的原语&lt;/li&gt;
&lt;li&gt;研究 &lt;code&gt;std::thread&lt;/code&gt; 和 &lt;code&gt;std::sync::mpsc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;目标：能解释 &lt;code&gt;Mutex&lt;/code&gt; 和 &lt;code&gt;RwLock&lt;/code&gt; 的区别和适用场景&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-smart-目标制定法&#34;&gt;3. SMART 目标制定法
&lt;/h2&gt;&lt;h3 id=&#34;具体-specific&#34;&gt;具体 (Specific)
&lt;/h3&gt;&lt;p&gt;❌ 模糊目标：学习集合类型
✅ 明确目标：理解 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; 的内存布局和扩容策略&lt;/p&gt;
&lt;h3 id=&#34;可衡量-measurable&#34;&gt;可衡量 (Measurable)
&lt;/h3&gt;&lt;p&gt;❌ 不明确：了解迭代器
✅ 可衡量：能实现3种不同的迭代器适配器&lt;/p&gt;
&lt;h3 id=&#34;可实现-achievable&#34;&gt;可实现 (Achievable)
&lt;/h3&gt;&lt;p&gt;❌ 不切实际：一周内掌握整个异步运行时
✅ 可实现：一周内理解 &lt;code&gt;Future&lt;/code&gt; trait 和基本的执行器原理&lt;/p&gt;
&lt;h3 id=&#34;相关性-relevant&#34;&gt;相关性 (Relevant)
&lt;/h3&gt;&lt;p&gt;❌ 不相关：学习网络协议实现（如果是为了理解集合类型）
✅ 相关：研究 &lt;code&gt;HashMap&lt;/code&gt; 的实现来理解 trait 约束&lt;/p&gt;
&lt;h3 id=&#34;有时限-time-bound&#34;&gt;有时限 (Time-bound)
&lt;/h3&gt;&lt;p&gt;❌ 无期限：某天学习错误处理
✅ 有时限：本周内完成 &lt;code&gt;std::error::Error&lt;/code&gt; trait 的学习&lt;/p&gt;
&lt;h2 id=&#34;4-示例学习计划&#34;&gt;4. 示例学习计划
&lt;/h2&gt;&lt;h3 id=&#34;第1周option-和-result&#34;&gt;第1周：&lt;code&gt;Option&lt;/code&gt; 和 &lt;code&gt;Result&lt;/code&gt;
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;周一：阅读 &lt;code&gt;Option&lt;/code&gt; 定义和基础方法&lt;/li&gt;
&lt;li&gt;周三：研究 &lt;code&gt;Option&lt;/code&gt; 的内存布局&lt;/li&gt;
&lt;li&gt;周五：&lt;code&gt;Result&lt;/code&gt; 和错误处理模式&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;第2周迭代器&#34;&gt;第2周：迭代器
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;周一：&lt;code&gt;Iterator&lt;/code&gt; trait 定义&lt;/li&gt;
&lt;li&gt;周三：常见适配器实现&lt;/li&gt;
&lt;li&gt;周五：自定义迭代器实践&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要我帮你制定一个具体的学习计划吗？或者你对某个特定主题更感兴趣？&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
