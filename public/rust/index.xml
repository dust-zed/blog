<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rust on zed的博客</title><link>https://www.dust-zed.site/rust/</link><description>Recent content in Rust on zed的博客</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 13 Oct 2025 10:33:08 +0800</lastBuildDate><atom:link href="https://www.dust-zed.site/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>Benchmark学习</title><link>https://www.dust-zed.site/rust/benchmark%E5%AD%A6%E4%B9%A0/</link><pubDate>Mon, 13 Oct 2025 10:33:08 +0800</pubDate><guid>https://www.dust-zed.site/rust/benchmark%E5%AD%A6%E4%B9%A0/</guid><description>&lt;h4 id="benchmark核心">benchmark核心
&lt;/h4>&lt;p>所有语言的&lt;strong>Benchmark&lt;/strong>都在做：&lt;/p>
&lt;ul>
&lt;li>计时 - 测量执行时间&lt;/li>
&lt;li>重复 - 多次运行取平均&lt;/li>
&lt;li>统计 - 计算均值、标准差&lt;/li>
&lt;li>对比 - 比较不同实现&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>通用流程&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>预热 → 测量 → 统计 → 报告 （防优化）
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>预热&lt;/strong>: 跳过缓存未命中的初测&lt;/p>
&lt;h4 id="criterion">Criterion
&lt;/h4>&lt;p>&lt;code>Criterion&lt;/code>是rust中最现代化的benchmark库，接下来跟着例子一步步深入了benchmark。&lt;/p>
&lt;h4 id="入门">入门
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#![allow(unused)]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> criterion::{black_box, criterion_group, criterion_main, Criterion};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> mycrate::fibonacci;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">criterion_benchmark&lt;/span>(c: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">mut&lt;/span> Criterion) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c.bench_function(&lt;span style="color:#e6db74">&amp;#34;fib 20&amp;#34;&lt;/span>, &lt;span style="color:#f92672">|&lt;/span>b&lt;span style="color:#f92672">|&lt;/span> b.iter(&lt;span style="color:#f92672">||&lt;/span> fibonacci(black_box(&lt;span style="color:#ae81ff">20&lt;/span>))));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">criterion_group!&lt;/span>(benches, criterion_benchmark);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">criterion_main!&lt;/span>(benches);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="1-bench_function方法">1. &lt;code>bench_function&lt;/code>方法
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>c.bench_function(&lt;span style="color:#e6db74">&amp;#34;fib 20&amp;#34;&lt;/span>, &lt;span style="color:#f92672">|&lt;/span>b&lt;span style="color:#f92672">|&lt;/span> b.iter(&lt;span style="color:#f92672">||&lt;/span> fibonacci(black_box(&lt;span style="color:#ae81ff">20&lt;/span>))));
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>作用&lt;/strong>：定义一个基准测试用例&lt;/li>
&lt;li>&lt;strong>参数&lt;/strong>:
&lt;ul>
&lt;li>&lt;code>fib 20&lt;/code>： 测试用例的名称（用于结果报告）&lt;/li>
&lt;li>闭包函数：包含实际的测试逻辑&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>闭包内部&lt;/strong>
&lt;ul>
&lt;li>&lt;code>b&lt;/code>: &lt;code>Bencher&lt;/code>对象(自动传入)&lt;/li>
&lt;li>&lt;code>b.iter(|| ...)&lt;/code>：运行被测代码多次并测量时间&lt;/li>
&lt;li>&lt;code>black_box(20)&lt;/code>：阻止编译器优化(确保真实计算)&lt;/li>
&lt;li>&lt;code>fibonacci(20)&lt;/code>：实际被测函数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="2-criterion_group宏">2. &lt;code>criterion_group!&lt;/code>宏
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">criterion_group!&lt;/span>(benches, criterion_benchmark);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>作用&lt;/strong>：创建基准测试组&lt;/li>
&lt;li>&lt;strong>参数&lt;/strong>：
&lt;ul>
&lt;li>&lt;code>benches&lt;/code>：组名称（自定义标识符）&lt;/li>
&lt;li>&lt;code>criterion_benchmark&lt;/code>：包含测试的函数名（本例中的基准函数）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>特性&lt;/strong>：
&lt;ul>
&lt;li>将多个基准测试组织成组&lt;/li>
&lt;li>支持添加多个测试函数&lt;/li>
&lt;li>生成对应的 &lt;code>bench_&lt;/code> 开头的函数（如&lt;code>benches_benchmark&lt;/code>）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="3-criterion_main宏">3. &lt;code>criterion_main!&lt;/code>宏
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">criterion_main!&lt;/span>(benches);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>作用&lt;/strong>：生成基准测试的入口函数&lt;/li>
&lt;li>&lt;strong>参数&lt;/strong>：
&lt;ul>
&lt;li>&lt;code>benches&lt;/code>：前面定义的测试组名&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>功能&lt;/strong>：
&lt;ul>
&lt;li>自动生成&lt;code>main()&lt;/code>函数&lt;/li>
&lt;li>配置并运行所有指定的测试组&lt;/li>
&lt;li>处理命令行参数（如 &lt;code>--filter&lt;/code>, &lt;code>--savebaseline&lt;/code>）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="4-benches的来源">4. &lt;code>benches&lt;/code>的来源
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">criterion_group!&lt;/span>(benches, &lt;span style="color:#f92672">..&lt;/span>.);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ^^^^^^ 这里定义
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">criterion_main!&lt;/span>(benches);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ^^^^^^ 这里使用
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>benches&lt;/code> 是由 &lt;code>criterion_group!&lt;/code> &lt;strong>宏创建的自定义标识符&lt;/strong>&lt;/li>
&lt;li>在 &lt;code>criterion_main!&lt;/code> 中引用时：
&lt;ol>
&lt;li>查找同名测试组&lt;/li>
&lt;li>将组内测试函数添加到执行队列&lt;/li>
&lt;li>生成报告和图表&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h4 id="进阶">进阶
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 使用 benchmark_group 组织测试
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> group &lt;span style="color:#f92672">=&lt;/span> c.benchmark_group(&lt;span style="color:#e6db74">&amp;#34;data_structures&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>group.sample_size(&lt;span style="color:#ae81ff">100&lt;/span>); &lt;span style="color:#75715e">// 配置采样
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>group.measurement_time(Duration::from_secs(&lt;span style="color:#ae81ff">5&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ... 多个相关测试
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>group.finish();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="benchmark_group方法">&lt;code>benchmark_group&lt;/code>方法
&lt;/h5>&lt;ul>
&lt;li>作用： 创建共享配置的容器，作为多个相关测试的配置载体&lt;/li>
&lt;li>必须被包含在 &lt;code>criterion_group!&lt;/code> 注册的测试函数中，并由其调度执行。&lt;/li>
&lt;/ul>
&lt;h4 id="理解统计输出">理解统计输出
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>time: &lt;span style="color:#f92672">[&lt;/span>123.45 µs 125.67 µs 128.90 µs&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ↑ ↑ ↑
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 下界 中位数 上界
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>change: &lt;span style="color:#f92672">[&lt;/span>-5.23% +2.34% +10.23%&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ↑ ↑ ↑
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 最好 预期变化 最坏
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Found &lt;span style="color:#ae81ff">3&lt;/span> outliers among &lt;span style="color:#ae81ff">100&lt;/span> measurements
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">2&lt;/span> high mild ← 稍微偏高
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span> high severe ← 严重偏高
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="例子">例子
&lt;/h4>&lt;h5 id="1-参数化测试">1. 参数化测试
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 测试不同输入大小
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> group &lt;span style="color:#f92672">=&lt;/span> c.benchmark_group(&lt;span style="color:#e6db74">&amp;#34;fibonacci&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#66d9ef">in&lt;/span> [&lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">15&lt;/span>, &lt;span style="color:#ae81ff">20&lt;/span>, &lt;span style="color:#ae81ff">25&lt;/span>].iter() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> group.bench_with_input(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BenchmarkId::from_parameter(i),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|&lt;/span>b, &lt;span style="color:#f92672">&amp;amp;&lt;/span>i&lt;span style="color:#f92672">|&lt;/span> b.iter(&lt;span style="color:#f92672">||&lt;/span> fibonacci(black_box(i)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>group.finish();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="2-对比多个实现">2. 对比多个实现
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> group &lt;span style="color:#f92672">=&lt;/span> c.benchmark_group(&lt;span style="color:#e6db74">&amp;#34;sum&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>group.bench_function(&lt;span style="color:#e6db74">&amp;#34;for_loop&amp;#34;&lt;/span>, &lt;span style="color:#f92672">|&lt;/span>b&lt;span style="color:#f92672">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b.iter(&lt;span style="color:#f92672">||&lt;/span> sum_for_loop(black_box(&lt;span style="color:#f92672">&amp;amp;&lt;/span>data)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>group.bench_function(&lt;span style="color:#e6db74">&amp;#34;iterator&amp;#34;&lt;/span>, &lt;span style="color:#f92672">|&lt;/span>b&lt;span style="color:#f92672">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b.iter(&lt;span style="color:#f92672">||&lt;/span> sum_iterator(black_box(&lt;span style="color:#f92672">&amp;amp;&lt;/span>data)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>group.finish();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="吞吐量测量">吞吐量测量
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> group &lt;span style="color:#f92672">=&lt;/span> c.benchmark_group(&lt;span style="color:#e6db74">&amp;#34;throughput&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 设置吞吐量单位
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>group.throughput(Throughput::Bytes(data.len() &lt;span style="color:#66d9ef">as&lt;/span> &lt;span style="color:#66d9ef">u64&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>group.bench_function(&lt;span style="color:#e6db74">&amp;#34;process&amp;#34;&lt;/span>, &lt;span style="color:#f92672">|&lt;/span>b&lt;span style="color:#f92672">|&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b.iter(&lt;span style="color:#f92672">||&lt;/span> process(black_box(&lt;span style="color:#f92672">&amp;amp;&lt;/span>data)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 报告会显示 MB/s
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="自定义配置">自定义配置
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>group.sample_size(&lt;span style="color:#ae81ff">1000&lt;/span>); &lt;span style="color:#75715e">// 样本数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>group.warm_up_time(Duration::from_secs(&lt;span style="color:#ae81ff">3&lt;/span>)); &lt;span style="color:#75715e">// 预热时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>group.measurement_time(Duration::from_secs(&lt;span style="color:#ae81ff">10&lt;/span>)); &lt;span style="color:#75715e">// 测量时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>group.noise_threshold(&lt;span style="color:#ae81ff">0.05&lt;/span>); &lt;span style="color:#75715e">// 噪音阈值
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>PhantomData的作用</title><link>https://www.dust-zed.site/rust/phantomdata%E7%9A%84%E4%BD%9C%E7%94%A8/</link><pubDate>Fri, 19 Sep 2025 10:20:18 +0800</pubDate><guid>https://www.dust-zed.site/rust/phantomdata%E7%9A%84%E4%BD%9C%E7%94%A8/</guid><description>&lt;p>&lt;code>PhantomData&lt;/code>在Rust中是为泛型提供逻辑上的补充，它帮助编译器理解和验证泛型参数的使用方式。&lt;/p>
&lt;h4 id="核心作用">核心作用
&lt;/h4>&lt;p>&lt;code>PhantomData&lt;/code>是一个零类型大小（ZST），它不会在运行时占用任何内存，但在编译期提供重要信息：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>类型标记&lt;/strong>：告诉编译器“这个类型逻辑上拥有&lt;code>T&lt;/code>”&lt;/li>
&lt;li>&lt;strong>生命周期追踪&lt;/strong>：帮组编译器验证生命周期的正确性&lt;/li>
&lt;li>&lt;strong>变体控制&lt;/strong>:影响泛型参数的协变/逆变行为&lt;/li>
&lt;li>&lt;strong>Drop检查&lt;/strong>：影响&lt;code>Drop&lt;/code>检查器的行为&lt;/li>
&lt;/ol>
&lt;p>在&lt;code>JoinHandle&amp;lt;T&amp;gt;&lt;/code>中的具体作用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">JoinHandle&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> raw: &lt;span style="color:#a6e22e">RawTask&lt;/span>, &lt;span style="color:#75715e">// 原始任务指针，不直接包含 T
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> _p: &lt;span style="color:#a6e22e">PhantomData&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span>, &lt;span style="color:#75715e">// 逻辑上表示这个句柄拥有 T 的所有权
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里&lt;code>PhantomData&amp;lt;T&amp;gt;&lt;/code>表示：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>所有权标记&lt;/strong>: &lt;code>JoinHandle&amp;lt;T&amp;gt;&lt;/code>逻辑上“拥有”一个&lt;code>T&lt;/code>类型的值&lt;/li>
&lt;li>&lt;strong>类型关联&lt;/strong>: 将&lt;code>RawTask&lt;/code>与返回类型&lt;code>T&lt;/code>关联起来&lt;/li>
&lt;li>&lt;strong>Drop检查&lt;/strong>： 确保当&lt;code>JoinHandle&amp;lt;T&amp;gt;&lt;/code>被drop时，&lt;code>T&lt;/code>的析构函数会被正确调用&lt;/li>
&lt;/ol>
&lt;h4 id="其他常见使用场景">其他常见使用场景
&lt;/h4>&lt;h5 id="1-不安全的代码中标记所有权">1. 不安全的代码中标记所有权：
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">MyPtr&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ptr: &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> &lt;span style="color:#66d9ef">u8&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _marker: &lt;span style="color:#a6e22e">PhantomData&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span>, &lt;span style="color:#75715e">//逻辑上拥有T
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="2-生命周期标记">2. 生命周期标记
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Slice&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#a6e22e">&amp;#39;a&lt;/span>, T&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> data: &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> T,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> len: &lt;span style="color:#66d9ef">usize&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _marker: &lt;span style="color:#a6e22e">PhantomData&lt;/span>&lt;span style="color:#f92672">&amp;lt;&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">&amp;#39;a&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>, &lt;span style="color:#75715e">// 表示包含对 T 的生命周期 &amp;#39;a 的引用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="3-变体控制">3. 变体控制
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Producer&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> data: &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> (),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _marker: &lt;span style="color:#a6e22e">PhantomData&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">fn&lt;/span>() -&amp;gt; &lt;span style="color:#a6e22e">T&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>, &lt;span style="color:#75715e">// 使 T 协变
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="4-类型安全抽象">4. 类型安全抽象
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Token&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _private: &lt;span style="color:#a6e22e">PhantomData&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span>, &lt;span style="color:#75715e">// 创建类型级别的标记
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="总结">总结
&lt;/h4>&lt;p>&lt;code>PhantomData&lt;/code>是Rust类型系统中一个强大工具，它允许在不实际存储值的情况下，表达类型之间的关系和约束。&lt;/p></description></item><item><title>对Callback的理解</title><link>https://www.dust-zed.site/rust/%E5%AF%B9callback%E7%9A%84%E7%90%86%E8%A7%A3/</link><pubDate>Fri, 12 Sep 2025 03:02:50 +0800</pubDate><guid>https://www.dust-zed.site/rust/%E5%AF%B9callback%E7%9A%84%E7%90%86%E8%A7%A3/</guid><description>&lt;p>个人理解：回调的本质就是将函数作为参数传递，而函数 近似 &lt;strong>操作&lt;/strong>。所以, 有别于普通参数传递的是&lt;strong>数据&lt;/strong>，&lt;code>Callback&lt;/code>传递的是&lt;strong>操作&lt;/strong>或&lt;strong>逻辑&lt;/strong>&lt;/p>
&lt;h4 id="优势">优势
&lt;/h4>&lt;ol>
&lt;li>&lt;strong>解耦&lt;/strong>: 完成逻辑的分离,要&lt;strong>做什么(调用者)&lt;strong>与&lt;/strong>何时做分离(被调用者)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>内存高效&lt;/strong>：避免一次性加载所有数据到内存，特别适合处理流式数据或大量数据(例如避免放到集合在遍历)&lt;/li>
&lt;li>&lt;strong>灵活性&lt;/strong>：允许调用者自定义处理逻辑，提高代码复用性&lt;/li>
&lt;li>&lt;strong>实时处理&lt;/strong>：数据可以立即处理，降低延迟&lt;/li>
&lt;li>&lt;strong>资源控制&lt;/strong>：可以轻松实现提前终止、错误处理等控制流&lt;/li>
&lt;li>&lt;strong>组合性&lt;/strong>：可以方便地组合多个回调函数，实现复杂的数据处理管道&lt;/li>
&lt;li>&lt;strong>事件驱动&lt;/strong>：天然适合事件驱动的编程模式&lt;/li>
&lt;li>&lt;strong>接口一致性&lt;/strong>：提供统一的接口处理不同类型的操作&lt;/li>
&lt;/ol>
&lt;h4 id="控制反转">控制反转
&lt;/h4>&lt;ul>
&lt;li>普通函数调用：调用者控制执行流程&lt;/li>
&lt;li>回调：被调用者决定何时执行操作&lt;/li>
&lt;li>控制权从调用者转移到被调用者&lt;/li>
&lt;/ul></description></item><item><title>内存排序</title><link>https://www.dust-zed.site/rust/%E5%86%85%E5%AD%98%E6%8E%92%E5%BA%8F/</link><pubDate>Mon, 08 Sep 2025 11:16:22 +0800</pubDate><guid>https://www.dust-zed.site/rust/%E5%86%85%E5%AD%98%E6%8E%92%E5%BA%8F/</guid><description>&lt;h4 id="1-为什么需要内存排序">1. 为什么需要内存排序
&lt;/h4>&lt;p>在多线程编程中，编译器和处理器会进行各种优化(如指令重排序)来提供性能。内存排序定义了这些优化在多线程环境中的行为。&lt;/p>
&lt;h4 id="rust中的内存排序级别">Rust中的内存排序级别
&lt;/h4>&lt;p>Rust通过&lt;code>std::sync::atomic::Ordering&lt;/code>提供了几种内存排序级别：&lt;/p>
&lt;h5 id="21-relaxed">2.1 Relaxed
&lt;/h5>&lt;ul>
&lt;li>最弱的内存排序&lt;/li>
&lt;li>只保证当前操作的原子性&lt;/li>
&lt;li>不保证操作之间的顺序&lt;/li>
&lt;li>适用场景：简单的计数器、统计信息&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> std::sync::atomic::{AtomicUsize, Ordering};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> counter &lt;span style="color:#f92672">=&lt;/span> AtomicUsize::new(&lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>counter.fetch_add(&lt;span style="color:#ae81ff">1&lt;/span>, Ordering::Relaxed);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="22-release和acquire">2.2 Release和Acquire
&lt;/h5>&lt;ul>
&lt;li>&lt;code>Release&lt;/code>：
&lt;ul>
&lt;li>&lt;strong>写屏障&lt;/strong>，确保Release操作之前的所有内存操作（读/写）都完成&lt;/li>
&lt;li>&lt;strong>可见性保证&lt;/strong>，确保这些修改对其他线程可见&lt;/li>
&lt;li>发布数据到共享内存，标记数据准备就绪&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>Acquire&lt;/code>
&lt;ul>
&lt;li>&lt;strong>读屏障&lt;/strong>：确保在Acquire操作之后的所有内存操作（读/写）都能看到之前Release操作的所有修改&lt;/li>
&lt;li>&lt;strong>可见性保证&lt;/strong>：确保看到其他线程Release操作之前的所有修改&lt;/li>
&lt;li>从共享内存读取数据，检查数据是否就绪&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="23-acqrel">2.3 AcqRel
&lt;/h5>&lt;ul>
&lt;li>组合语义，同时具有&lt;code>Release&lt;/code>和&lt;code>Acquire&lt;/code>的语义&lt;/li>
&lt;/ul>
&lt;h5 id="24-seqcst">2.4 Seqcst
&lt;/h5>&lt;ul>
&lt;li>&lt;strong>最强保证&lt;/strong>：除了&lt;code>Acquire/Release&lt;/code>外，还保证全局一致性&lt;/li>
&lt;li>&lt;strong>额外保证&lt;/strong>：
&lt;ul>
&lt;li>所有线程看到的操作顺序一致，所有线程看到的操作顺序是一致的
&lt;ul>
&lt;li>要么看到 (3) -&amp;gt; (1) -&amp;gt; (4) -&amp;gt; (2)&lt;/li>
&lt;li>要么看到 (1) -&amp;gt; (3) -&amp;gt; (2) -&amp;gt; (4)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>建立全局操作顺序&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h4 id="小结">小结
&lt;/h4>&lt;p>&lt;code>Relaxed&lt;/code>是只针对原子变量的，其他内存排序是针对共享内存的，充当着内存屏障的作用。&lt;/p></description></item><item><title>普通对象和trait对象</title><link>https://www.dust-zed.site/rust/%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E5%92%8Ctrait%E5%AF%B9%E8%B1%A1/</link><pubDate>Fri, 05 Sep 2025 18:49:07 +0800</pubDate><guid>https://www.dust-zed.site/rust/%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E5%92%8Ctrait%E5%AF%B9%E8%B1%A1/</guid><description>&lt;h4 id="普通对象的内存结构">普通对象的内存结构
&lt;/h4>&lt;ul>
&lt;li>只包含数据成员&lt;/li>
&lt;li>方法不占用内存空间&lt;/li>
&lt;li>方法调用是静态分发的，方法存储在代码段中，调用时直接跳转到固定地址&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Point&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x: &lt;span style="color:#66d9ef">i32&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> y: &lt;span style="color:#66d9ef">i32&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">///内存结构
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&lt;/span>&lt;span style="color:#f92672">+------+------+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">|&lt;/span> x: &lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#f92672">|&lt;/span> y: &lt;span style="color:#ae81ff">4&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#75715e">// 8 字节 (i32 是 4 字节)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">+------+------+&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="trait对象内存结构">trait对象内存结构
&lt;/h4>&lt;ul>
&lt;li>由两个指针组成
&lt;ul>
&lt;li>数据指针：指向实际数据的指针&lt;/li>
&lt;li>虚表指针：指向虚表的指针&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>虚表包含
&lt;ul>
&lt;li>析构函数指针&lt;/li>
&lt;li>类型大小和对齐信息&lt;/li>
&lt;li>trait中所有方法的函数指针&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">trait&lt;/span> Shape {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">area&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>self) -&amp;gt; &lt;span style="color:#66d9ef">f64&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">scale&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self, factor: &lt;span style="color:#66d9ef">f64&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Circle&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> radius: &lt;span style="color:#66d9ef">f64&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> Shape &lt;span style="color:#66d9ef">for&lt;/span> Circle {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">area&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>self) -&amp;gt; &lt;span style="color:#66d9ef">f64&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std::&lt;span style="color:#66d9ef">f64&lt;/span>::consts::&lt;span style="color:#66d9ef">PI&lt;/span> &lt;span style="color:#f92672">*&lt;/span> self.radius &lt;span style="color:#f92672">*&lt;/span> self.radius
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">scale&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self, factor: &lt;span style="color:#66d9ef">f64&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.radius &lt;span style="color:#f92672">*=&lt;/span> factor;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> circle: Box&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">dyn&lt;/span> Shape&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Box::new(Circle { radius: &lt;span style="color:#ae81ff">1.0&lt;/span> });
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="内存布局">内存布局
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">+------------------+&lt;/span> &lt;span style="color:#f92672">+------------------+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">数据指针&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#f92672">-&lt;/span>-&amp;gt; &lt;span style="color:#f92672">|&lt;/span> radius: &lt;span style="color:#66d9ef">f64&lt;/span> &lt;span style="color:#f92672">|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">+------------------+&lt;/span> &lt;span style="color:#f92672">+------------------+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">虚表指针&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#f92672">-&lt;/span>-&amp;gt; &lt;span style="color:#f92672">+------------------+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">+------------------+&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">指向&lt;/span> Circle &lt;span style="color:#960050;background-color:#1e0010">的虚表&lt;/span> &lt;span style="color:#f92672">|&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">+------------------+&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|&lt;/span> drop_in_place &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#75715e">// 析构函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">|&lt;/span> size &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#75715e">// 类型大小
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">|&lt;/span> align &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#75715e">// 对齐方式
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">|&lt;/span> area() &lt;span style="color:#960050;background-color:#1e0010">函数指针&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#75715e">// 第一个 trait 方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">|&lt;/span> scale() &lt;span style="color:#960050;background-color:#1e0010">函数指针&lt;/span> &lt;span style="color:#f92672">|&lt;/span> &lt;span style="color:#75715e">// 第二个 trait 方法
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">+------------------+&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="方法调用过程">方法调用过程
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>普通对象方法&lt;/strong>: 普通对象方法存储在代码段中，不占用对象内存，调用时直接跳转到固定地址。&lt;/li>
&lt;li>&lt;strong>trait对象方法&lt;/strong>：
&lt;ul>
&lt;li>获取虚表指针&lt;/li>
&lt;li>从虚表中获取函数指针&lt;/li>
&lt;li>调用函数&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Rust中基础网络编程</title><link>https://www.dust-zed.site/rust/rust%E4%B8%AD%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link><pubDate>Fri, 05 Sep 2025 02:04:09 +0800</pubDate><guid>https://www.dust-zed.site/rust/rust%E4%B8%AD%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid><description>&lt;h3 id="rust-网络编程基础tcp-与-udp">Rust 网络编程基础：TCP 与 UDP
&lt;/h3>&lt;h4 id="tcp-与-udp-基础概念">TCP 与 UDP 基础概念
&lt;/h4>&lt;h5 id="tcp-传输控制协议">TCP (传输控制协议)
&lt;/h5>&lt;ul>
&lt;li>&lt;strong>面向连接&lt;/strong>：通信前需要建立连接，使用 &lt;code>TcpStream&lt;/code> 表示连接&lt;/li>
&lt;li>&lt;strong>可靠性&lt;/strong>：保证数据按序到达，自动处理丢包重传&lt;/li>
&lt;li>&lt;strong>流式协议&lt;/strong>：数据没有明确边界，需要应用层处理消息分帧&lt;/li>
&lt;li>&lt;strong>流量控制&lt;/strong>：内置流量控制和拥塞控制机制&lt;/li>
&lt;li>&lt;strong>适用场景&lt;/strong>：文件传输、网页浏览、电子邮件等需要可靠传输的场景&lt;/li>
&lt;/ul>
&lt;h4 id="udp-用户数据报协议">UDP (用户数据报协议)
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>无连接&lt;/strong>：每个数据包独立发送，使用 &lt;code>UdpSocket&lt;/code> 进行通信&lt;/li>
&lt;li>&lt;strong>不可靠&lt;/strong>：不保证数据包顺序和可达性&lt;/li>
&lt;li>&lt;strong>数据报&lt;/strong>：每个数据包有明确边界&lt;/li>
&lt;li>&lt;strong>低延迟&lt;/strong>：没有连接建立和确认开销&lt;/li>
&lt;li>&lt;strong>适用场景&lt;/strong>：实时音视频、在线游戏、DNS 查询等对延迟敏感的应用&lt;/li>
&lt;/ul>
&lt;h3 id="rust-中的-tcp-编程">Rust 中的 TCP 编程
&lt;/h3>&lt;h4 id="服务端">服务端
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> tokio::net::{TcpListener, TcpStream};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">server&lt;/span>(addr: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">str&lt;/span>) -&amp;gt; Result&lt;span style="color:#f92672">&amp;lt;&lt;/span>(), Box&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">dyn&lt;/span> std::error::Error&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> listener &lt;span style="color:#f92672">=&lt;/span> TcpListener::bind(addr).&lt;span style="color:#66d9ef">await&lt;/span>&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">println!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Server listening on &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, addr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">loop&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> (&lt;span style="color:#66d9ef">mut&lt;/span> stream, addr) &lt;span style="color:#f92672">=&lt;/span> listener.accept().&lt;span style="color:#66d9ef">await&lt;/span>&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">println!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Client connected from: &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, addr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 为每个连接创建新任务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> tokio::spawn(&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">move&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 处理连接
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> handle_connection(stream).&lt;span style="color:#66d9ef">await&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="客户端">客户端
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> tokio::net::TcpStream;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">client&lt;/span>(addr: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">str&lt;/span>) -&amp;gt; Result&lt;span style="color:#f92672">&amp;lt;&lt;/span>(), Box&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">dyn&lt;/span> std::error::Error&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> stream &lt;span style="color:#f92672">=&lt;/span> TcpStream::connect(addr).&lt;span style="color:#66d9ef">await&lt;/span>&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">println!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Connected to server at &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, addr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 发送和接收数据...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Ok(())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="rust-中的-udp-编程">Rust 中的 UDP 编程
&lt;/h3>&lt;h4 id="服务端-1">服务端
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> tokio::net::UdpSocket;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">server&lt;/span>(addr: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">str&lt;/span>) -&amp;gt; Result&lt;span style="color:#f92672">&amp;lt;&lt;/span>(), Box&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">dyn&lt;/span> std::error::Error&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> socket &lt;span style="color:#f92672">=&lt;/span> UdpSocket::bind(addr).&lt;span style="color:#66d9ef">await&lt;/span>&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">println!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;UDP server listening on &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, addr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> buf &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">vec!&lt;/span>[&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#66d9ef">u8&lt;/span>; &lt;span style="color:#ae81ff">1024&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">loop&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> (len, addr) &lt;span style="color:#f92672">=&lt;/span> socket.recv_from(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> buf).&lt;span style="color:#66d9ef">await&lt;/span>&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">println!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Received &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74"> bytes from &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, len, addr);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 处理数据并回复
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> socket.send_to(&lt;span style="color:#f92672">&amp;amp;&lt;/span>buf[&lt;span style="color:#f92672">..&lt;/span>len], &lt;span style="color:#f92672">&amp;amp;&lt;/span>addr).&lt;span style="color:#66d9ef">await&lt;/span>&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="客户端-1">客户端
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> tokio::net::UdpSocket;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> std::net::SocketAddr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">client&lt;/span>(server_addr: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">str&lt;/span>) -&amp;gt; Result&lt;span style="color:#f92672">&amp;lt;&lt;/span>(), Box&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">dyn&lt;/span> std::error::Error&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 绑定到任意可用端口
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> bind_addr &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> server_addr.contains(&lt;span style="color:#e6db74">&amp;#39;:&amp;#39;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;[::]:0&amp;#34;&lt;/span> &lt;span style="color:#75715e">// IPv6
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;0.0.0.0:0&amp;#34;&lt;/span> &lt;span style="color:#75715e">// IPv4
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> socket &lt;span style="color:#f92672">=&lt;/span> UdpSocket::bind(bind_addr).&lt;span style="color:#66d9ef">await&lt;/span>&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> server_addr: &lt;span style="color:#a6e22e">SocketAddr&lt;/span> &lt;span style="color:#f92672">=&lt;/span> server_addr.parse()&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 可选：连接到服务器地址，之后可以使用 send/recv 而非 send_to/recv_from
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> socket.connect(&lt;span style="color:#f92672">&amp;amp;&lt;/span>server_addr).&lt;span style="color:#66d9ef">await&lt;/span>&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 发送数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> socket.send(&lt;span style="color:#e6db74">b&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Hello, UDP!&amp;#34;&lt;/span>).&lt;span style="color:#66d9ef">await&lt;/span>&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 接收响应
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> buf &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#66d9ef">u8&lt;/span>; &lt;span style="color:#ae81ff">1024&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> len &lt;span style="color:#f92672">=&lt;/span> socket.recv(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> buf).&lt;span style="color:#66d9ef">await&lt;/span>&lt;span style="color:#f92672">?&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">println!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Received: &lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, String::from_utf8_lossy(&lt;span style="color:#f92672">&amp;amp;&lt;/span>buf[&lt;span style="color:#f92672">..&lt;/span>len]));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Ok(())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="关键区别总结">关键区别总结
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>连接处理&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>TCP 需要显式接受连接 (&lt;code>accept&lt;/code>)&lt;/li>
&lt;li>UDP 直接发送/接收数据报&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>数据边界&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>TCP 是流式协议，需要应用层处理消息边界&lt;/li>
&lt;li>UDP 保持消息边界，每个 &lt;code>recv_from&lt;/code> 对应一个完整的消息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>可靠性&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>TCP 保证可靠传输&lt;/li>
&lt;li>UDP 不保证，需要应用层处理丢包和乱序&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>性能&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>TCP 有连接建立和确认开销&lt;/li>
&lt;li>UDP 延迟更低，适合实时应用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h4 id="端口和连接">端口和连接
&lt;/h4>&lt;h5 id="1-监听端口">1. 监听端口
&lt;/h5>&lt;ul>
&lt;li>一个端口只能被一个进程监听&lt;/li>
&lt;/ul>
&lt;h5 id="2-连接与端口的关系">2. 连接与端口的关系
&lt;/h5>&lt;ul>
&lt;li>一个端口可以承载多个连接&lt;/li>
&lt;li>每个连接由四元组唯一标识
&lt;ul>
&lt;li>源IP&lt;/li>
&lt;li>源端口&lt;/li>
&lt;li>目标IP&lt;/li>
&lt;li>目标端口&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="套接字与连接">套接字与连接
&lt;/h5>&lt;ul>
&lt;li>每个Tcp连接对应一个唯一的套接字&lt;/li>
&lt;li>监听套接字负责接受新连接&lt;/li>
&lt;li>已连接套接字处理具体的传输&lt;/li>
&lt;li>Tcp的“有连接”本质是指&lt;strong>通信双方维护共同的状态信息&lt;/strong>，而Udp的“无连接”是指&lt;strong>每个数据包都是独立处理的&lt;/strong>，不依赖之前的通信状态。&lt;/li>
&lt;/ul>
&lt;h3 id="选择建议">选择建议
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>选择 TCP 当：&lt;/p>
&lt;ul>
&lt;li>需要可靠的数据传输&lt;/li>
&lt;li>数据传输的完整性比实时性更重要&lt;/li>
&lt;li>传输大量数据&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>选择 UDP 当：&lt;/p>
&lt;ul>
&lt;li>低延迟比可靠性更重要&lt;/li>
&lt;li>可以容忍少量数据丢失&lt;/li>
&lt;li>需要广播或多播功能&lt;/li>
&lt;li>传输小数据包且频繁&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>这两种协议各有优势，选择哪种取决于您的具体应用需求。&lt;/p></description></item><item><title>为何抽象</title><link>https://www.dust-zed.site/rust/%E4%B8%BA%E4%BD%95%E6%8A%BD%E8%B1%A1/</link><pubDate>Wed, 03 Sep 2025 22:56:23 +0800</pubDate><guid>https://www.dust-zed.site/rust/%E4%B8%BA%E4%BD%95%E6%8A%BD%E8%B1%A1/</guid><description>&lt;h4 id="抽象的核心目的">抽象的核心目的
&lt;/h4>&lt;p>抽象的主要目的是&lt;strong>管理变化&lt;/strong>，具体来说：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>识别变化点&lt;/strong>：确定哪些部分可能会变化&lt;/li>
&lt;li>&lt;strong>隔离变化&lt;/strong>：将变化限制在局部&lt;/li>
&lt;li>&lt;strong>统一接口&lt;/strong>：为不同的实现提供一致的交互方式&lt;/li>
&lt;/ol>
&lt;h4 id="抽象的核心价值">抽象的核心价值
&lt;/h4>&lt;p>在变化中寻求平衡稳定&lt;/p>
&lt;ul>
&lt;li>&lt;strong>稳定层&lt;/strong>：抽象定义“做什么”（接口/契约）&lt;/li>
&lt;li>&lt;strong>变化层&lt;/strong>：实现处理“怎么做”（具体细节）&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h4 id="solid原则">SOLID原则
&lt;/h4>&lt;h5 id="1-单一职责原则">1. 单一职责原则
&lt;/h5>&lt;p>一个类应该只有一个引起它变化的原因&lt;/p>
&lt;ul>
&lt;li>每个类应该只负责一项职责&lt;/li>
&lt;li>将不同的功能分离到不同的类中&lt;/li>
&lt;/ul>
&lt;h5 id="2-开闭原则">2. 开闭原则
&lt;/h5>&lt;p>软件实体（类、模块、函数等）应该对扩展开放，对修改关闭&lt;/p>
&lt;ul>
&lt;li>通过添加新代码开扩展功能，而不是修改现有代码&lt;/li>
&lt;li>使用抽象来定义契约&lt;/li>
&lt;/ul>
&lt;h5 id="3-里氏替换原则">3. 里氏替换原则
&lt;/h5>&lt;p>子类型必须能够替换其父类型而不影响程序的正确性。&lt;/p>
&lt;ul>
&lt;li>子类应该扩展父类的行为，而不是改变它&lt;/li>
&lt;li>子类不应该加强前置条件或削弱后置条件&lt;/li>
&lt;li>子类不应该抛出父类不会抛出的异常&lt;/li>
&lt;/ul>
&lt;h5 id="4-接口隔离原则">4. 接口隔离原则
&lt;/h5>&lt;p>客户端不应该被迫依赖他们不使用的接口&lt;/p>
&lt;ul>
&lt;li>将大接口拆分为更小、更具体的接口&lt;/li>
&lt;li>类不应该实现他们不需要的方法&lt;/li>
&lt;/ul>
&lt;h5 id="5-依赖倒置">5. 依赖倒置
&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">高层模块&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">依赖&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">抽象接口&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">←&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">实现&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">←&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">低层模块&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Rust知识问答</title><link>https://www.dust-zed.site/rust/rust%E7%9F%A5%E8%AF%86%E9%97%AE%E7%AD%94/</link><pubDate>Mon, 01 Sep 2025 17:16:28 +0800</pubDate><guid>https://www.dust-zed.site/rust/rust%E7%9F%A5%E8%AF%86%E9%97%AE%E7%AD%94/</guid><description>&lt;h5 id="为什么fnonce只能调用一次">为什么FnOnce只能调用一次
&lt;/h5>&lt;h6 id="源码分析">源码分析
&lt;/h6>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">trait&lt;/span> FnOnce&lt;span style="color:#f92672">&amp;lt;&lt;/span>Args&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Output&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">extern&lt;/span> &lt;span style="color:#e6db74">&amp;#34;rust-call&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">call_once&lt;/span>(self, args: &lt;span style="color:#a6e22e">Args&lt;/span>) -&amp;gt; &lt;span style="color:#a6e22e">Self&lt;/span>::Output;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>&lt;code>self&lt;/code>的含义
&lt;ul>
&lt;li>接收实现了&lt;code>FnOnce&lt;/code>的具体类型的值&lt;/li>
&lt;li>这个值会被移动(move)进方法&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h6 id="具体例子">具体例子
&lt;/h6>&lt;p>假设我们有一个闭包:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> s &lt;span style="color:#f92672">=&lt;/span> String::from(&lt;span style="color:#e6db74">&amp;#34;hello&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> f &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">||&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">println!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, s); &lt;span style="color:#75715e">// 获取 s 的所有权
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> s.len()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当这个闭包实现&lt;code>FnOnce&lt;/code>时&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 编译器生成的代码类似这样：
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Closure&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> s: String, &lt;span style="color:#75715e">// 捕获的环境变量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> FnOnce&lt;span style="color:#f92672">&amp;lt;&lt;/span>()&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> Closure {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Output&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">usize&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">call_once&lt;/span>(self, _args: ()) -&amp;gt; &lt;span style="color:#66d9ef">usize&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">println!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, self.s);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.s.len()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="调用示例">调用示例
&lt;/h6>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> f(); &lt;span style="color:#75715e">// 等价于 FnOnce::call_once(f, ())
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 这里不能再调用 f()，因为 f 已经被移动
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最终f所有权被转移进&lt;code>call_once&lt;/code>，并随着call_once的结束而&lt;code>drop&lt;/code>了，f被释放了，内部捕获的所有权自然也被释放。&lt;/p>
&lt;p>&lt;code>FnOnce&lt;/code>、&lt;code>FnMut&lt;/code>、&lt;code>Fn&lt;/code>这些是根据如何捕获环境而区分的，并不影响函数签名，&lt;code>FnMut&lt;/code>也可以接收&lt;strong>所有权参数&lt;/strong>&lt;/p>
&lt;h5 id="什么是零成本抽象">什么是零成本抽象
&lt;/h5>&lt;p>零成本抽象的核心就是：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>编译期完成工作&lt;/strong>：类型检查、泛型单态化、内联优化等在编译时完成&lt;/li>
&lt;li>&lt;strong>零运行时开销&lt;/strong>：不引入额外的运行时检查或间接调用&lt;/li>
&lt;li>&lt;strong>无额外内存分配&lt;/strong>：避免不必要的堆分配，尽可能使用栈内存&lt;/li>
&lt;li>&lt;strong>透明优化&lt;/strong>：高级抽象在编译后生成的机器码与手写底层代码相当&lt;/li>
&lt;/ol>
&lt;p>这正是 Rust 能在提供高级语言特性的同时，仍能保持与 C/C++ 相媲美的性能的关键所在。&lt;/p></description></item><item><title>文件系统</title><link>https://www.dust-zed.site/rust/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Mon, 01 Sep 2025 17:12:26 +0800</pubDate><guid>https://www.dust-zed.site/rust/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid><description>&lt;h4 id="文件系统">文件系统
&lt;/h4>&lt;ul>
&lt;li>&lt;code>metadata&lt;/code>:本质上就是描述文件信息的数据&lt;/li>
&lt;li>环境变量和配置文件
&lt;ul>
&lt;li>配置文件：存储&lt;strong>默认配置&lt;/strong>或&lt;strong>静态配置&lt;/strong>&lt;/li>
&lt;li>环境变量：提供&lt;strong>动态覆盖&lt;/strong>或&lt;strong>环境特定配置&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>挂载（Mount）&lt;/strong>： 将&lt;strong>存储设备&lt;/strong>或&lt;strong>文件系统&lt;/strong>连接到操作系统目录树中特定位置的过程。这个连接点称为&lt;strong>挂载点（Mount Point）&lt;/strong>。类比门和仓库的关系。&lt;/li>
&lt;li>文件设备号&lt;/li>
&lt;/ul></description></item><item><title>架构设计</title><link>https://www.dust-zed.site/rust/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</link><pubDate>Mon, 01 Sep 2025 17:05:55 +0800</pubDate><guid>https://www.dust-zed.site/rust/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</guid><description>&lt;h4 id="如何做好职责分离">如何做好职责分离
&lt;/h4>&lt;ul>
&lt;li>从“怎么实现”到“怎么组合”
&lt;ul>
&lt;li>一体式思维：写一个函数完成所有功能&lt;/li>
&lt;li>分离式思维：要设计几个组件，然后组合它们实现功能&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>从“功能优先”到“测试优先”
&lt;ul>
&lt;li>一体式思维：先实现功能，再考虑测试&lt;/li>
&lt;li>分离式思维：先考虑怎么测试，倒推出职责分离&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>ripgrep&lt;/code>的分离式架构
&lt;ul>
&lt;li>cli参数 → &lt;code>LowArgs&lt;/code> → &lt;code>HiArgs&lt;/code>&lt;/li>
&lt;li>搜索目标：分为文件发现和目标搜索&lt;/li>
&lt;li>文件遍历再次分离：WalkDir（负责目录树形结构转为线性的Iter）→ WalkEventDir（负责发送事件）→ Walk（添加忽略规则）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr></description></item><item><title>语法速查</title><link>https://www.dust-zed.site/rust/%E8%AF%AD%E6%B3%95%E9%80%9F%E6%9F%A5/</link><pubDate>Mon, 01 Sep 2025 16:22:39 +0800</pubDate><guid>https://www.dust-zed.site/rust/%E8%AF%AD%E6%B3%95%E9%80%9F%E6%9F%A5/</guid><description>&lt;h4 id="集合或迭代器">集合或迭代器
&lt;/h4>&lt;ul>
&lt;li>&lt;code>drain()&lt;/code>方法：核心功能是移除集合中指定范围的元素，同时保持集合的连续性，是一种比**多次调用remove()**更高效的批量处理方式&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h4 id="所有权">所有权
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>所有权&lt;/strong>和&lt;strong>可变性&lt;/strong>是独立的&lt;/li>
&lt;li>&lt;strong>所有权完整性&lt;/strong>保护针对集合
&lt;ul>
&lt;li>集合需要保证所有元素位置有效&lt;/li>
&lt;li>集合在内存中是连续的&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>结构体允许&lt;strong>字段被转移走所有权&lt;/strong>
&lt;ul>
&lt;li>结构体字段具有独立性，布局在编译时可知&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>所有者离开作用域，值将被丢弃&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h4 id="变量和类型">变量和类型
&lt;/h4>&lt;ul>
&lt;li>
&lt;p>&lt;code>ref&lt;/code>和&lt;code>&amp;amp;&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&amp;amp;用于创建引用&lt;/li>
&lt;li>&amp;amp;用于模式匹配时，行使的是解构操作（一般作用是隐式解引用）&lt;/li>
&lt;li>ref用于模式匹配，获取引用而不是获取所有权&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>'a : 'b&lt;/code>表示 &lt;code>'a&lt;/code> &amp;gt;= &lt;code>'b&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>T: 'static&lt;/code>:表示类型&lt;strong>T内部字段&lt;/strong>要么没有引用，要么引用都是&lt;code>'static&lt;/code>的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>trait My Trait: 'static&lt;/code>或&lt;code>Box&amp;lt;dyn MyTrait + 'static&amp;gt;&lt;/code>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>实现类型&lt;/strong>必须满足：&lt;code>Self: 'static&lt;/code>或者没有引用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>(PathBuf, Path)&lt;/code>、&lt;code>(String, str)&lt;/code>和&lt;code>(BytesMut/Vec&amp;lt;u8&amp;gt;, &amp;amp;[u8]&lt;/code>&lt;/p>
&lt;ul>
&lt;li>Path，str都是DST类型&lt;/li>
&lt;li>PathBuf和String都是拥有所有权的&lt;/li>
&lt;li>文件路径长度和字符串长度在编译时未知&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>&amp;amp;buf&lt;/code>和&lt;code>&amp;amp;buf[..]&lt;/code>的区别&lt;/p>
&lt;ul>
&lt;li>&lt;code>&amp;amp;buf&lt;/code>获取整个数组的引用，类型是&lt;code>&amp;amp;[u8; N]&lt;/code>或&lt;code>&amp;amp;Vec&amp;lt;u8&amp;gt;&lt;/code>（固定大小数组）&lt;/li>
&lt;li>&lt;code>&amp;amp;buf[..]&lt;/code>获取数组的切片引用，类型是&lt;code>&amp;amp;[u8]&lt;/code>（动态大小切片）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>格式化输出语法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>{[&lt;span style="color:#960050;background-color:#1e0010">参数索引&lt;/span>]:[&lt;span style="color:#960050;background-color:#1e0010">填充字符&lt;/span>][&lt;span style="color:#960050;background-color:#1e0010">对齐方式&lt;/span>][&lt;span style="color:#960050;background-color:#1e0010">宽度&lt;/span>][.&lt;span style="color:#960050;background-color:#1e0010">精度&lt;/span>][&lt;span style="color:#960050;background-color:#1e0010">类型&lt;/span>]}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;code>fmt::Formatter&lt;/code>是一个功能强大的格式化缓冲区，可以输出到字符串、stdout、文件等&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h4 id="结构体">结构体
&lt;/h4>&lt;ul>
&lt;li>Rust不允许将struct中某个字段标记为可变&lt;/li>
&lt;li>Rust中源文件（&lt;code>.rs&lt;/code>）隐性的视为一个模块，区别于&lt;code>mod&lt;/code>的显式声明&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h4 id="闭包">闭包
&lt;/h4>&lt;ul>
&lt;li>根据闭包捕获环境方式可分为三种，注意区分闭包 &lt;strong>捕获的环境变量&lt;/strong>和&lt;strong>闭包的参数&lt;/strong>
&lt;ul>
&lt;li>&lt;code>FnOnce&lt;/code>获取所有权&lt;/li>
&lt;li>&lt;code>FnMut&lt;/code>获取可变引用&lt;/li>
&lt;li>&lt;code>Fn&lt;/code>获取不可变引用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h4 id="并发编程">并发编程
&lt;/h4>&lt;ul>
&lt;li>并发编程主要有两种核心范式：&lt;strong>共享状态并发&lt;/strong>和&lt;strong>消息传递并发&lt;/strong>&lt;/li>
&lt;li>&lt;code>std::thread::scope&lt;/code>
&lt;ul>
&lt;li>相当于&lt;code>thread::spwan&lt;/code> + &lt;code>thread::join&lt;/code>，但是它们只能借用&lt;code>'static&lt;/code>或者&lt;code>move&lt;/code>变量&lt;/li>
&lt;li>&lt;code>scope&lt;/code>没有以上限制，有编译器的支持&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>Mutex&lt;/code>和&lt;code>MutexGuard&lt;/code>
&lt;ul>
&lt;li>&lt;code>Mutex&lt;/code>是互斥锁本身&lt;/li>
&lt;li>&lt;code>MutexGuard&lt;/code>指访问受互斥锁保护数据的“许可证”或“钥匙”&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>park()/unpark&lt;/code>和&lt;code>sleep()&lt;/code>
&lt;ul>
&lt;li>&lt;code>park()/unpark()&lt;/code>精准的控制线程的睡眠（park）与唤醒（unpark）&lt;/li>
&lt;li>&lt;code>sleep()&lt;/code>基于时间自动唤醒，无法提前唤醒&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>Rust中的IO操作</title><link>https://www.dust-zed.site/rust/rust%E4%B8%AD%E7%9A%84io%E6%93%8D%E4%BD%9C/</link><pubDate>Fri, 22 Aug 2025 06:01:17 +0800</pubDate><guid>https://www.dust-zed.site/rust/rust%E4%B8%AD%E7%9A%84io%E6%93%8D%E4%BD%9C/</guid><description>&lt;p>在Rust中，I/O操作主要通过&lt;code>Read&lt;/code>和&lt;code>Write&lt;/code>两个核心trait实现，而&lt;code>Cursor&lt;/code>、&lt;code>BufWriter&lt;/code>和&lt;code>ReadBuf&lt;/code>是围绕这些trait的实用工具。&lt;/p>
&lt;hr>
&lt;h4 id="1-read和write-trait">1. &lt;code>Read&lt;/code>和&lt;code>Write&lt;/code> trait
&lt;/h4>&lt;h5 id="stdioread">&lt;code>std::io::Read&lt;/code>
&lt;/h5>&lt;p>&lt;strong>作用&lt;/strong>：从数据源（文件、网络等）读取字节流。&lt;/p>
&lt;p>&lt;strong>核心方法&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">read&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self, buf: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">mut&lt;/span> [&lt;span style="color:#66d9ef">u8&lt;/span>]) -&amp;gt; Result&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">usize&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>尝试读取数据到缓冲区&lt;code>buf&lt;/code>&lt;/li>
&lt;li>返回实际读取的字节数(&lt;code>Ok(n)&lt;/code>)，或错误（&lt;code>Err(e)&lt;/code>）&lt;/li>
&lt;li>当读取到EOF时返回&lt;code>Ok(0)&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>常用方法&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;code>read_to_end(&amp;amp;mut vec)&lt;/code>:读取所有字节到&lt;code>Vec&amp;lt;u8&amp;gt;&lt;/code>&lt;/li>
&lt;li>&lt;code>read_to_string(&amp;amp;mut string)&lt;/code>:读取UTF-8字节到&lt;code>String&lt;/code>&lt;/li>
&lt;li>&lt;code>read_exact(&amp;amp;mut buf)&lt;/code>:精确读取&lt;code>buf.len()&lt;/code>字节，否则报错&lt;/li>
&lt;/ul>
&lt;h5 id="stdiowrite">&lt;code>std::io::Write&lt;/code>
&lt;/h5>&lt;p>&lt;strong>作用&lt;/strong>：将字节流写入目标&lt;/p>
&lt;p>&lt;strong>核心方法&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">write&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self, buf: &lt;span style="color:#66d9ef">&amp;amp;&lt;/span>[&lt;span style="color:#66d9ef">u8&lt;/span>]) -&amp;gt; Result&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">usize&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">flush&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#66d9ef">mut&lt;/span> self) -&amp;gt; Result&lt;span style="color:#f92672">&amp;lt;&lt;/span>()&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>write&lt;/code>尝试写入缓冲区&lt;code>buf&lt;/code>，返回实际写入的字节数&lt;/li>
&lt;li>&lt;code>flush&lt;/code>确保所有缓冲数据写入目标（如磁盘）&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h4 id="2-cursort">2. &lt;code>Cursor&amp;lt;T&amp;gt;&lt;/code>
&lt;/h4>&lt;p>&lt;strong>作用&lt;/strong>：将内存类型包装成可&lt;code>随机访问&lt;/code>的&lt;code>Read&lt;/code>/&lt;code>Write&lt;/code>对象。&lt;/p>
&lt;p>&lt;strong>特点&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>在内存中模拟文件指针（维护&lt;code>position&lt;/code>）。&lt;/li>
&lt;li>实现Read和Write（需&lt;code>T: AsMut&amp;lt;[u8]&amp;gt;&lt;/code>)，支持&lt;code>Seek&lt;/code>。&lt;/li>
&lt;li>零成本抽象，高性能内存操作。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>使用场景&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>从&lt;code>Vec&amp;lt;u8&amp;gt;&lt;/code>读取数据，或写入到&lt;code>Vec&amp;lt;u8&amp;gt;&lt;/code>。&lt;/li>
&lt;li>测试时代替真实文件I/O。&lt;/li>
&lt;/ul>
&lt;h4 id="3-bufwriterw">3. &lt;code>BufWriter&amp;lt;W&amp;gt;&lt;/code>
&lt;/h4>&lt;p>&lt;strong>作用&lt;/strong>：包装一个&lt;code>Write&lt;/code>对象，提供&lt;strong>写入缓冲&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>优点&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>减少系统调用（如磁盘、网络写入）。&lt;/li>
&lt;li>批量写入提高性能（默认缓冲区大小&lt;strong>8KB&lt;/strong>）。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>行为&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>先写入内存缓冲区，满时自动刷新到内部&lt;code>W&lt;/code>。&lt;/li>
&lt;li>手动调用&lt;code>flush()&lt;/code>或&lt;code>Drop&lt;/code>时强制刷新缓冲区。&lt;/li>
&lt;/ul>
&lt;h4 id="4-bufreaderr">4. &lt;code>BufReader&amp;lt;R&amp;gt;&lt;/code>
&lt;/h4>&lt;p>&lt;strong>作用&lt;/strong>：包装&lt;code>Read&lt;/code>对象，提供&lt;strong>读取缓冲&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>优点&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>减少频繁系统调用（如读取文件时多次小数据读取）&lt;/li>
&lt;li>支持按行读取（&lt;code>read_line&lt;/code>和&lt;code>lines&lt;/code>）&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h4 id="完整知识图谱">完整知识图谱
&lt;/h4>&lt;pre tabindex="0">&lt;code>I/O 核心 Trait
│
├── Read (字节源)
│ ├── 实现类型：File, TcpStream, Vec&amp;lt;u8&amp;gt;, etc.
│ ├── 工具：BufReader (缓冲读取), Take (限制读取长度)
│ └── 扩展：BufRead (提供 read_line, lines 等方法)
│
├── Write (字节目标)
│ ├── 实现类型：File, TcpStream, Vec&amp;lt;u8&amp;gt;, etc.
│ └── 工具：BufWriter (缓冲写入), LineWriter (行缓冲)
│
├── Seek (随机访问)
│ └── 实现类型：File, Cursor&amp;lt;T&amp;gt;
│
└── 内存适配器
└── Cursor&amp;lt;T&amp;gt; (内存模拟 I/O)
├── 支持：Read/Write/Seek
└── 适用：Vec&amp;lt;u8&amp;gt;, &amp;amp;[u8], String, &amp;amp;str
&lt;/code>&lt;/pre>&lt;hr>
&lt;h5 id="关键原则">关键原则
&lt;/h5>&lt;p>&lt;strong>1. 缓冲使用&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>BufReader/BufWriter总是推荐用于文件/网络 I/O。&lt;/li>
&lt;li>Cursor用于内存数据（如解析二进制格式）&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>2. 错误处理&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>所有I/O操作返回&lt;code>Result&lt;/code>，必须处理&lt;code>Err&lt;/code>情况。&lt;/li>
&lt;li>特别注意&lt;code>flush()&lt;/code>的错误（如磁盘满）。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>3. 性能&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>小数据写入用&lt;code>BufWriter&lt;/code>&lt;/li>
&lt;li>避免频繁小数据读取（缓冲或批量化）&lt;/li>
&lt;/ul></description></item><item><title>大端序和小端序</title><link>https://www.dust-zed.site/rust/%E5%A4%A7%E7%AB%AF%E5%BA%8F%E5%92%8C%E5%B0%8F%E7%AB%AF%E5%BA%8F/</link><pubDate>Fri, 22 Aug 2025 03:33:16 +0800</pubDate><guid>https://www.dust-zed.site/rust/%E5%A4%A7%E7%AB%AF%E5%BA%8F%E5%92%8C%E5%B0%8F%E7%AB%AF%E5%BA%8F/</guid><description>&lt;p>大端序和小端序是两种不同的&lt;strong>字节存储顺序&lt;/strong>，用于描述多字节数据（如整数、浮点数）在计算机内存中的存储方式。它们的区别在于字节的排列顺序：&lt;/p>
&lt;h4 id="大端序">大端序
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>高位字节存储在低地址&lt;/strong>，低位字节存储在高地址&lt;/li>
&lt;/ul>
&lt;h4 id="小端序">小端序
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>低位字节存储在低地址&lt;/strong>，高位字节存储在高地址&lt;/li>
&lt;/ul>
&lt;p>小端序更符合计算机的处理逻辑&lt;/p></description></item><item><title>需要多熟悉的rust语法</title><link>https://www.dust-zed.site/rust/%E9%9C%80%E8%A6%81%E5%A4%9A%E7%86%9F%E6%82%89%E7%9A%84rust%E8%AF%AD%E6%B3%95/</link><pubDate>Tue, 19 Aug 2025 15:02:39 +0800</pubDate><guid>https://www.dust-zed.site/rust/%E9%9C%80%E8%A6%81%E5%A4%9A%E7%86%9F%E6%82%89%E7%9A%84rust%E8%AF%AD%E6%B3%95/</guid><description>&lt;h4 id="绑定运算符">@(绑定运算符)
&lt;/h4>&lt;p>在Rust中，&lt;code>@&lt;/code>被称为绑定运算符，用于在模式匹配的值绑定到一个变量，同时允许进一步解构内部结构。&lt;/p>
&lt;p>&lt;strong>具体解析&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">match&lt;/span> self.reader.read(buf) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Ok(len) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.size &lt;span style="color:#f92672">-=&lt;/span> len;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Ok(len)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err &lt;span style="color:#f92672">@&lt;/span> Err(_) &lt;span style="color:#f92672">=&amp;gt;&lt;/span> err
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>&lt;code>Ok(len)&lt;/code>分支&lt;/strong>：匹配成功的&lt;code>Ok&lt;/code>变体，提取内部的&lt;code>len&lt;/code>值，然后更新&lt;code>self.size&lt;/code>并返回&lt;code>Ok(len)&lt;/code>&lt;/li>
&lt;li>**&lt;code>err @ Err(_)&lt;/code>**分支：
&lt;ul>
&lt;li>&lt;code>Err(_)&lt;/code>匹配任意&lt;code>Err&lt;/code>变体(不关心内部错误的具体值)&lt;/li>
&lt;li>&lt;code>@&lt;/code>将整个Err的值(如&lt;code>Err(&amp;quot;io_error&amp;quot;)&lt;/code>)绑定到变量&lt;code>err&lt;/code>&lt;/li>
&lt;li>分支返回&lt;code>err&lt;/code>，即原始的&lt;code>Err&lt;/code>值&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>解构默认会发生所有权转移，&lt;code>let Data(inner) = &amp;amp;data;&lt;/code>等价于&lt;code>let Data(ref inner) = &amp;amp;data;&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h4 id="asref">AsRef
&lt;/h4>&lt;p>&lt;code>AsRef&lt;/code> trait的核心作用是允许一个类型以&lt;strong>零开销&lt;/strong>的方式将自己或引用转换成&lt;strong>另一种类型的引用&lt;/strong>。&lt;code>AsMut&lt;/code>是&lt;code>AsRef&lt;/code>的可变版本&lt;/p>
&lt;p>&lt;strong>1. 核心机制&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>AsRef&amp;lt;T&amp;gt;&lt;/code>定义了一个方法：&lt;code>fn as_ref(&amp;amp;self) -&amp;gt; &amp;amp;T&lt;/code>&lt;/li>
&lt;li>它接受&lt;code>&amp;amp;self&lt;/code>，返回目标类型&lt;code>&amp;amp;T&lt;/code>的引用&lt;/li>
&lt;li>本质上：将&lt;code>&amp;amp;Self&lt;/code>转换为&lt;code>&amp;amp;T&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>2. 转换类型&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>允许的是&lt;code>Self&lt;/code>到&lt;code>T&lt;/code>的引用转换。&lt;/li>
&lt;li>例如：
&lt;ul>
&lt;li>&lt;code>String&lt;/code>实现&lt;code>AsRef&amp;lt;str&amp;gt;&lt;/code>: &lt;code>&amp;amp;String -&amp;gt; &amp;amp;str&lt;/code>&lt;/li>
&lt;li>&lt;code>Vec&amp;lt;T&amp;gt;&lt;/code> 实现&lt;code>AsRef&amp;lt;[T]&amp;gt;&lt;/code>: &lt;code>&amp;amp;Vec&amp;lt;T&amp;gt; -&amp;gt;&amp;amp;[T]&lt;/code>&lt;/li>
&lt;li>&lt;code>PathBuf&lt;/code>实现&lt;code>AsRef&amp;lt;Path&amp;gt;&lt;/code>: &lt;code>&amp;amp;PathBuf -&amp;gt; &amp;amp;Path&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>**3. 设计目的 **&lt;/p>
&lt;ul>
&lt;li>泛型灵活性：让函数接受多种类型参数&lt;/li>
&lt;li>零开销抽象：转换过程无额外堆分配或复制&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h4 id="零开销">零开销
&lt;/h4>&lt;p>&lt;strong>什么是零开销&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>栈操作和微小的寄存器复制是允许的&lt;/li>
&lt;li>没有&lt;strong>堆内存分配&lt;/strong>：绝不调用内存分配器&lt;/li>
&lt;li>没有&lt;strong>深拷贝&lt;/strong>：不复制底层数据本身（即使是栈上的解构也需要合理区分）&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h4 id="切片引用">切片引用
&lt;/h4>&lt;p>&lt;strong>切片引用本质就是宽指针&lt;/strong>，由&lt;strong>数据指针&lt;/strong>和&lt;strong>长度&lt;/strong>组成&lt;/p>
&lt;hr>
&lt;h4 id="condvar">Condvar
&lt;/h4>&lt;p>在rust中，&lt;code>Condvar&lt;/code>（条件变量）是用于线程间同步的核心工具，通常与&lt;code>Mutex&lt;/code>结合使用。它的核心功能是让线程在某个条件不满足时&lt;strong>主动阻塞&lt;/strong>，直到其他线程修改条件并通知它继续执行。&lt;/p>
&lt;ul>
&lt;li>作用：解决线程间的&lt;strong>等待-通知&lt;/strong>问题，避免busy looping。&lt;/li>
&lt;li>依赖：必须与&lt;code>Mutex&lt;/code>配合使用（保护共享数据 + 同步条件）&lt;/li>
&lt;li>典型场景：生产者-消费者模型、任务队列调度、资源池管理等。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> std::sync::{Arc, Mutex, Condvar};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">use&lt;/span> std::thread;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//创建共享数据结构：(Mutex&amp;lt;bool&amp;gt;, Condvar)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">let&lt;/span> pair &lt;span style="color:#f92672">=&lt;/span> Arc::new(Mutex::new(&lt;span style="color:#66d9ef">false&lt;/span>), Condvar::new()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> pair_clone &lt;span style="color:#f92672">=&lt;/span> Arc::clone(&lt;span style="color:#f92672">&amp;amp;&lt;/span>pair);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> consumer &lt;span style="color:#f92672">=&lt;/span> thread::spawn(&lt;span style="color:#66d9ef">move&lt;/span> &lt;span style="color:#f92672">||&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> (lock, cvar) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;*&lt;/span>pair_clone;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> condition &lt;span style="color:#f92672">=&lt;/span> lock.lock().unwarp();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//等条件满足
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">!*&lt;/span>condition {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//释放锁并阻塞，被唤醒后(wait返回后)重新获取锁
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> condition &lt;span style="color:#f92672">=&lt;/span> cvar.wait(condition).unwarp();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">println!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;消费者：条件已满足！继续执行&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//消费者的处理逻辑
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> thread::sleep(Duration::from_secs(&lt;span style="color:#ae81ff">1&lt;/span>));&lt;span style="color:#75715e">//模拟工作耗时
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> (lock, cvar) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;*&lt;/span>pair;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">let&lt;/span> &lt;span style="color:#66d9ef">mut&lt;/span> condition &lt;span style="color:#f92672">=&lt;/span> lock.lock().unwarp();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">println!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;生产者：更新条件并通知消费者...&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>condition &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 通知一个等待的消费者线程
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> cvar.notify_one();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> consumer.join().unwrap();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">println!&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;主线程: 所有线程执行完成&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h4 id="pin">PIN
&lt;/h4>&lt;hr>
&lt;p>&lt;strong>&lt;code>haystack&lt;/code>&lt;strong>命名源自英语谚语&lt;/strong>&amp;ldquo;looking for a needle in a haystack&amp;rdquo;&lt;/strong>(大海捞针),&lt;code>haystack&lt;/code>表示被搜索的&lt;strong>主体数据&lt;/strong>，&lt;code>needle&lt;/code>表示待查找的&lt;strong>目标元素&lt;/strong>.&lt;/p>
&lt;p>rust中有两种解引用的方式：&lt;strong>&lt;code>*&lt;/code>&lt;strong>和&lt;/strong>模式匹配解引用&lt;/strong>&lt;/p>
&lt;hr>
&lt;h4 id="unicodeascii和utf-8等">Unicode、ASCII和UTF-8等
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>Unicode&lt;/strong>为所有字符分配了唯一标识(称为&lt;strong>码点&lt;/strong>)&lt;/li>
&lt;li>&lt;strong>UTF-8&lt;/strong>等是需要将这些码点转换为用于存储/传输的&lt;strong>字节序列&lt;/strong>,根据&lt;strong>码点值的范围分类&lt;/strong>，确定字节序列的&lt;strong>长度&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>ASCII&lt;/strong>是Unicode和UTF-8的&lt;strong>特殊兼容子集&lt;/strong>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h4 id="字符数据">字符数据
&lt;/h4>&lt;ul>
&lt;li>&lt;code>b&lt;/code>前缀标识的数据：表示&lt;code>ASCII&lt;/code>字符集的字节数据，类型为&lt;code>u8&lt;/code>或&lt;code>&amp;amp;[u8]&lt;/code>&lt;/li>
&lt;li>&lt;code>&amp;amp;str&lt;/code>和&lt;code>&amp;amp;[u8]&lt;/code>：&lt;code>&amp;amp;str&lt;/code>是utf-8编码的切片引用且不可变，&lt;code>&amp;amp;[u8]&lt;/code>是对原始字节的切片引用，可变版本是&lt;code>&amp;amp;mut [u8]&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h4 id="为什么可以手动调用dropx而不能调用xdrop">为什么可以手动调用drop(x)而不能调用x.drop()
&lt;/h4>&lt;p>关键在于&lt;strong>所有权&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;code>std::mem::drop&amp;lt;T&amp;gt;(_x: T)&lt;/code>转移了所有权，_x离开drop函数作用域，&lt;strong>自动触发析构逻辑&lt;/strong>（调用&lt;code>Drop::drop&lt;/code> trait的实现）&lt;/li>
&lt;li>&lt;code>drop(&amp;amp;mut self)&lt;/code>没有发生所有权的转移，如果允许手动调用&lt;code>x.drop&lt;/code>,编译期在作用域结束时仍会再次调用&lt;code>drop&lt;/code>，双重释放，导致内存安全问题。&lt;/li>
&lt;/ul></description></item></channel></rss>