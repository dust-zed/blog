<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="一、核心作用 Choreographer是Android系统协调动画、输入和绘制操作的核心调度器。它通过VSYNC信号确保帧的渲染与屏幕刷新率同步，避免画面撕裂和卡顿。\n二、关键概念 VSYNC：垂直同步信号，表示屏幕开始刷新新的一帧 Frame Callbacks：注册的回调函数，在下一帧的特定阶段执行 Callback Types（按执行顺序排序） CALLBACK_INPUT CALLBACK_ANIMATION CALLBACK_INSETS_ANIMATION CALLBACK_TRAVERSAL CALLBACK_COMMIT public final class Choreographer { // 五种回调类型 public static final int CALLBACK_INPUT = 0; public static final int CALLBACK_ANIMATION = 1; public static final int CALLBACK_INSETS_ANIMATION = 2; public static final int CALLBACK_TRAVERSAL = 3; public static final int CALLBACK_COMMIT = 4; public static final int CALLBACK_LAST = CALLBACK_COMMIT; // 最后一种类型 // 单例模式实现 private static final ThreadLocal&lt;Choreographer&gt; sThreadInstance = new ThreadLocal&lt;Choreographer&gt;() { @Override protected Choreographer initialValue() { Looper looper = Looper.myLooper(); return new Choreographer(looper, VSYNC_SOURCE_APP); } }; // 回调队列数组 private final CallbackQueue[] mCallbackQueues; // VSYNC 接收器 private final FrameDisplayEventReceiver mDisplayEventReceiver; // 处理消息的Handler private final FrameHandler mHandler; } 三、核心架构图解 ┌───────────────────────┐ ┌───────────────────────┐ │ VSYNC 信号源 │──────&gt;│ FrameDisplayEventReceiver │ └───────────────────────┘ │ (接收硬件VSYNC信号) │ └───────────┬───────────┘ │ ▼ ┌───────────────────────┐ ┌───────────────────────┐ │ FrameHandler │&lt;──────│ onVsync() │ │ (处理3类消息) │──────&gt;│ scheduleVsync() │ └───────────┬───────────┘ └───────────────────────┘ │ ▼ ┌───────────────────────┐ │ doFrame() │ │ (帧处理核心方法) │ └───────────┬───────────┘ │ ▼ ┌───────────────────────┐ │ CallbackQueue[] │ │ (5种类型回调链表) │ └───────────────────────┘ 三、回调添加入口 1. 添加回调入口 public void postCallback(int callbackType, Runnable action, Object token) { postCallbackDelayed(callbackType, action, token, 0); } public void postCallbackDelayed(int callbackType, Runnable action, long delayMillis) { postCallbackDelayedInternal(callbackType, action, token, delayMillis); } 2. 内部添加实现 private void postCallbackDelayedInternal(int callbackType, Object action, Object token, long delayMillis) { synchronized (mLock) { final long now = SystemClock.uptimeMillis(); final long dueTime = now + delayMillis; // 1. 添加到对应的回调队列 mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token); // 2. 调度帧处理 if (dueTime &lt;= now) { // 立即调度 scheduleFrameLocked(now); } else { // 延迟调度 Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action); msg.arg1 = callbackType; msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, dueTime); } } } 3. 回调链表结构 private static final class CallbackQueue { private CallbackRecord mHead; public void addCallbackLocked(long dueTime, Object action, Object token) { CallbackRecord callback = obtainCallbackLocked(dueTime, action, token); if (mHead == null) { mHead = callback; return; } // 链表按照执行时间排序（小到大） if (dueTime &lt; mHead.dueTime) { callback.next = mHead; mHead = callback; return; } CallbackRecord entry = mHead; while (entry.next != null) { if (dueTime &lt; entry.next.dueTime) { callback.next = entry.next; entry.next = callback; return; } entry = entry.next; } entry.next = callback; } } // 链表节点定义 private static final class CallbackRecord { public CallbackRecord next; public long dueTime; public Object action; // Runnable 或 FrameCallback public Object token; } 四、VSYNC同步机制 1、 VSYNC请求 private void scheduleFrameLocked(long now) { if (!mFrameScheduled) { mFrameScheduled = true; if (USE_VSYNC) { // 通过 FrameDisplayEventReceiver 请求 VSYNC if (isRunningOnLooperThreadLocked()) { //注册 scheduleVsyncLocked(); } else { // 非UI线程发送消息到UI线程 Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC); msg.setAsynchronous(true); mHandler.sendMessageAtFrontOfQueue(msg); } } else { // 无VSYNC直接安排帧 final long nextFrameTime = ...; Message msg = mHandler.obtainMessage(MSG_DO_FRAME); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, nextFrameTime); } } } private void scheduleVsyncLocked() { mDisplayEventReceiver.scheduleVsync(); } 2. VSYNC接收与处理 private final class FrameDisplayEventReceiver extends DisplayEventReceiver { @Override public void onVsync(long timestampNanos, long physicalDisplayId, int frame) { // 1. 计算正确的帧时间 long now = System.nanoTime(); long intendedFrameTimeNanos = ...; // 2. 发送MSG_DO_FRAME消息 Message msg = Message.obtain(mHandler, MSG_DO_FRAME); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, intendedFrameTimeNanos / NANOS_PER_MS); } } 3. 帧处理核心 - doFrame() void doFrame(long frameTimeNanos, int frame) { final long startNanos; synchronized (mLock) { // 检查帧调度状态 if (!mFrameScheduled) return; // 计算跳帧情况 long jitterNanos = startNanos - frameTimeNanos; if (jitterNanos &gt;= mFrameIntervalNanos) { final long skippedFrames = jitterNanos / mFrameIntervalNanos; // 超过阈值打印警告日志 if (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) { Log.i(TAG, &#34;Skipped &#34; + skippedFrames + &#34; frames!&#34;); } frameTimeNanos = ...; // 调整帧时间 } mLastFrameTimeNanos = frameTimeNanos; mFrameScheduled = false; } try { // 按优先级顺序执行回调 mFrameInfo.markInputHandlingStart(); doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos); mFrameInfo.markAnimationsStart(); doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos); mFrameInfo.markPerformTraversalsStart(); doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos); doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos); } finally { // 清理工作 } } 五、回调执行处理 1. 执行回调核心逻辑 void doCallbacks(int callbackType, long frameTimeNanos) { CallbackRecord callbacks; synchronized (mLock) { // 提取所有到期的回调 final long now = frameTimeNanos / NANOS_PER_MS; callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now); if (callbacks == null) return; mCallbacksRunning = true; } try { // 执行链表中的所有回调 for (CallbackRecord c = callbacks; c != null; c = c.next) { // 执行回调 if (c.action instanceof Runnable) { ((Runnable) c.action).run(); } else { ((FrameCallback) c.action).doFrame(frameTimeNanos); } } } finally { synchronized (mLock) { // 回收CallbackRecord对象 recycleCallbackRecordsLocked(callbacks); mCallbacksRunning = false; } } } 2.到期回调提取算法 CallbackRecord extractDueCallbacksLocked(long now) { CallbackRecord callbacks = null; CallbackRecord next = mHead; // 遍历链表，找出所有dueTime&lt;=now的节点 while (next != null &amp;&amp; next.dueTime &lt;= now) { CallbackRecord temp = next; next = next.next; temp.next = callbacks; // 新节点插入链表头部 callbacks = temp; // 新链表头 } // 更新原链表 mHead = next; // 返回的是倒序链表（最近加入的先执行） return callbacks; } 六、Choreographer的其他作用 1. 帧率监控 开发者可以通过postFrameCallback实现帧率监控：\n">
<title>Choreographer类解析</title>

<link rel='canonical' href='http://localhost:1313/android-develop/choreographer%E7%B1%BB%E8%A7%A3%E6%9E%90/'>

<link rel="stylesheet" href="/scss/style.min.946cca6c6259ef94ac55abfae7c7bf3291ea3ed5eea17ef77500b257217c6710.css"><meta property='og:title' content="Choreographer类解析">
<meta property='og:description' content="一、核心作用 Choreographer是Android系统协调动画、输入和绘制操作的核心调度器。它通过VSYNC信号确保帧的渲染与屏幕刷新率同步，避免画面撕裂和卡顿。\n二、关键概念 VSYNC：垂直同步信号，表示屏幕开始刷新新的一帧 Frame Callbacks：注册的回调函数，在下一帧的特定阶段执行 Callback Types（按执行顺序排序） CALLBACK_INPUT CALLBACK_ANIMATION CALLBACK_INSETS_ANIMATION CALLBACK_TRAVERSAL CALLBACK_COMMIT public final class Choreographer { // 五种回调类型 public static final int CALLBACK_INPUT = 0; public static final int CALLBACK_ANIMATION = 1; public static final int CALLBACK_INSETS_ANIMATION = 2; public static final int CALLBACK_TRAVERSAL = 3; public static final int CALLBACK_COMMIT = 4; public static final int CALLBACK_LAST = CALLBACK_COMMIT; // 最后一种类型 // 单例模式实现 private static final ThreadLocal&lt;Choreographer&gt; sThreadInstance = new ThreadLocal&lt;Choreographer&gt;() { @Override protected Choreographer initialValue() { Looper looper = Looper.myLooper(); return new Choreographer(looper, VSYNC_SOURCE_APP); } }; // 回调队列数组 private final CallbackQueue[] mCallbackQueues; // VSYNC 接收器 private final FrameDisplayEventReceiver mDisplayEventReceiver; // 处理消息的Handler private final FrameHandler mHandler; } 三、核心架构图解 ┌───────────────────────┐ ┌───────────────────────┐ │ VSYNC 信号源 │──────&gt;│ FrameDisplayEventReceiver │ └───────────────────────┘ │ (接收硬件VSYNC信号) │ └───────────┬───────────┘ │ ▼ ┌───────────────────────┐ ┌───────────────────────┐ │ FrameHandler │&lt;──────│ onVsync() │ │ (处理3类消息) │──────&gt;│ scheduleVsync() │ └───────────┬───────────┘ └───────────────────────┘ │ ▼ ┌───────────────────────┐ │ doFrame() │ │ (帧处理核心方法) │ └───────────┬───────────┘ │ ▼ ┌───────────────────────┐ │ CallbackQueue[] │ │ (5种类型回调链表) │ └───────────────────────┘ 三、回调添加入口 1. 添加回调入口 public void postCallback(int callbackType, Runnable action, Object token) { postCallbackDelayed(callbackType, action, token, 0); } public void postCallbackDelayed(int callbackType, Runnable action, long delayMillis) { postCallbackDelayedInternal(callbackType, action, token, delayMillis); } 2. 内部添加实现 private void postCallbackDelayedInternal(int callbackType, Object action, Object token, long delayMillis) { synchronized (mLock) { final long now = SystemClock.uptimeMillis(); final long dueTime = now + delayMillis; // 1. 添加到对应的回调队列 mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token); // 2. 调度帧处理 if (dueTime &lt;= now) { // 立即调度 scheduleFrameLocked(now); } else { // 延迟调度 Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action); msg.arg1 = callbackType; msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, dueTime); } } } 3. 回调链表结构 private static final class CallbackQueue { private CallbackRecord mHead; public void addCallbackLocked(long dueTime, Object action, Object token) { CallbackRecord callback = obtainCallbackLocked(dueTime, action, token); if (mHead == null) { mHead = callback; return; } // 链表按照执行时间排序（小到大） if (dueTime &lt; mHead.dueTime) { callback.next = mHead; mHead = callback; return; } CallbackRecord entry = mHead; while (entry.next != null) { if (dueTime &lt; entry.next.dueTime) { callback.next = entry.next; entry.next = callback; return; } entry = entry.next; } entry.next = callback; } } // 链表节点定义 private static final class CallbackRecord { public CallbackRecord next; public long dueTime; public Object action; // Runnable 或 FrameCallback public Object token; } 四、VSYNC同步机制 1、 VSYNC请求 private void scheduleFrameLocked(long now) { if (!mFrameScheduled) { mFrameScheduled = true; if (USE_VSYNC) { // 通过 FrameDisplayEventReceiver 请求 VSYNC if (isRunningOnLooperThreadLocked()) { //注册 scheduleVsyncLocked(); } else { // 非UI线程发送消息到UI线程 Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC); msg.setAsynchronous(true); mHandler.sendMessageAtFrontOfQueue(msg); } } else { // 无VSYNC直接安排帧 final long nextFrameTime = ...; Message msg = mHandler.obtainMessage(MSG_DO_FRAME); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, nextFrameTime); } } } private void scheduleVsyncLocked() { mDisplayEventReceiver.scheduleVsync(); } 2. VSYNC接收与处理 private final class FrameDisplayEventReceiver extends DisplayEventReceiver { @Override public void onVsync(long timestampNanos, long physicalDisplayId, int frame) { // 1. 计算正确的帧时间 long now = System.nanoTime(); long intendedFrameTimeNanos = ...; // 2. 发送MSG_DO_FRAME消息 Message msg = Message.obtain(mHandler, MSG_DO_FRAME); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, intendedFrameTimeNanos / NANOS_PER_MS); } } 3. 帧处理核心 - doFrame() void doFrame(long frameTimeNanos, int frame) { final long startNanos; synchronized (mLock) { // 检查帧调度状态 if (!mFrameScheduled) return; // 计算跳帧情况 long jitterNanos = startNanos - frameTimeNanos; if (jitterNanos &gt;= mFrameIntervalNanos) { final long skippedFrames = jitterNanos / mFrameIntervalNanos; // 超过阈值打印警告日志 if (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) { Log.i(TAG, &#34;Skipped &#34; + skippedFrames + &#34; frames!&#34;); } frameTimeNanos = ...; // 调整帧时间 } mLastFrameTimeNanos = frameTimeNanos; mFrameScheduled = false; } try { // 按优先级顺序执行回调 mFrameInfo.markInputHandlingStart(); doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos); mFrameInfo.markAnimationsStart(); doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos); mFrameInfo.markPerformTraversalsStart(); doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos); doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos); } finally { // 清理工作 } } 五、回调执行处理 1. 执行回调核心逻辑 void doCallbacks(int callbackType, long frameTimeNanos) { CallbackRecord callbacks; synchronized (mLock) { // 提取所有到期的回调 final long now = frameTimeNanos / NANOS_PER_MS; callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now); if (callbacks == null) return; mCallbacksRunning = true; } try { // 执行链表中的所有回调 for (CallbackRecord c = callbacks; c != null; c = c.next) { // 执行回调 if (c.action instanceof Runnable) { ((Runnable) c.action).run(); } else { ((FrameCallback) c.action).doFrame(frameTimeNanos); } } } finally { synchronized (mLock) { // 回收CallbackRecord对象 recycleCallbackRecordsLocked(callbacks); mCallbacksRunning = false; } } } 2.到期回调提取算法 CallbackRecord extractDueCallbacksLocked(long now) { CallbackRecord callbacks = null; CallbackRecord next = mHead; // 遍历链表，找出所有dueTime&lt;=now的节点 while (next != null &amp;&amp; next.dueTime &lt;= now) { CallbackRecord temp = next; next = next.next; temp.next = callbacks; // 新节点插入链表头部 callbacks = temp; // 新链表头 } // 更新原链表 mHead = next; // 返回的是倒序链表（最近加入的先执行） return callbacks; } 六、Choreographer的其他作用 1. 帧率监控 开发者可以通过postFrameCallback实现帧率监控：\n">
<meta property='og:url' content='http://localhost:1313/android-develop/choreographer%E7%B1%BB%E8%A7%A3%E6%9E%90/'>
<meta property='og:site_name' content='zed的博客'>
<meta property='og:type' content='article'><meta property='article:section' content='Android-Develop' /><meta property='article:published_time' content='2025-06-16T06:49:21&#43;08:00'/><meta property='article:modified_time' content='2025-06-16T06:49:21&#43;08:00'/>
<meta name="twitter:title" content="Choreographer类解析">
<meta name="twitter:description" content="一、核心作用 Choreographer是Android系统协调动画、输入和绘制操作的核心调度器。它通过VSYNC信号确保帧的渲染与屏幕刷新率同步，避免画面撕裂和卡顿。\n二、关键概念 VSYNC：垂直同步信号，表示屏幕开始刷新新的一帧 Frame Callbacks：注册的回调函数，在下一帧的特定阶段执行 Callback Types（按执行顺序排序） CALLBACK_INPUT CALLBACK_ANIMATION CALLBACK_INSETS_ANIMATION CALLBACK_TRAVERSAL CALLBACK_COMMIT public final class Choreographer { // 五种回调类型 public static final int CALLBACK_INPUT = 0; public static final int CALLBACK_ANIMATION = 1; public static final int CALLBACK_INSETS_ANIMATION = 2; public static final int CALLBACK_TRAVERSAL = 3; public static final int CALLBACK_COMMIT = 4; public static final int CALLBACK_LAST = CALLBACK_COMMIT; // 最后一种类型 // 单例模式实现 private static final ThreadLocal&lt;Choreographer&gt; sThreadInstance = new ThreadLocal&lt;Choreographer&gt;() { @Override protected Choreographer initialValue() { Looper looper = Looper.myLooper(); return new Choreographer(looper, VSYNC_SOURCE_APP); } }; // 回调队列数组 private final CallbackQueue[] mCallbackQueues; // VSYNC 接收器 private final FrameDisplayEventReceiver mDisplayEventReceiver; // 处理消息的Handler private final FrameHandler mHandler; } 三、核心架构图解 ┌───────────────────────┐ ┌───────────────────────┐ │ VSYNC 信号源 │──────&gt;│ FrameDisplayEventReceiver │ └───────────────────────┘ │ (接收硬件VSYNC信号) │ └───────────┬───────────┘ │ ▼ ┌───────────────────────┐ ┌───────────────────────┐ │ FrameHandler │&lt;──────│ onVsync() │ │ (处理3类消息) │──────&gt;│ scheduleVsync() │ └───────────┬───────────┘ └───────────────────────┘ │ ▼ ┌───────────────────────┐ │ doFrame() │ │ (帧处理核心方法) │ └───────────┬───────────┘ │ ▼ ┌───────────────────────┐ │ CallbackQueue[] │ │ (5种类型回调链表) │ └───────────────────────┘ 三、回调添加入口 1. 添加回调入口 public void postCallback(int callbackType, Runnable action, Object token) { postCallbackDelayed(callbackType, action, token, 0); } public void postCallbackDelayed(int callbackType, Runnable action, long delayMillis) { postCallbackDelayedInternal(callbackType, action, token, delayMillis); } 2. 内部添加实现 private void postCallbackDelayedInternal(int callbackType, Object action, Object token, long delayMillis) { synchronized (mLock) { final long now = SystemClock.uptimeMillis(); final long dueTime = now + delayMillis; // 1. 添加到对应的回调队列 mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token); // 2. 调度帧处理 if (dueTime &lt;= now) { // 立即调度 scheduleFrameLocked(now); } else { // 延迟调度 Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action); msg.arg1 = callbackType; msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, dueTime); } } } 3. 回调链表结构 private static final class CallbackQueue { private CallbackRecord mHead; public void addCallbackLocked(long dueTime, Object action, Object token) { CallbackRecord callback = obtainCallbackLocked(dueTime, action, token); if (mHead == null) { mHead = callback; return; } // 链表按照执行时间排序（小到大） if (dueTime &lt; mHead.dueTime) { callback.next = mHead; mHead = callback; return; } CallbackRecord entry = mHead; while (entry.next != null) { if (dueTime &lt; entry.next.dueTime) { callback.next = entry.next; entry.next = callback; return; } entry = entry.next; } entry.next = callback; } } // 链表节点定义 private static final class CallbackRecord { public CallbackRecord next; public long dueTime; public Object action; // Runnable 或 FrameCallback public Object token; } 四、VSYNC同步机制 1、 VSYNC请求 private void scheduleFrameLocked(long now) { if (!mFrameScheduled) { mFrameScheduled = true; if (USE_VSYNC) { // 通过 FrameDisplayEventReceiver 请求 VSYNC if (isRunningOnLooperThreadLocked()) { //注册 scheduleVsyncLocked(); } else { // 非UI线程发送消息到UI线程 Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC); msg.setAsynchronous(true); mHandler.sendMessageAtFrontOfQueue(msg); } } else { // 无VSYNC直接安排帧 final long nextFrameTime = ...; Message msg = mHandler.obtainMessage(MSG_DO_FRAME); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, nextFrameTime); } } } private void scheduleVsyncLocked() { mDisplayEventReceiver.scheduleVsync(); } 2. VSYNC接收与处理 private final class FrameDisplayEventReceiver extends DisplayEventReceiver { @Override public void onVsync(long timestampNanos, long physicalDisplayId, int frame) { // 1. 计算正确的帧时间 long now = System.nanoTime(); long intendedFrameTimeNanos = ...; // 2. 发送MSG_DO_FRAME消息 Message msg = Message.obtain(mHandler, MSG_DO_FRAME); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, intendedFrameTimeNanos / NANOS_PER_MS); } } 3. 帧处理核心 - doFrame() void doFrame(long frameTimeNanos, int frame) { final long startNanos; synchronized (mLock) { // 检查帧调度状态 if (!mFrameScheduled) return; // 计算跳帧情况 long jitterNanos = startNanos - frameTimeNanos; if (jitterNanos &gt;= mFrameIntervalNanos) { final long skippedFrames = jitterNanos / mFrameIntervalNanos; // 超过阈值打印警告日志 if (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) { Log.i(TAG, &#34;Skipped &#34; + skippedFrames + &#34; frames!&#34;); } frameTimeNanos = ...; // 调整帧时间 } mLastFrameTimeNanos = frameTimeNanos; mFrameScheduled = false; } try { // 按优先级顺序执行回调 mFrameInfo.markInputHandlingStart(); doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos); mFrameInfo.markAnimationsStart(); doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos); mFrameInfo.markPerformTraversalsStart(); doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos); doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos); } finally { // 清理工作 } } 五、回调执行处理 1. 执行回调核心逻辑 void doCallbacks(int callbackType, long frameTimeNanos) { CallbackRecord callbacks; synchronized (mLock) { // 提取所有到期的回调 final long now = frameTimeNanos / NANOS_PER_MS; callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(now); if (callbacks == null) return; mCallbacksRunning = true; } try { // 执行链表中的所有回调 for (CallbackRecord c = callbacks; c != null; c = c.next) { // 执行回调 if (c.action instanceof Runnable) { ((Runnable) c.action).run(); } else { ((FrameCallback) c.action).doFrame(frameTimeNanos); } } } finally { synchronized (mLock) { // 回收CallbackRecord对象 recycleCallbackRecordsLocked(callbacks); mCallbacksRunning = false; } } } 2.到期回调提取算法 CallbackRecord extractDueCallbacksLocked(long now) { CallbackRecord callbacks = null; CallbackRecord next = mHead; // 遍历链表，找出所有dueTime&lt;=now的节点 while (next != null &amp;&amp; next.dueTime &lt;= now) { CallbackRecord temp = next; next = next.next; temp.next = callbacks; // 新节点插入链表头部 callbacks = temp; // 新链表头 } // 更新原链表 mHead = next; // 返回的是倒序链表（最近加入的先执行） return callbacks; } 六、Choreographer的其他作用 1. 帧率监控 开发者可以通过postFrameCallback实现帧率监控：\n">
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column compact"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu_f509edb42ecc0ebd.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">zed的博客</a></h1>
            <h2 class="site-description"></h2>
        </div>
    </header><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/rust' >
                
                
                
                <span>rust</span>
            </a>
        </li>
        
        
        <li  class='current' >
            <a href='/android-develop/' >
                
                
                
                <span>Android-Develops</span>
            </a>
        </li>
        
        
        <li >
            <a href='/learning-reflection/' >
                
                
                
                <span>Learning-Reflections</span>
            </a>
        </li>
        
        
        <li >
            <a href='/tutorials/' >
                
                
                
                <span>Tutorials</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    

            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/android-develop/" >
                Android-Develop
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/android-develop/choreographer%E7%B1%BB%E8%A7%A3%E6%9E%90/">Choreographer类解析</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Jun 16, 2025</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 4 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h4 id="一核心作用">一、核心作用
</h4><p>Choreographer是Android系统<strong>协调动画、输入和绘制操作的核心调度器</strong>。它通过VSYNC信号确保帧的渲染与屏幕刷新率同步，避免画面撕裂和卡顿。</p>
<h4 id="二关键概念">二、关键概念
</h4><ul>
<li>VSYNC：垂直同步信号，表示屏幕开始刷新新的一帧</li>
<li>Frame Callbacks：注册的回调函数，在下一帧的特定阶段执行</li>
<li>Callback Types（按执行顺序排序）
<ul>
<li>CALLBACK_INPUT</li>
<li>CALLBACK_ANIMATION</li>
<li>CALLBACK_INSETS_ANIMATION</li>
<li>CALLBACK_TRAVERSAL</li>
<li>CALLBACK_COMMIT</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Choreographer</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 五种回调类型</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> CALLBACK_INPUT <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> CALLBACK_ANIMATION <span style="color:#f92672">=</span> 1;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> CALLBACK_INSETS_ANIMATION <span style="color:#f92672">=</span> 2;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> CALLBACK_TRAVERSAL <span style="color:#f92672">=</span> 3;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> CALLBACK_COMMIT <span style="color:#f92672">=</span> 4;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> CALLBACK_LAST <span style="color:#f92672">=</span> CALLBACK_COMMIT; <span style="color:#75715e">// 最后一种类型</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 单例模式实现</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> ThreadLocal<span style="color:#f92672">&lt;</span>Choreographer<span style="color:#f92672">&gt;</span> sThreadInstance <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">new</span> ThreadLocal<span style="color:#f92672">&lt;</span>Choreographer<span style="color:#f92672">&gt;</span>() {
</span></span><span style="display:flex;"><span>            <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">protected</span> Choreographer <span style="color:#a6e22e">initialValue</span>() {
</span></span><span style="display:flex;"><span>                Looper looper <span style="color:#f92672">=</span> Looper.<span style="color:#a6e22e">myLooper</span>();
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Choreographer(looper, VSYNC_SOURCE_APP);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 回调队列数组</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> CallbackQueue<span style="color:#f92672">[]</span> mCallbackQueues;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// VSYNC 接收器</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> FrameDisplayEventReceiver mDisplayEventReceiver;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 处理消息的Handler</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> FrameHandler mHandler;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="三核心架构图解">三、核心架构图解
</h4><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-tex" data-lang="tex"><span style="display:flex;"><span>┌───────────────────────┐       ┌───────────────────────┐
</span></span><span style="display:flex;"><span>│    VSYNC 信号源        │──────&gt;│ FrameDisplayEventReceiver │
</span></span><span style="display:flex;"><span>└───────────────────────┘       │  (接收硬件VSYNC信号)     │
</span></span><span style="display:flex;"><span>                                └───────────┬───────────┘
</span></span><span style="display:flex;"><span>                                            │
</span></span><span style="display:flex;"><span>                                            ▼
</span></span><span style="display:flex;"><span>┌───────────────────────┐       ┌───────────────────────┐
</span></span><span style="display:flex;"><span>│     FrameHandler       │&lt;──────│    onVsync()          │
</span></span><span style="display:flex;"><span>│   (处理3类消息)        │──────&gt;│    scheduleVsync()    │
</span></span><span style="display:flex;"><span>└───────────┬───────────┘       └───────────────────────┘
</span></span><span style="display:flex;"><span>            │
</span></span><span style="display:flex;"><span>            ▼
</span></span><span style="display:flex;"><span>┌───────────────────────┐
</span></span><span style="display:flex;"><span>│      doFrame()         │
</span></span><span style="display:flex;"><span>│ (帧处理核心方法)       │
</span></span><span style="display:flex;"><span>└───────────┬───────────┘
</span></span><span style="display:flex;"><span>            │
</span></span><span style="display:flex;"><span>            ▼
</span></span><span style="display:flex;"><span>┌───────────────────────┐
</span></span><span style="display:flex;"><span>│   CallbackQueue[]      │
</span></span><span style="display:flex;"><span>│ (5种类型回调链表)      │
</span></span><span style="display:flex;"><span>└───────────────────────┘
</span></span></code></pre></div><h4 id="三回调添加入口">三、回调添加入口
</h4><h5 id="1-添加回调入口">1. 添加回调入口
</h5><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">postCallback</span>(<span style="color:#66d9ef">int</span> callbackType, Runnable action, Object token) {
</span></span><span style="display:flex;"><span>    postCallbackDelayed(callbackType, action, token, 0);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">postCallbackDelayed</span>(<span style="color:#66d9ef">int</span> callbackType, Runnable action, <span style="color:#66d9ef">long</span> delayMillis) {
</span></span><span style="display:flex;"><span>    postCallbackDelayedInternal(callbackType, action, token, delayMillis);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="2-内部添加实现">2. 内部添加实现
</h5><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">postCallbackDelayedInternal</span>(<span style="color:#66d9ef">int</span> callbackType,
</span></span><span style="display:flex;"><span>        Object action, Object token, <span style="color:#66d9ef">long</span> delayMillis) {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">synchronized</span> (mLock) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> now <span style="color:#f92672">=</span> SystemClock.<span style="color:#a6e22e">uptimeMillis</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> dueTime <span style="color:#f92672">=</span> now <span style="color:#f92672">+</span> delayMillis;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 1. 添加到对应的回调队列</span>
</span></span><span style="display:flex;"><span>        mCallbackQueues<span style="color:#f92672">[</span>callbackType<span style="color:#f92672">]</span>.<span style="color:#a6e22e">addCallbackLocked</span>(dueTime, action, token);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 2. 调度帧处理</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (dueTime <span style="color:#f92672">&lt;=</span> now) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 立即调度</span>
</span></span><span style="display:flex;"><span>            scheduleFrameLocked(now);
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 延迟调度</span>
</span></span><span style="display:flex;"><span>            Message msg <span style="color:#f92672">=</span> mHandler.<span style="color:#a6e22e">obtainMessage</span>(MSG_DO_SCHEDULE_CALLBACK, action);
</span></span><span style="display:flex;"><span>            msg.<span style="color:#a6e22e">arg1</span> <span style="color:#f92672">=</span> callbackType;
</span></span><span style="display:flex;"><span>            msg.<span style="color:#a6e22e">setAsynchronous</span>(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>            mHandler.<span style="color:#a6e22e">sendMessageAtTime</span>(msg, dueTime);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="3-回调链表结构">3. 回调链表结构
</h5><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CallbackQueue</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> CallbackRecord mHead;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addCallbackLocked</span>(<span style="color:#66d9ef">long</span> dueTime, Object action, Object token) {
</span></span><span style="display:flex;"><span>        CallbackRecord callback <span style="color:#f92672">=</span> obtainCallbackLocked(dueTime, action, token);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (mHead <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            mHead <span style="color:#f92672">=</span> callback;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 链表按照执行时间排序（小到大）</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (dueTime <span style="color:#f92672">&lt;</span> mHead.<span style="color:#a6e22e">dueTime</span>) {
</span></span><span style="display:flex;"><span>            callback.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> mHead;
</span></span><span style="display:flex;"><span>            mHead <span style="color:#f92672">=</span> callback;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        CallbackRecord entry <span style="color:#f92672">=</span> mHead;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span> (entry.<span style="color:#a6e22e">next</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (dueTime <span style="color:#f92672">&lt;</span> entry.<span style="color:#a6e22e">next</span>.<span style="color:#a6e22e">dueTime</span>) {
</span></span><span style="display:flex;"><span>                callback.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> entry.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>                entry.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> callback;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            entry <span style="color:#f92672">=</span> entry.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        entry.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> callback;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 链表节点定义</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CallbackRecord</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> CallbackRecord next;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">long</span> dueTime;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Object action; <span style="color:#75715e">// Runnable 或 FrameCallback</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Object token;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="四vsync同步机制">四、VSYNC同步机制
</h4><h5 id="1-vsync请求">1、 VSYNC请求
</h5><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">scheduleFrameLocked</span>(<span style="color:#66d9ef">long</span> now) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>mFrameScheduled) {
</span></span><span style="display:flex;"><span>        mFrameScheduled <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (USE_VSYNC) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 通过 FrameDisplayEventReceiver 请求 VSYNC</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (isRunningOnLooperThreadLocked()) {
</span></span><span style="display:flex;"><span>              <span style="color:#75715e">//注册</span>
</span></span><span style="display:flex;"><span>                scheduleVsyncLocked();
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// 非UI线程发送消息到UI线程</span>
</span></span><span style="display:flex;"><span>                Message msg <span style="color:#f92672">=</span> mHandler.<span style="color:#a6e22e">obtainMessage</span>(MSG_DO_SCHEDULE_VSYNC);
</span></span><span style="display:flex;"><span>                msg.<span style="color:#a6e22e">setAsynchronous</span>(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>                mHandler.<span style="color:#a6e22e">sendMessageAtFrontOfQueue</span>(msg);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 无VSYNC直接安排帧</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> nextFrameTime <span style="color:#f92672">=</span> ...;
</span></span><span style="display:flex;"><span>            Message msg <span style="color:#f92672">=</span> mHandler.<span style="color:#a6e22e">obtainMessage</span>(MSG_DO_FRAME);
</span></span><span style="display:flex;"><span>            msg.<span style="color:#a6e22e">setAsynchronous</span>(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>            mHandler.<span style="color:#a6e22e">sendMessageAtTime</span>(msg, nextFrameTime);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">scheduleVsyncLocked</span>() {
</span></span><span style="display:flex;"><span>    mDisplayEventReceiver.<span style="color:#a6e22e">scheduleVsync</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="2-vsync接收与处理">2. VSYNC接收与处理
</h5><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">FrameDisplayEventReceiver</span> <span style="color:#66d9ef">extends</span> DisplayEventReceiver {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">onVsync</span>(<span style="color:#66d9ef">long</span> timestampNanos, <span style="color:#66d9ef">long</span> physicalDisplayId, <span style="color:#66d9ef">int</span> frame) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 1. 计算正确的帧时间</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> now <span style="color:#f92672">=</span> System.<span style="color:#a6e22e">nanoTime</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> intendedFrameTimeNanos <span style="color:#f92672">=</span> ...;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 2. 发送MSG_DO_FRAME消息</span>
</span></span><span style="display:flex;"><span>        Message msg <span style="color:#f92672">=</span> Message.<span style="color:#a6e22e">obtain</span>(mHandler, MSG_DO_FRAME);
</span></span><span style="display:flex;"><span>        msg.<span style="color:#a6e22e">setAsynchronous</span>(<span style="color:#66d9ef">true</span>);
</span></span><span style="display:flex;"><span>        mHandler.<span style="color:#a6e22e">sendMessageAtTime</span>(msg, intendedFrameTimeNanos <span style="color:#f92672">/</span> NANOS_PER_MS);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="3-帧处理核心---doframe">3. 帧处理核心 - doFrame()
</h5><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doFrame</span>(<span style="color:#66d9ef">long</span> frameTimeNanos, <span style="color:#66d9ef">int</span> frame) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> startNanos;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">synchronized</span> (mLock) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 检查帧调度状态</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>mFrameScheduled) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 计算跳帧情况</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> jitterNanos <span style="color:#f92672">=</span> startNanos <span style="color:#f92672">-</span> frameTimeNanos;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (jitterNanos <span style="color:#f92672">&gt;=</span> mFrameIntervalNanos) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> skippedFrames <span style="color:#f92672">=</span> jitterNanos <span style="color:#f92672">/</span> mFrameIntervalNanos;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 超过阈值打印警告日志</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (skippedFrames <span style="color:#f92672">&gt;=</span> SKIPPED_FRAME_WARNING_LIMIT) {
</span></span><span style="display:flex;"><span>                Log.<span style="color:#a6e22e">i</span>(TAG, <span style="color:#e6db74">&#34;Skipped &#34;</span> <span style="color:#f92672">+</span> skippedFrames <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; frames!&#34;</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            frameTimeNanos <span style="color:#f92672">=</span> ...; <span style="color:#75715e">// 调整帧时间</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        mLastFrameTimeNanos <span style="color:#f92672">=</span> frameTimeNanos;
</span></span><span style="display:flex;"><span>        mFrameScheduled <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 按优先级顺序执行回调</span>
</span></span><span style="display:flex;"><span>        mFrameInfo.<span style="color:#a6e22e">markInputHandlingStart</span>();
</span></span><span style="display:flex;"><span>        doCallbacks(Choreographer.<span style="color:#a6e22e">CALLBACK_INPUT</span>, frameTimeNanos);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        mFrameInfo.<span style="color:#a6e22e">markAnimationsStart</span>();
</span></span><span style="display:flex;"><span>        doCallbacks(Choreographer.<span style="color:#a6e22e">CALLBACK_ANIMATION</span>, frameTimeNanos);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        mFrameInfo.<span style="color:#a6e22e">markPerformTraversalsStart</span>();
</span></span><span style="display:flex;"><span>        doCallbacks(Choreographer.<span style="color:#a6e22e">CALLBACK_TRAVERSAL</span>, frameTimeNanos);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        doCallbacks(Choreographer.<span style="color:#a6e22e">CALLBACK_COMMIT</span>, frameTimeNanos);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 清理工作</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="五回调执行处理">五、回调执行处理
</h4><h5 id="1-执行回调核心逻辑">1. 执行回调核心逻辑
</h5><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doCallbacks</span>(<span style="color:#66d9ef">int</span> callbackType, <span style="color:#66d9ef">long</span> frameTimeNanos) {
</span></span><span style="display:flex;"><span>    CallbackRecord callbacks;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">synchronized</span> (mLock) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 提取所有到期的回调</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> now <span style="color:#f92672">=</span> frameTimeNanos <span style="color:#f92672">/</span> NANOS_PER_MS;
</span></span><span style="display:flex;"><span>        callbacks <span style="color:#f92672">=</span> mCallbackQueues<span style="color:#f92672">[</span>callbackType<span style="color:#f92672">]</span>.<span style="color:#a6e22e">extractDueCallbacksLocked</span>(now);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (callbacks <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span>) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        mCallbacksRunning <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 执行链表中的所有回调</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (CallbackRecord c <span style="color:#f92672">=</span> callbacks; c <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span>; c <span style="color:#f92672">=</span> c.<span style="color:#a6e22e">next</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 执行回调</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (c.<span style="color:#a6e22e">action</span> <span style="color:#66d9ef">instanceof</span> Runnable) {
</span></span><span style="display:flex;"><span>                ((Runnable) c.<span style="color:#a6e22e">action</span>).<span style="color:#a6e22e">run</span>();
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                ((FrameCallback) c.<span style="color:#a6e22e">action</span>).<span style="color:#a6e22e">doFrame</span>(frameTimeNanos);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">finally</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">synchronized</span> (mLock) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 回收CallbackRecord对象</span>
</span></span><span style="display:flex;"><span>            recycleCallbackRecordsLocked(callbacks);
</span></span><span style="display:flex;"><span>            mCallbacksRunning <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h5 id="2到期回调提取算法">2.到期回调提取算法
</h5><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>CallbackRecord <span style="color:#a6e22e">extractDueCallbacksLocked</span>(<span style="color:#66d9ef">long</span> now) {
</span></span><span style="display:flex;"><span>    CallbackRecord callbacks <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>    CallbackRecord next <span style="color:#f92672">=</span> mHead;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 遍历链表，找出所有dueTime&lt;=now的节点</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (next <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> next.<span style="color:#a6e22e">dueTime</span> <span style="color:#f92672">&lt;=</span> now) {
</span></span><span style="display:flex;"><span>        CallbackRecord temp <span style="color:#f92672">=</span> next;
</span></span><span style="display:flex;"><span>        next <span style="color:#f92672">=</span> next.<span style="color:#a6e22e">next</span>;
</span></span><span style="display:flex;"><span>        temp.<span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> callbacks;  <span style="color:#75715e">// 新节点插入链表头部</span>
</span></span><span style="display:flex;"><span>        callbacks <span style="color:#f92672">=</span> temp;       <span style="color:#75715e">// 新链表头</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 更新原链表</span>
</span></span><span style="display:flex;"><span>    mHead <span style="color:#f92672">=</span> next;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 返回的是倒序链表（最近加入的先执行）</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> callbacks;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="六choreographer的其他作用">六、Choreographer的其他作用
</h4><h5 id="1-帧率监控">1. 帧率监控
</h5><p>开发者可以通过postFrameCallback实现帧率监控：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">startMonitoring</span>() {
</span></span><span style="display:flex;"><span>    Choreographer.<span style="color:#a6e22e">getInstance</span>().<span style="color:#a6e22e">postFrameCallback</span>(<span style="color:#66d9ef">new</span> FrameCallback() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">long</span> lastFrameTime <span style="color:#f92672">=</span> 0;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doFrame</span>(<span style="color:#66d9ef">long</span> frameTimeNanos) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (lastFrameTime <span style="color:#f92672">!=</span> 0) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">long</span> frameInterval <span style="color:#f92672">=</span> (frameTimeNanos <span style="color:#f92672">-</span> lastFrameTime) <span style="color:#f92672">/</span> 1000000;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (frameInterval <span style="color:#f92672">&gt;</span> 16) {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// 记录掉帧情况</span>
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            lastFrameTime <span style="color:#f92672">=</span> frameTimeNanos;
</span></span><span style="display:flex;"><span>            Choreographer.<span style="color:#a6e22e">getInstance</span>().<span style="color:#a6e22e">postFrameCallback</span>(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="七总结">七、总结
</h4><p>Choreographer 是 Android 渲染系统的核心协调器，其工作原理可以概括为：</p>
<ol>
<li>
<p><strong>任务管理</strong>：通过 5 个链表队列管理不同优先级的回调任务</p>
<ul>
<li>输入 &gt; 动画 &gt; 插入动画 &gt; 视图遍历 &gt; 提交</li>
</ul>
</li>
<li>
<p><strong>VSYNC 同步</strong>：</p>
<pre tabindex="0"><code>scheduleVsync() → DisplayEventReceiver → onVsync() → doFrame()
</code></pre></li>
<li>
<p><strong>帧生命周期</strong>：</p>
<pre tabindex="0"><code>doFrame() → 
  doCallbacks(INPUT) → 
  doCallbacks(ANIMATION) → 
  doCallbacks(TRAVERSAL) → 
  doCallbacks(COMMIT)
</code></pre></li>
<li>
<p><strong>性能监控</strong>：内置跳帧检测和警告机制</p>
</li>
<li>
<p><strong>系统协调</strong>：作为动画系统、UI 系统、输入系统的同步中枢</p>
</li>
</ol>
<p>整个设计体现了 Android 系统对以下关键目标的平衡：</p>
<ul>
<li><strong>精确性</strong>：通过 VSYNC 精准同步</li>
<li><strong>高效性</strong>：链表结构和对象复用</li>
<li><strong>优先级</strong>：严格的分级回调顺序</li>
<li><strong>扩展性</strong>：支持多种回调类型</li>
<li><strong>监控能力</strong>：内置性能检测机制</li>
</ul>
<p><strong><code>scheduleVsync()</code> 的唯一目的就是在 VSYNC 到来时触发 <code>doFrame()</code></strong>，而整个 Choreographer 的核心任务就是确保所有帧处理操作完美对齐 VSYNC 时间序列。</p>

</section>


    <footer class="article-footer">
    

    </footer>


    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2025 zed的博客
    </section>
    
    <section class="powerby">
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.30.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.0640c0f9745d7bd65b558574cdb67852b46437c1f807526bf043aebc566fd6e4.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
