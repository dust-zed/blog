<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="Android View 性能优化体系 一、规避过度绘制（GPU优化） 专注于减少GPU的无效像素填充负载\n概念解析：\nGPU在单个像素点重复绘制超过2.5次（1x绘制+1.5x半透明混合）的现象，消耗填充率导致帧率下降 检测工具：\n开发者选项->调试GPU过度绘制（蓝色<1x, 绿色<2x, 粉色<3x, 红色≥4x） 核心策略： 移除无效背景层： 检查并移除Activity根布局或主题中冗余的windowBackground 删除被完全覆盖的中间层布局（如FrameLayout）背景 避免在自定义View的onDraw()中绘制被覆盖区域 层级扁平化： 使用ConstraintLayout替代多层嵌套布局 减少RelativeLayout导致的二次测量 透明效果控制： 避免大面积半透明视图（引发GPU混合计算） 硬件层动画结束时立即禁用（setLayerType(LAYER_TYPE_NONE)） 引用关键通用技术：\n结合clipRect/quickReject限定绘制区域（详见通用技术章节） 二、绘制指令优化（CPU优化） 降低CPU生成绘制指令的开销\n优化焦点：\nonDraw()方法的执行效率与资源管理 核心准则： 禁止内存分配：\n绝不在onDraw()中创建Paint/Path/Bitmap对象（应在构造方法初始化） 规避耗时操作：\n避免复杂计算、IO或解析逻辑 阻断递归触发：\n禁止在onDraw()中调用invalidate()或requestLayout() 高级技巧： 绘图资源复用：\n对矢量图(VectorDrawable)和位图采用不同优化策略 小图标优先使用矢量图 位图加载启用inSampleSize采样和RGB_565解码 使用ImageView.setImageDrawable()替代canvas.drawBitmap() 透明效果实现：\n优先使用View.setAlpha()而非半透明背景色 引用关键通用技术：\n精准控制硬件加速生命周期（详见通用技术章节） 三、通用核心技术 跨优化领域的共性技术方案\n区域裁剪技术：\ngraph TB A[canvas.clipRect] --> B[限定子View绘制区域] C[canvas.quickReject] --> D[跳过屏幕外区域绘制] A-->|ViewGroup| E[重写dispatchDraw控制] C-->|自定义View| F[onDraw中预判可见性] 在ViewGroup.drawChild中限定子View绘制边界 列表项等非重叠视图必备优化手段 硬件加速深度指南：\n运作机制：\n将View缓存为GPU纹理(Texture) 通过setLayerType(LAYER_TYPE_HARDWARE, null)启用 最佳实践：\n"><title>View性能优化</title><link rel=canonical href=https://www.dust-zed.site/android-develop/view%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/><link rel=stylesheet href=/scss/style.min.946cca6c6259ef94ac55abfae7c7bf3291ea3ed5eea17ef77500b257217c6710.css><meta property='og:title' content="View性能优化"><meta property='og:description' content="Android View 性能优化体系 一、规避过度绘制（GPU优化） 专注于减少GPU的无效像素填充负载\n概念解析：\nGPU在单个像素点重复绘制超过2.5次（1x绘制+1.5x半透明混合）的现象，消耗填充率导致帧率下降 检测工具：\n开发者选项->调试GPU过度绘制（蓝色<1x, 绿色<2x, 粉色<3x, 红色≥4x） 核心策略： 移除无效背景层： 检查并移除Activity根布局或主题中冗余的windowBackground 删除被完全覆盖的中间层布局（如FrameLayout）背景 避免在自定义View的onDraw()中绘制被覆盖区域 层级扁平化： 使用ConstraintLayout替代多层嵌套布局 减少RelativeLayout导致的二次测量 透明效果控制： 避免大面积半透明视图（引发GPU混合计算） 硬件层动画结束时立即禁用（setLayerType(LAYER_TYPE_NONE)） 引用关键通用技术：\n结合clipRect/quickReject限定绘制区域（详见通用技术章节） 二、绘制指令优化（CPU优化） 降低CPU生成绘制指令的开销\n优化焦点：\nonDraw()方法的执行效率与资源管理 核心准则： 禁止内存分配：\n绝不在onDraw()中创建Paint/Path/Bitmap对象（应在构造方法初始化） 规避耗时操作：\n避免复杂计算、IO或解析逻辑 阻断递归触发：\n禁止在onDraw()中调用invalidate()或requestLayout() 高级技巧： 绘图资源复用：\n对矢量图(VectorDrawable)和位图采用不同优化策略 小图标优先使用矢量图 位图加载启用inSampleSize采样和RGB_565解码 使用ImageView.setImageDrawable()替代canvas.drawBitmap() 透明效果实现：\n优先使用View.setAlpha()而非半透明背景色 引用关键通用技术：\n精准控制硬件加速生命周期（详见通用技术章节） 三、通用核心技术 跨优化领域的共性技术方案\n区域裁剪技术：\ngraph TB A[canvas.clipRect] --> B[限定子View绘制区域] C[canvas.quickReject] --> D[跳过屏幕外区域绘制] A-->|ViewGroup| E[重写dispatchDraw控制] C-->|自定义View| F[onDraw中预判可见性] 在ViewGroup.drawChild中限定子View绘制边界 列表项等非重叠视图必备优化手段 硬件加速深度指南：\n运作机制：\n将View缓存为GPU纹理(Texture) 通过setLayerType(LAYER_TYPE_HARDWARE, null)启用 最佳实践：\n"><meta property='og:url' content='https://www.dust-zed.site/android-develop/view%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/'><meta property='og:site_name' content='zed的博客'><meta property='og:type' content='article'><meta property='article:section' content='Android-Develop'><meta property='article:published_time' content='2025-06-13T23:55:35+08:00'><meta property='article:modified_time' content='2025-06-13T23:55:35+08:00'><meta name=twitter:title content="View性能优化"><meta name=twitter:description content="Android View 性能优化体系 一、规避过度绘制（GPU优化） 专注于减少GPU的无效像素填充负载\n概念解析：\nGPU在单个像素点重复绘制超过2.5次（1x绘制+1.5x半透明混合）的现象，消耗填充率导致帧率下降 检测工具：\n开发者选项->调试GPU过度绘制（蓝色<1x, 绿色<2x, 粉色<3x, 红色≥4x） 核心策略： 移除无效背景层： 检查并移除Activity根布局或主题中冗余的windowBackground 删除被完全覆盖的中间层布局（如FrameLayout）背景 避免在自定义View的onDraw()中绘制被覆盖区域 层级扁平化： 使用ConstraintLayout替代多层嵌套布局 减少RelativeLayout导致的二次测量 透明效果控制： 避免大面积半透明视图（引发GPU混合计算） 硬件层动画结束时立即禁用（setLayerType(LAYER_TYPE_NONE)） 引用关键通用技术：\n结合clipRect/quickReject限定绘制区域（详见通用技术章节） 二、绘制指令优化（CPU优化） 降低CPU生成绘制指令的开销\n优化焦点：\nonDraw()方法的执行效率与资源管理 核心准则： 禁止内存分配：\n绝不在onDraw()中创建Paint/Path/Bitmap对象（应在构造方法初始化） 规避耗时操作：\n避免复杂计算、IO或解析逻辑 阻断递归触发：\n禁止在onDraw()中调用invalidate()或requestLayout() 高级技巧： 绘图资源复用：\n对矢量图(VectorDrawable)和位图采用不同优化策略 小图标优先使用矢量图 位图加载启用inSampleSize采样和RGB_565解码 使用ImageView.setImageDrawable()替代canvas.drawBitmap() 透明效果实现：\n优先使用View.setAlpha()而非半透明背景色 引用关键通用技术：\n精准控制硬件加速生命周期（详见通用技术章节） 三、通用核心技术 跨优化领域的共性技术方案\n区域裁剪技术：\ngraph TB A[canvas.clipRect] --> B[限定子View绘制区域] C[canvas.quickReject] --> D[跳过屏幕外区域绘制] A-->|ViewGroup| E[重写dispatchDraw控制] C-->|自定义View| F[onDraw中预判可见性] 在ViewGroup.drawChild中限定子View绘制边界 列表项等非重叠视图必备优化手段 硬件加速深度指南：\n运作机制：\n将View缓存为GPU纹理(Texture) 通过setLayerType(LAYER_TYPE_HARDWARE, null)启用 最佳实践：\n"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column compact"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_f509edb42ecc0ebd.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>zed的博客</a></h1><h2 class=site-description></h2></div></header><ol class=menu id=main-menu><li><a href=/android-develop><span>android-develop</span></a></li><li><a href=/basic><span>basic</span></a></li><li><a href=/rust><span>rust</span></a></li><li><a href=/learning-reflection/><span>Learning-Reflections</span></a></li><li><a href=/tutorials/><span>Tutorials</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/android-develop/>Android-Develop</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/android-develop/view%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/>View性能优化</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Jun 13, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 1 分钟</time></div></footer></div></header><section class=article-content><h3 id=android-view-性能优化体系>Android View 性能优化体系</h3><hr><h3 id=一规避过度绘制gpu优化>一、规避过度绘制（GPU优化）</h3><p>专注于减少GPU的无效像素填充负载</p><ul><li><strong>概念解析：</strong><br>GPU在单个像素点重复绘制超过2.5次（1x绘制+1.5x半透明混合）的现象，消耗填充率导致帧率下降</li><li><strong>检测工具：</strong><br><code>开发者选项->调试GPU过度绘制</code>（蓝色&lt;1x, 绿色&lt;2x, 粉色&lt;3x, 红色≥4x）</li><li><strong>核心策略：</strong><ul><li><strong>移除无效背景层：</strong><ul><li>检查并移除Activity根布局或主题中冗余的<code>windowBackground</code></li><li>删除被完全覆盖的中间层布局（如FrameLayout）背景</li><li>避免在自定义View的<code>onDraw()</code>中绘制被覆盖区域</li></ul></li><li><strong>层级扁平化：</strong><ul><li>使用<code>ConstraintLayout</code>替代多层嵌套布局</li><li>减少RelativeLayout导致的二次测量</li></ul></li><li><strong>透明效果控制：</strong><ul><li>避免大面积半透明视图（引发GPU混合计算）</li><li>硬件层动画结束时立即禁用（<code>setLayerType(LAYER_TYPE_NONE)</code>）</li></ul></li><li><strong>引用关键通用技术：</strong><br>结合<code>clipRect/quickReject</code>限定绘制区域（详见通用技术章节）</li></ul></li></ul><hr><h3 id=二绘制指令优化cpu优化>二、绘制指令优化（CPU优化）</h3><p>降低CPU生成绘制指令的开销</p><ul><li><strong>优化焦点：</strong><br><code>onDraw()</code>方法的执行效率与资源管理</li><li><strong>核心准则：</strong><ul><li><strong>禁止内存分配：</strong><br>绝不在<code>onDraw()</code>中创建Paint/Path/Bitmap对象（应在构造方法初始化）</li><li><strong>规避耗时操作：</strong><br>避免复杂计算、IO或解析逻辑</li><li><strong>阻断递归触发：</strong><br>禁止在<code>onDraw()</code>中调用<code>invalidate()</code>或<code>requestLayout()</code></li></ul></li><li><strong>高级技巧：</strong><ul><li><strong>绘图资源复用：</strong><br>对矢量图(VectorDrawable)和位图采用不同优化策略<ul><li>小图标优先使用矢量图</li><li>位图加载启用<code>inSampleSize</code>采样和<code>RGB_565</code>解码</li><li>使用<code>ImageView.setImageDrawable()</code>替代<code>canvas.drawBitmap()</code></li></ul></li><li><strong>透明效果实现：</strong><br>优先使用<code>View.setAlpha()</code>而非半透明背景色</li><li><strong>引用关键通用技术：</strong><br>精准控制硬件加速生命周期（详见通用技术章节）</li></ul></li></ul><hr><h3 id=三通用核心技术>三、通用核心技术</h3><p>跨优化领域的共性技术方案</p><ul><li><p><strong>区域裁剪技术：</strong></p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>graph TB
  A[canvas.clipRect] --&gt; B[限定子View绘制区域]
  C[canvas.quickReject] --&gt; D[跳过屏幕外区域绘制]
  A--&gt;|ViewGroup| E[重写dispatchDraw控制]
  C--&gt;|自定义View| F[onDraw中预判可见性]
</code></pre><ul><li>在<code>ViewGroup.drawChild</code>中限定子View绘制边界</li><li>列表项等非重叠视图必备优化手段</li></ul></li><li><p><strong>硬件加速深度指南：</strong></p><ul><li><p><strong>运作机制：</strong></p><ul><li>将View缓存为GPU纹理(Texture)</li><li>通过<code>setLayerType(LAYER_TYPE_HARDWARE, null)</code>启用</li></ul></li><li><p><strong>最佳实践：</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 动画开始前启用</span>
</span></span><span style=display:flex><span>view.<span style=color:#a6e22e>setLayerType</span>(LAYER_TYPE_HARDWARE, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>ObjectAnimator.<span style=color:#a6e22e>run</span>();
</span></span><span style=display:flex><span><span style=color:#75715e>// 动画结束后立即释放</span>
</span></span><span style=display:flex><span>animator.<span style=color:#a6e22e>addListener</span>(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>    view.<span style=color:#a6e22e>setLayerType</span>(LAYER_TYPE_NONE, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>});
</span></span></code></pre></div></li><li><p><strong>开销预警：</strong></p><ul><li>离屏缓冲增加20%-30%内存占用</li><li>静态视图启用反而降低性能</li></ul></li></ul></li><li><p><strong>圆角处理方案：</strong></p><div class=table-wrapper><table><thead><tr><th>实现方式</th><th>适用场景</th><th>性能影响</th></tr></thead><tbody><tr><td>ViewOutlineProvider</td><td>小面积圆角</td><td>★★☆</td></tr><tr><td>.9.png贴图</td><td>固定尺寸元素</td><td>★☆☆</td></tr><tr><td>绘制圆角矩形</td><td>动态尺寸视图</td><td>★★☆</td></tr><tr><td>clipToOutline</td><td>避免大面积使用</td><td>★★★</td></tr></tbody></table></div></li></ul><hr><h3 id=四布局优化独立模块>四、布局优化（独立模块）</h3><p>优化测量(measure)与布局(layout)阶段性能</p><ul><li><strong>检测工具：</strong><br><code>Profile GPU Rendering</code>分析各阶段耗时</li><li><strong>优化策略：</strong><ul><li><strong>层级压缩：</strong><ul><li>使用ConstraintLayout减少嵌套</li><li>避免LinearLayout权重导致的二次测量</li></ul></li><li><strong>动态加载：</strong><ul><li><code>&lt;merge></code>消除冗余容器层</li><li><code>ViewStub</code>延迟加载隐藏视图</li></ul></li><li><strong>自定义布局优化：</strong><ul><li>缓存<code>onMeasure()</code>计算结果</li><li>只测量可见子View</li></ul></li></ul></li></ul><hr><h3 id=优化关联图谱>优化关联图谱</h3><pre tabindex=0><code class=language-mermaid data-lang=mermaid>flowchart TD
    A[性能优化] --&gt; B[GPU负载]
    A --&gt; C[CPU负载]
    B --&gt; D[过度绘制优化]
    C --&gt; E[布局计算优化]
    C --&gt; F[绘制指令优化]
    D &amp; F --&gt; G[通用技术]
    G --&gt; H[区域裁剪]
    G --&gt; I[硬件加速]
    G --&gt; J[圆角处理]
</code></pre><p>该重组方案：</p><ol><li>完整保留原文所有技术点</li><li>消除硬件加速/clipRect等技术点的重复描述</li><li>建立清晰的「GPU优化-CPU优化-通用技术」逻辑链路</li><li>通过流程图和表格提升关键技术的可操作性</li><li>维持与原文档相同的技术细节颗粒度</li></ol><p>最终形成的体系逻辑：<br><strong>GPU优化</strong>解决"绘制次数"问题 → <strong>CPU优化</strong>解决"绘制效率"问题 → <strong>通用技术</strong>提供跨领域解决方案 → <strong>布局优化</strong>作为独立并行模块</p><ul><li><code>canvas.save()</code>: 将当前<strong>绘制状态</strong>（矩阵变换/裁剪区域/图层属性）存入栈中</li><li><code>canvas.restore()</code>: 从栈顶取出最近保存的状态并恢复</li><li><code>canvas.quickReject()</code>:快速判断指定矩形区域是否<strong>完全位于当前裁剪区域外</strong></li></ul></section><footer class=article-footer></footer></article><footer class=site-footer><section class=copyright>&copy;
2025 zed的博客</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>