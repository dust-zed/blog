+++
date = '2025-09-01T16:22:39+08:00'
draft = false
title = '语法速查'
categories = ['rust']

+++

#### 集合或迭代器

* `drain()`方法：核心功能是移除集合中指定范围的元素，同时保持集合的连续性，是一种比**多次调用remove()**更高效的批量处理方式

----------

#### 所有权

* **所有权**和**可变性**是独立的
* **所有权完整性**保护针对集合
  * 集合需要保证所有元素位置有效
  * 集合在内存中是连续的
* 结构体允许**字段被转移走所有权**
  * 结构体字段具有独立性，布局在编译时可知
* 所有者离开作用域，值将被丢弃

-----------

#### 变量和类型

* `ref`和`&`
  * &用于创建引用
  * &用于模式匹配时，行使的是解构操作（一般作用是隐式解引用）
  * ref用于模式匹配，获取引用而不是获取所有权
* `T: 'static`:表示类型**T内部字段**要么没有引用，要么引用都是`'static`的
* `trait My Trait: 'static`或`Box<dyn MyTrait + 'static`
  * **实现类型**必须满足：`Self: 'static`
* `(PathBuf, Path)`、`(String, str)`和`(BytesMut/Vec<u8>, &[u8]`
  * Path，str都是DST类型
  * PathBuf和String都是拥有所有权的
  * 文件路径长度和字符串长度在编译时未知
* `&buf`和`&buf[..]`的区别
  * `&buf`获取整个数组的引用，类型是`&[u8; N]`或`&Vec<u8>`（固定大小数组）
  * `&buf[..]`获取数组的切片引用，类型是`&[u8]`（动态大小切片）
  

--------

#### 结构体

* Rust不允许将struct中某个字段标记为可变
* Rust中源文件（`.rs`）隐性的视为一个模块，区别于`mod`的显式声明

----------

#### 闭包

* 根据闭包捕获环境方式可分为三种
  * `FnOnce`获取所有权
  * `FnMut`获取可变引用
  * `Fn`获取不可变引用
* 

-------------

#### 并发编程

* 并发编程主要有两种核心范式：**共享状态并发**和**消息传递并发**
* `std::thread::scope`
  * 相当于`thread::spwan` + `thread::join`，但是它们只能借用`'static`或者`move`变量
  * `scope`没有以上限制，有编译器的支持
* `Mutex`和`MutexGuard`
  * `Mutex`是互斥锁本身
  * `MutexGuard`指访问受互斥锁保护数据的“许可证”或“钥匙”
* `park()/unpark`和`sleep()`
  * `park()/unpark()`精准的控制线程的睡眠（park）与唤醒（unpark）
  * `sleep()`基于时间自动唤醒，无法提前唤醒
