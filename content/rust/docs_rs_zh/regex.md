+++
date = '2025-09-22T12:19:53+08:00'
draft = false
title = 'Regex'
categories = ['rust', 'docs_rs']

+++

è¿™ä¸ªcrateæä¾›äº†åœ¨å­—ç¬¦ä¸²ä¸­æœç´¢ä¸æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…(`regular expression`ç®€ç§°`regex`)çš„ä¾‹ç¨‹ã€‚æœ¬åº“æ”¯æŒçš„æ­£åˆ™è¡¨è¾¾å¼è¯­æ³•å’Œå…¶ä»–æ­£åˆ™å¼•æ“ç›¸ä¼¼ï¼Œä½†æ˜¯ç¼ºå°‘äº†ä¸€äº›æ— æ³•é«˜æ•ˆå®ç°çš„åŠŸèƒ½ã€‚åŒ…æ‹¬ä½†ä¸é™äºï¼Œ`look-around`å’Œ`backrefernces`ã€‚ç›¸åº”çš„ï¼Œæœ¬åº“çš„æ­£åˆ™æœç´¢æœ€å·®çš„æ—¶é—´å¤æ‚åº¦æ˜¯`O(m * n)`ï¼Œ`m`å’Œæ­£åˆ™è¡¨è¾¾å¼æˆæ­£æ¯”ï¼Œ`n`å’Œè¢«æœç´¢çš„å­—ç¬¦ä¸²æˆæ­£æ¯”ã€‚

å¦‚æœä½ åªéœ€è¦APIæ–‡æ¡£ï¼Œåªéœ€è¦è·³è½¬è‡³[Regex][https://docs.rs/regex/latest/regex/struct.Regex.html]ç±»å‹ã€‚å¦åˆ™ï¼Œæ­¤å¤„æ˜¯å¿«é€Ÿç¤ºä¾‹ï¼Œå±•ç¤ºå¦‚ä½•è§£æç±»ä¼¼grepç¨‹åºçš„è¾“å‡ºï¼š

```rust
use regex::Regex;

let re = Regex::new(r"(?m)^([^:]+):([0-9]+):(.+)$").unwrap();
let hay = "\
path/to/foo:54:Blue Harvest
path/to/bar:90:Something, Something, Something, Dark Side
path/to/baz:3:It's a Trap!
";

let mut results = vec![];
for (_, [path, lineno, line]) in re.captures_iter(hay).map(|c| c.extract()) {
    results.push((path, lineno.parse::<u64>()?, line));
}
assert_eq!(results, vec![
    ("path/to/foo", 54, "Blue Harvest"),
    ("path/to/bar", 90, "Something, Something, Something, Dark Side"),
    ("path/to/baz", 3, "It's a Trap!"),
]);
```

#### æ¦‚è¿°

----------------

æœ¬åº“çš„ä¸»è¦ç±»å‹æ˜¯`Regex`ã€‚å…¶é‡è¦çš„æ–¹æ³•å¦‚ä¸‹ï¼š

* `Regex::new`ä½¿ç”¨é»˜è®¤é…ç½®ç¼–è¯‘æ­£åˆ™è¡¨è¾¾å¼ã€‚`RegexBuilder`å…è®¸é…ç½®éé»˜è®¤é…ç½®ã€‚ï¼ˆä¾‹å¦‚ï¼Œä¸åŒºåˆ†å¤§å°å†™åŒ¹é…ï¼Œè¯¦ç»†æ¨¡å¼ç­‰ã€‚ï¼‰
* `Regex::is_match` æŠ¥å‘Šåœ¨ç‰¹å®šçš„haystackæ˜¯å¦å­˜åœ¨åŒ¹é…ã€‚
* `Regex::find`æŠ¥å‘ŠåŒ¹é…é¡¹åœ¨haystackçš„å­—èŠ‚åç§»ï¼Œå¦‚æœå­˜åœ¨çš„è¯ã€‚`Regex::find_iter`è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼Œç”¨äºéå†æ‰€æœ‰åŒ¹é…é¡¹ã€‚
* `Regex::captures`è¿”å›`Captures`,å®ƒæŠ¥å‘Šäº†åœ¨haystackä¸­åŒ¹é…çš„å­—èŠ‚åç§»é‡ä»¥åŠä»haystackä¸­çš„regexåŒ¹é…çš„æ¯ä¸ªæ•è·ç»„çš„å­—èŠ‚åç§»é‡ã€‚

ä¹Ÿæœ‰`RegexSet`ï¼Œå®ƒå…è®¸åœ¨ä¸€æ¬¡æœç´¢ä¸­æœç´¢å¤šä¸ªæ­£åˆ™è¡¨è¾¾å¼ã€‚ç„¶è€Œï¼Œå®ƒåªæŠ¥å‘ŠåŒ¹é…çš„æ¨¡å¼è€Œä¸æŠ¥å‘ŠåŒ¹é…çš„å­—èŠ‚åç§»é‡ã€‚

æ­¤å¤–ï¼Œé¡¶çº§crateæ–‡æ¡£ç»„ç»‡å¦‚ä¸‹ï¼š

* [Usage](#Usage)å±•ç¤ºäº†å¦‚ä½•åœ¨Rustå·¥ç¨‹ä¸­æ·»åŠ `regex`ã€‚
* [Examples](#Examples)æä¾›äº†æœ‰é™çš„æ­£åˆ™è¡¨è¾¾å¼ç¤ºä¾‹ã€‚
* [Performance](#Performance)æä¾›äº†å¦‚ä½•ä¼˜åŒ–æ­£åˆ™æœç´¢é€Ÿåº¦çš„ç®€å•æ€»ç»“ã€‚
* [Unicode][]è®¨è®ºäº†å¯¹non-ASCIIçš„æ”¯æŒã€‚
* [Syntax][]åˆ—ä¸¾äº†æœ¬åº“æ˜ç¡®æ”¯æŒçš„æ­£åˆ™è¡¨è¾¾å¼è¯­æ³•ã€‚
* [Untrusted input][]è®¨è®ºäº†æœ¬åº“å¦‚ä½•å¤„ç†ä¸å—ä¿¡ä»»çš„regexæˆ–haystackã€‚
* [Crate features][]è®°å½•äº†è¿™ä¸ªåº“å¯ä»¥è¢«å¯ç”¨æˆ–ç¦ç”¨çš„ç‰¹æ€§ã€‚
* [Other crates][]ä¸æ­£åˆ™å®¶æ—ä¸­å…¶ä»–åº“é“¾æ¥ã€‚



#### Usage

`regex`åœ¨ [crates.io][https://crates.io/crates/regex]ä¸Šï¼Œå¯ä»¥é€šè¿‡åœ¨é¡¹ç›®`Cargo.toml`æ–‡ä»¶æ·»åŠ `regex`åˆ°ä½ çš„ä¾èµ–é¡¹æ¥ä½¿ç”¨ã€‚æ›´ç®€å•çš„æ–¹å¼ï¼Œåªéœ€è¦`cargo run regex`ã€‚

è¿™æ˜¯ä¸€ä¸ªå®Œæ•´çš„ç¤ºä¾‹ï¼Œå®ƒåˆ›å»ºäº†ä¸€ä¸ªæ–°çš„ Rust é¡¹ç›®ï¼Œæ·»åŠ äº†å¯¹ `regex` çš„ä¾èµ–ï¼Œåˆ›å»ºäº†æ­£åˆ™æœç´¢çš„æºä»£ç ï¼Œç„¶åè¿è¡Œäº†ç¨‹åºã€‚

ç¬¬ä¸€æ­¥ï¼Œåœ¨æ–°ç›®å½•æ–°å»ºé¡¹ç›®ï¼š

```bash
$ mkdir regex-example
$ cd regex-example
$ crago init
```

ç¬¬äºŒæ­¥ï¼Œæ·»åŠ `regex`ä¾èµ–ï¼š

```bash
$ cargo add regex
```

ç¬¬ä¸‰æ­¥ï¼šç¼–è¾‘`src/main.rs`ï¼Œç”¨ä»¥ä¸‹å†…å®¹æ›¿æ¢å…¶æºç ï¼š

```rust
use regex::Regex;

fn main() {
    let re = Regex::new(r"Hello (?<name>\w+)!").unwrap();
    let Some(caps) = re.captures("Hello Murphy!") else {
        println!("no match!");
        return;
    };
    println!("The name is: {}", &caps["name"]);
}
```

ç¬¬å››æ­¥ï¼Œæ‰§è¡Œ`cargo run`è¿è¡Œ

```bash
$ cargo run
   Compiling memchr v2.5.0
   Compiling regex-syntax v0.7.1
   Compiling aho-corasick v1.0.1
   Compiling regex v1.8.1
   Compiling regex-example v0.1.0 (/tmp/regex-example)
    Finished dev [unoptimized + debuginfo] target(s) in 4.22s
     Running `target/debug/regex-example`
The name is: Murphy
```

ç¨‹åºç¬¬ä¸€æ¬¡è¿è¡Œå°†å±•ç¤ºæ›´å¤šè¾“å‡ºï¼Œå¦‚ä¸Šæ‰€ç¤ºã€‚ä½†æ˜¯åç»­è¿è¡Œä¸éœ€è¦é‡æ–°ç¼–è¯‘ä¾èµ–é¡¹ã€‚ã€

#### Examples

-----------

æœ¬èŠ‚æä¾›äº†ä¸€äº›ç¤ºä¾‹ï¼Œä»¥æ•™ç¨‹é£æ ¼å±•ç¤ºå¦‚ä½•ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åœ¨haystackä¸­è¿›è¡Œæœç´¢ã€‚APIæ–‡æ¡£ä¸­è¿˜æœ‰æ›´å¤šç¤ºä¾‹ã€‚

åœ¨å¼€å§‹ä¹‹å‰ï¼Œæœ‰å¿…è¦å®šä¹‰ä¸€äº›æœ¯è¯­ï¼š

* **regex**æ˜¯ç±»å‹ä¸º`Regex`çš„å€¼ã€‚æˆ‘ä»¬ç”¨`re`ä½œä¸ºæ­£åˆ™è¡¨è¾¾å¼çš„å˜é‡åã€‚
* **pattern**ç”¨äºæ„å»ºæ­£åˆ™è¡¨è¾¾å¼çš„å­—ç¬¦ä¸²ã€‚æˆ‘ä»¬ç”¨`pat`ä½œä¸ºæ¨¡å¼çš„å˜é‡åã€‚
* **haystack**æ˜¯è¢«æ­£åˆ™è¡¨è¾¾å¼æœç´¢çš„å­—ç¬¦ä¸²ã€‚æˆ‘ä»¬ç”¨`hay`ä½œä¸ºhaystackçš„å˜é‡åã€‚

æœ‰æ—¶å€™â€œregexâ€å’Œâ€œpatternâ€è¿™ä¸¤ä¸ªè¯ä¼šè¢«äº’æ¢ä½¿ç”¨ã€‚

åœ¨è¿™ä¸ªcrateä¸­ï¼Œå¸¸è§„è¡¨è¾¾å¼çš„ä¸€èˆ¬ä½¿ç”¨æ–¹æ³•æ˜¯å°†ä¸€ä¸ªæ¨¡å¼ç¼–è¯‘æˆä¸€ä¸ªæ­£åˆ™è¡¨è¾¾å¼ï¼Œç„¶åä½¿ç”¨è¯¥æ­£åˆ™è¡¨è¾¾å¼æ¥æœç´¢ã€åˆ†å‰²æˆ–æ›¿æ¢å­—ç¬¦ä¸²çš„ä¸€éƒ¨åˆ†ã€‚

##### Example: find a middle intial

------------

æˆ‘ä»¬ä»ä¸€ä¸ªéå¸¸ç®€å•çš„ä¾‹å­å¼€å§‹ï¼šä¸€ä¸ªæ­£åˆ™è¡¨è¾¾å¼ï¼Œç”¨äºæŸ¥æ‰¾ç‰¹å®šçš„åç§°ï¼Œä½†ä½¿ç”¨é€šé…ç¬¦æ¥åŒ¹é…ä¸­é—´åã€‚

```rust
use regex::Regex;

// We use 'unwrap()' here because it would be a bug in our program if the
// pattern failed to compile to a regex. Panicking in the presence of a bug
// is okay.
let re = Regex::new(r"Homer (.)\. Simpson").unwrap();
let hay = "Homer J. Simpson";
let Some(caps) = re.captures(hay) else { return };
assert_eq!("J", &caps[1]);
```

åœ¨ç¬¬ä¸€ä¸ªä¾‹å­æœ‰äº›å€¼å¾—æ³¨æ„çš„åœ°æ–¹ï¼š

* `.` æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„æ¨¡å¼å…ƒå­—ç¬¦ï¼Œè¡¨ç¤ºâ€œåŒ¹é…ä»»ä½•å•ä¸ªå­—ç¬¦ï¼Œé™¤äº†æ¢è¡Œç¬¦ã€‚â€ï¼ˆæ›´ç²¾ç¡®åœ°è¯´ï¼Œåœ¨è¿™ä¸ª crate ä¸­ï¼Œè¡¨ç¤ºâ€œåŒ¹é…ä»»ä½• UTF-8 ç¼–ç çš„ä»»ä½• Unicode æ ‡é‡å€¼ï¼Œé™¤äº† \nã€‚â€ï¼‰
* æˆ‘ä»¬å¯ä»¥ç”¨è½¬ä¹‰å­—ç¬¦æ¥åŒ¹é…å®é™…çš„ç‚¹å·ï¼Œå³` \.`ã€‚
* æˆ‘ä»¬ä½¿ç”¨ Rust çš„åŸå§‹å­—ç¬¦ä¸²æ¥é¿å…åœ¨æ­£åˆ™è¡¨è¾¾å¼æ¨¡å¼è¯­æ³•å’Œ Rust çš„å­—ç¬¦ä¸²å­—é¢é‡è¯­æ³•ä¸­å¤„ç†è½¬ä¹‰åºåˆ—ã€‚å¦‚æœæˆ‘ä»¬ä¸ä½¿ç”¨åŸå§‹å­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨`\\.`å»åŒ¹é…å­—ç¬¦`.`ã€‚`r"\."`å’Œ`\\.`æ˜¯ç­‰æ•ˆçš„æ¨¡å¼ã€‚
* æˆ‘ä»¬å°†é€šé…ç¬¦` \.` æŒ‡ä»¤æ”¾åœ¨æ‹¬å·ä¸­ã€‚è¿™äº›æ‹¬å·å…·æœ‰ç‰¹æ®Šå«ä¹‰ï¼Œè¡¨ç¤ºâ€œå°† haystack ä¸­ä¸è¿™äº›æ‹¬å·åŒ¹é…çš„éƒ¨åˆ†ä½œä¸ºæ•è·ç»„å¯ç”¨â€ã€‚æ‰¾åˆ°åŒ¹é…åï¼Œæˆ‘ä»¬ä½¿ç”¨ &caps[1] è®¿é—®æ­¤æ•è·ç»„ã€‚

å¦åˆ™ï¼Œæˆ‘ä»¬ä½¿ç”¨ `re.captures(hay) `æ‰§è¡Œæœç´¢ï¼Œå¹¶åœ¨æ²¡æœ‰åŒ¹é…æ—¶ä»æˆ‘ä»¬çš„å‡½æ•°ä¸­è¿”å›ã€‚ç„¶åï¼Œæˆ‘ä»¬é€šè¿‡è¯¢é—®ä¸æ•è·ç»„ç´¢å¼•ä¸º`1`çš„éƒ¨åˆ†åŒ¹é…çš„haystackçš„é‚£ä¸€éƒ¨åˆ†æ¥å¼•ç”¨ä¸­é—´åã€‚ï¼ˆç´¢å¼•ä¸º0çš„æ•è·ç»„æ˜¯éšå¼çš„ï¼Œæ€»æ˜¯å¯¹åº”æ•´ä¸ªåŒ¹é…ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œé‚£å°±æ˜¯`Homer J. Simpson`ã€‚ï¼‰

##### Example: named capture groups

------

åœ¨æˆ‘ä»¬ä¸Šé¢çš„ä¸­é—´åˆå§‹ç¤ºä¾‹ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ç¨å¾®è°ƒæ•´ä¸€ä¸‹æ¨¡å¼ï¼Œç»™åŒ¹é…ä¸­é—´åˆå§‹çš„ç»„å‘½åï¼š

```rust
use regex::Regex;
// Note that (?P<middle>.) is a different way to spell the same thing.
let re = Regex::new(r"Homer (?<middle>.)\. Simpson").unwrap();
let hay = "Homer J. Simpson";
let Some(caps) = re.captures(hay) else {return};
assert_eq!("J", &caps["middle"]);
```

ç»™ä¸€ç»„å‘½ååœ¨æ¨¡å¼ä¸­æœ‰å¤šä¸ªç»„æ—¶å¾ˆæœ‰ç”¨ã€‚å®ƒä½¿å¼•ç”¨è¿™äº›ç»„çš„ä»£ç æ›´å®¹æ˜“ç†è§£ã€‚

##### Example: validating a particular date format

----------

è¿™ä¸ªç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•ç¡®è®¤ä¸€ä¸ªå­—ç¬¦ä¸²ï¼ˆhaystackï¼‰æ˜¯å¦å®Œå…¨åŒ¹é…æŸä¸ªç‰¹å®šçš„æ—¥æœŸæ ¼å¼ï¼š

```rust
use regex::Regex;

let re = Regex::new(r"^\d{4}-\d{2}-\d{2}$").unwrap();
assert!(re.is_match("2010-03-14"));
```

æ³¨æ„ `^` å’Œ `$` é”šç‚¹çš„ä½¿ç”¨ã€‚åœ¨è¿™ä¸ªcrateä¸­ï¼Œæ¯ä¸ªæ­£åˆ™è¡¨è¾¾å¼æœç´¢éƒ½ä¼šåœ¨å…¶æ¨¡å¼çš„å¼€å¤´éšå¼åœ°åŠ ä¸Š`(?s:.)*?`ï¼Œè¿™ä½¿å¾—æ­£åˆ™è¡¨è¾¾å¼å¯ä»¥åœ¨haystackçš„ä»»ä½•ä½ç½®è¿›è¡ŒåŒ¹é…ã€‚æ­£å¦‚ä¸Šé¢æ‰€æåˆ°çš„ï¼Œé”šç‚¹å¯ä»¥ç”¨æ¥ç¡®ä¿æ•´ä¸ªhaystackåŒ¹é…ä¸€ä¸ªæ¨¡å¼ã€‚

è¿™ä¸ª crate é»˜è®¤æ˜¯ Unicode æ„ŸçŸ¥çš„ï¼Œè¿™æ„å‘³ç€ `\d `å¯èƒ½ä¼šåŒ¹é…ä½ å¯èƒ½é¢„æœŸçš„æ›´å¤šå†…å®¹ã€‚ä¾‹å¦‚ï¼š

```rust
use regex::Regex;

let re = Regex::new(r"^\d{4}-\d{2}-\d{2}$").unwrap();
assert!(re.is_match("ğŸšğŸ˜ğŸ™ğŸ˜-ğŸ˜ğŸ›-ğŸ™ğŸœ"));
```

è¦ä»…åŒ¹é…ASCIIåè¿›åˆ¶æ•°å­—ï¼Œä»¥ä¸‹æ‰€æœ‰å†…å®¹éƒ½æ˜¯ç­‰æ•ˆçš„ï¼š

* `[0-9]`
* `[?-u:\d]`
* `[[:digit:]]`
* `[\d&&\p{ascii}]`

##### Example: find dates in a haystack

-------

åœ¨ä¹‹å‰çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å±•ç¤ºäº†å¦‚ä½•éªŒè¯æ•´ä¸ªhaystackæ˜¯å¦å¯¹åº”äºç‰¹å®šçš„æ—¥æœŸæ ¼å¼ã€‚ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬æƒ³è¦ä»ä¸€å¤§å †æ•°æ®ä¸­æå–å‡ºç‰¹å®šæ ¼å¼çœ‹èµ·æ¥åƒæ—¥æœŸçš„æ‰€æœ‰ä¸œè¥¿ï¼Œè¯¥æ€ä¹ˆåŠï¼Ÿè¦å®ç°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªè¿­ä»£å™¨APIæ¥æŸ¥æ‰¾æ‰€æœ‰åŒ¹é…é¡¹ï¼ˆè¯·æ³¨æ„ï¼Œæˆ‘ä»¬å·²ç»ç§»é™¤äº†é”šç‚¹å¹¶åˆ‡æ¢åˆ°æŸ¥æ‰¾ä»…åŒ…å«ASCIIå­—ç¬¦çš„æ•°å­—ï¼‰ï¼š

```rust
use regex::Regex;

let re = Regex::new(r"[0-9]{4}-[0-9]{2}-[0-9]{2}").unwrap();
let hay = "What do 1865-04-14, 1881-07-02, 1901-09-06 and 1963-11-22 have in common?";
// 'm' is a 'Match', and 'as_str()' returns the matching part of the haystack.
let dates: Vec<&str> = re.find_iter(hay).map(|m| m.as_str()).collect();
assert_eq!(dates, vec![
    "1865-04-14",
    "1881-07-02",
    "1901-09-06",
    "1963-11-22",
]);
```

æˆ‘ä»¬ä¹Ÿå¯ä»¥éå†æ•è·å€¼ï¼ˆ`Captures`ï¼‰è€Œä¸æ˜¯åŒ¹é…å€¼ï¼ˆ`Match`ï¼‰ï¼Œè¿™æ ·å°±å¯ä»¥é€šè¿‡æ•è·ç»„è®¿é—®æ—¥æœŸçš„æ¯ä¸ªç»„ä»¶ï¼š

```rust
(?<name>pattern)
 â”‚ â”‚    â”‚       â”‚
 â”‚ â”‚    â”‚       â””â”€ æ•è·ç»„çš„æ¨¡å¼
 â”‚ â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ æ•è·ç»„çš„åç§°
 â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ å‘½åè¯­æ³•çš„å¼€å§‹
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ æ•è·ç»„çš„å¼€å§‹
```

```rust
use regex::Regex;

let re = Regex::new(r"(?<y>[0-9]{4})-(?<m>[0-9]{2})-(?<d>[0-9]{2})").unwrap();
let hay = "What do 1865-04-14, 1881-07-02, 1901-09-06 and 1963-11-22 have in common?";
// 'm' is a 'Match', and 'as_str()' returns the matching part of the haystack.
let dates: Vec<(&str, &str, &str)> = re.captures_iter(hay).map(|caps| {
    // The unwraps are okay because every capture group must match if the whole
    // regex matches, and in this context, we know we have a match.
    //
    // Note that we use `caps.name("y").unwrap().as_str()` instead of
    // `&caps["y"]` because the lifetime of the former is the same as the
    // lifetime of `hay` above, but the lifetime of the latter is tied to the
    // lifetime of `caps` due to how the `Index` trait is defined.
    let year = caps.name("y").unwrap().as_str();
    let month = caps.name("m").unwrap().as_str();
    let day = caps.name("d").unwrap().as_str();
    (year, month, day)
}).collect();
assert_eq!(dates, vec![
    ("1865", "04", "14"),
    ("1881", "07", "02"),
    ("1901", "09", "06"),
    ("1963", "11", "22"),
]);
```

##### Example: simpler capture group extraction

--------

å¯ä»¥ä½¿ç”¨` Captures::extract` å°†å‰ä¸€ä¸ªç¤ºä¾‹ä¸­çš„ä»£ç ç®€åŒ–ä¸€äº›ï¼š

```rust
use regex::Regex;

let re = Regex::new(r"([0-9]{4})-([0-9]{2})-([0-9]{2})").unwrap();
let hay = "What do 1865-04-14, 1881-07-02, 1901-09-06 and 1963-11-22 have in common?";
let dates: Vec<(&str, &str, &str)> = re.captures_iter(hay).map(|caps| {
    let (_, [year, month, day]) = caps.extract();
    (year, month, day)
}).collect();
assert_eq!(dates, vec![
    ("1865", "04", "14"),
    ("1881", "07", "02"),
    ("1901", "09", "06"),
    ("1963", "11", "22"),
]);
```

`Captures::extract` é€šè¿‡ç¡®ä¿åŒ¹é…çš„ç»„æ•°ä¸é€šè¿‡ `[year, month, day] `è¯­æ³•è¯·æ±‚çš„ç»„æ•°åŒ¹é…æ¥å·¥ä½œã€‚å¦‚æœå®ƒä»¬åŒ¹é…ï¼Œé‚£ä¹ˆæ¯ä¸ªå¯¹åº”æ•è·ç»„çš„å­å­—ç¬¦ä¸²å°†è‡ªåŠ¨ä»¥é€‚å½“å¤§å°çš„æ•°ç»„è¿”å›ã€‚Rust çš„æ•°ç»„æ¨¡å¼åŒ¹é…è¯­æ³•è´Ÿè´£å…¶ä½™éƒ¨åˆ†ã€‚

##### replacement with named capture groups

--------

åœ¨ä¹‹å‰çš„ä¾‹å­åŸºç¡€ä¸Šï¼Œä¹Ÿè®¸æˆ‘ä»¬æƒ³é‡æ–°æ’åˆ—æ—¥æœŸæ ¼å¼ã€‚å¯ä»¥é€šè¿‡æ‰¾åˆ°æ¯ä¸ªåŒ¹é…é¡¹å¹¶ç”¨ä¸åŒçš„å†…å®¹æ›¿æ¢å®ƒæ¥å®ç°ã€‚`Regex::replace_all` è¿™ä¸ªå‡½æ•°æä¾›äº†ä¸€ç§æ–¹ä¾¿çš„æ–¹æ³•æ¥å®Œæˆè¿™ä¸ªä»»åŠ¡ï¼ŒåŒ…æ‹¬æ”¯æŒåœ¨æ›¿æ¢å­—ç¬¦ä¸²ä¸­å¼•ç”¨å‘½åç»„ï¼š

```rust
use regex::Regex;

let re = Regex::new(r"(?<y>\d{4})-(?<m>\d{2})-(?<d>\d{2})").unwrap();
let before = "1973-01-05, 1975-08-25 and 1980-10-18";
let after = re.replace_all(before, "$m/$d/$y");
assert_eq!(after, "01/05/1973, 08/25/1975 and 10/18/1980");
```

æ›¿æ¢æ–¹æ³•å®é™…ä¸Šåœ¨æ›¿æ¢ä¸­æ˜¯å¤šæ€çš„ï¼Œè¿™æä¾›äº†æ¯”è¿™é‡Œçœ‹åˆ°çš„æ›´å¤šçš„çµæ´»æ€§ã€‚ï¼ˆæœ‰å…³ `Regex::replace` çš„æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…æ–‡æ¡£ã€‚ï¼‰

##### Example: verbose mode

-------

å½“ä½ çš„æ­£åˆ™è¡¨è¾¾å¼å˜å¾—å¤æ‚æ—¶ï¼Œä½ å¯èƒ½éœ€è¦è€ƒè™‘ä½¿ç”¨å…¶ä»–å·¥å…·ï¼Œè€Œä¸æ˜¯æ­£åˆ™è¡¨è¾¾å¼ã€‚ä½†æ˜¯ï¼Œå¦‚æœä½ åšæŒä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ï¼Œä½ å¯ä»¥ä½¿ç”¨ `x` æ ‡å¿—å¯ç”¨ä¸æ˜¾ç€çš„ç©ºç™½æ¨¡å¼æˆ–â€œè¯¦ç»†æ¨¡å¼â€ã€‚åœ¨è¿™ç§æ¨¡å¼ä¸‹ï¼Œç©ºç™½è¢«è§†ä¸ºä¸æ˜¾ç€ï¼Œå¯ä»¥ç¼–å†™æ³¨é‡Šã€‚è¿™å¯èƒ½ä¼šä½¿ä½ çš„æ¨¡å¼æ›´æ˜“äºç†è§£ã€‚

```rust
use regex::Regex;

let re = Regex::new(r"(?x)
  (?P<y>\d{4}) # the year, including all Unicode digits
  -
  (?P<m>\d{2}) # the month, including all Unicode digits
  -
  (?P<d>\d{2}) # the day, including all Unicode digits
").unwrap();

let before = "1973-01-05, 1975-08-25 and 1980-10-18";
let after = re.replace_all(before, "$m/$d/$y");
assert_eq!(after, "01/05/1973, 08/25/1975 and 10/18/1980");
```

å¦‚æœä½ å¸Œæœ›åœ¨è¿™ç§æ¨¡å¼ä¸‹åŒ¹é…ç©ºç™½å­—ç¬¦ï¼Œä»ç„¶å¯ä»¥ä½¿ç”¨ `\s`, `\n`, `\t` ç­‰ã€‚è¦è½¬ä¹‰å•ä¸ªç©ºæ ¼å­—ç¬¦ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨ `\`ï¼Œä½¿ç”¨å…¶åå…­è¿›åˆ¶å­—ç¬¦ä»£ç  `\x20` æˆ–æš‚æ—¶ç¦ç”¨` x` æ ‡å¿—ï¼Œä¾‹å¦‚ï¼Œ`(?-x: )`ã€‚

##### Example: match multiple regular expressions simultaneously

è¿™å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ `RegexSet` åœ¨ä¸€æ¬¡æ‰«æä¸­åŒ¹é…å¤šä¸ªï¼ˆå¯èƒ½é‡å çš„ï¼‰æ­£åˆ™è¡¨è¾¾å¼ï¼š

```rust
use regex::RegexSet;

let set = RegexSet::new(&[
    r"\w+",
    r"\d+",
    r"\pL+",
    r"foo",
    r"bar",
    r"barfoo",
    r"foobar",
]).unwrap();

// Iterate over and collect all of the matches. Each match corresponds to the
// ID of the matching pattern.
let matches: Vec<_> = set.matches("foobar").into_iter().collect();
assert_eq!(matches, vec![0, 2, 3, 4, 6]);

// You can also test whether a particular regex matched:
let matches = set.matches("foobar");
assert!(!matches.matched(5));
assert!(matches.matched(6));
```

#### Performance

--------

æœ¬èŠ‚ç®€è¦è®¨è®ºäº†æ­£åˆ™è¡¨è¾¾å¼åœ¨é€Ÿåº¦å’Œèµ„æºä½¿ç”¨æ–¹é¢çš„å‡ ä¸ªé—®é¢˜ã€‚

##### Only ask for what you need

------

åœ¨ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼è¿›è¡Œæœç´¢æ—¶ï¼Œé€šå¸¸å¯ä»¥è¯·æ±‚ä¸‰ç§ä¸åŒç±»å‹çš„ä¿¡æ¯ï¼š

1. æ­£åˆ™è¡¨è¾¾å¼åœ¨haystackä¸­åŒ¹é…å—ï¼Ÿ
2. æ­£åˆ™è¡¨è¾¾å¼åœ¨haystackåŒ¹é…çš„ä½ç½®ï¼Ÿ
3. æ¯ä¸ªæ•è·ç»„åœ¨haystackä¸­åŒ¹é…çš„ä½ç½®åœ¨å“ªé‡Œï¼Ÿ

ä¸€èˆ¬æ¥è¯´ï¼Œè¿™ä¸ªåº“å¯ä»¥æä¾›ä¸€ä¸ªå‡½æ•°æ¥å›ç­”#3ï¼Œè¿™ä¼šè‡ªåŠ¨åŒ…å«#1å’Œ#2ã€‚ç„¶è€Œï¼Œè®¡ç®—æ•è·ç»„åŒ¹é…ä½ç½®å¯èƒ½ä¼šæ˜¾è‘—æ›´æ˜‚è´µï¼Œæ‰€ä»¥å¦‚æœä½ ä¸éœ€è¦çš„è¯æœ€å¥½ä¸è¦è¿™æ ·åšã€‚

å› æ­¤ï¼Œåªéœ€è¦è¯·æ±‚ä½ éœ€è¦çš„å†…å®¹ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä½ åªéœ€è¦æµ‹è¯•æ­£åˆ™è¡¨è¾¾å¼æ˜¯å¦åŒ¹é…ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œä¸è¦ä½¿ç”¨`Regex::find`ã€‚è€Œæ˜¯ä½¿ç”¨`Regex::is_match`ã€‚

##### Unicode can impact usage and search speed

-------

è¿™ä¸ªcrateå¯¹Unicodeæœ‰ä¸€çº§æ”¯æŒå¹¶é»˜è®¤å¯ç”¨ã€‚åœ¨è®¸å¤šæƒ…å†µä¸‹ï¼Œä¸ºäº†æ”¯æŒå®ƒæ‰€éœ€çš„é¢å¤–å†…å­˜å¯ä»¥å¿½ç•¥ä¸è®¡ï¼Œå¹¶ä¸”é€šå¸¸ä¸ä¼šå½±å“æœç´¢é€Ÿåº¦ã€‚ä½†åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå®ƒå¯èƒ½ä¼šæœ‰å½±å“ã€‚

åœ¨å†…å­˜ä½¿ç”¨æ–¹é¢ï¼ŒUnicodeçš„ä¸»è¦å½±å“ä¸»è¦é€šè¿‡Unicodeå­—ç¬¦ç±»ä½“ç°ã€‚Unicodeå­—ç¬¦ç±»é€šå¸¸ç›¸å½“å¤§ã€‚ä¾‹å¦‚ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œ\wåŒ¹é…å¤§çº¦14ä¸‡ä¸ªä¸åŒçš„ä»£ç ç‚¹ã€‚è¿™éœ€è¦é¢å¤–çš„å†…å­˜ï¼Œå¹¶ä¸”é€šå¸¸ä¼šå‡æ…¢æ­£åˆ™è¡¨è¾¾å¼ç¼–è¯‘çš„é€Ÿåº¦ã€‚è™½ç„¶è¿™é‡Œå¶å°”ä½¿ç”¨ä¸€ä¸ª\wé€šå¸¸ä¸ä¼šè¢«æ³¨æ„åˆ°ï¼Œä½†å†™\w{100}ä¼šé»˜è®¤ç”Ÿæˆä¸€ä¸ªç›¸å½“å¤§çš„æ­£åˆ™è¡¨è¾¾å¼ã€‚å®é™…ä¸Šï¼Œ\wæ¯”å…¶ä»…é™ASCIIçš„ç‰ˆæœ¬å¤§å¾—å¤šï¼Œå› æ­¤å¦‚æœæ‚¨çš„éœ€æ±‚ä»…é™äºASCIIï¼Œé‚£ä¹ˆä½¿ç”¨ASCIIç±»å¯èƒ½æ˜¯ä¸€ä¸ªå¥½ä¸»æ„ã€‚ä»…é™ASCIIçš„\wå¯ä»¥ä»¥å¤šç§æ–¹å¼æ‹¼å†™ã€‚ä»¥ä¸‹æ‰€æœ‰å†…å®¹éƒ½æ˜¯ç­‰ä»·çš„ï¼š

* `[0-9A-Za-z_]`
* `(?-u:\w)`
* `[[:word:]]`
* `[\w&&\p{ascii}]`

åœ¨æœç´¢é€Ÿåº¦æ–¹é¢ï¼ŒUnicodeé€šå¸¸èƒ½å¤Ÿå¾ˆå¥½åœ°å¤„ç†ï¼Œå³ä½¿åœ¨ä½¿ç”¨å¤§å‹Unicodeå­—ç¬¦ç±»æ—¶ä¹Ÿæ˜¯å¦‚æ­¤ã€‚ç„¶è€Œï¼Œä¸€äº›æ›´å¿«çš„å†…éƒ¨æ­£åˆ™è¡¨è¾¾å¼å¼•æ“æ— æ³•å¤„ç†Unicodeæ„ŸçŸ¥çš„å•è¯è¾¹ç•Œæ–­è¨€ã€‚å› æ­¤ï¼Œå¦‚æœä½ ä¸éœ€è¦Unicodeæ„ŸçŸ¥çš„å•è¯è¾¹ç•Œæ–­è¨€ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨(?-u:\b)ä»£æ›¿\bï¼Œå…¶ä¸­å‰è€…ä½¿ç”¨ASCII-onlyçš„å•è¯å­—ç¬¦å®šä¹‰ã€‚

##### Literals might accelerate searches

------

è¿™ä¸ªcrateåœ¨è¯†åˆ«æ­£åˆ™è¡¨è¾¾å¼æ¨¡å¼ä¸­çš„å­—é¢é‡å¹¶ä½¿ç”¨å®ƒä»¬åŠ é€Ÿæœç´¢æ–¹é¢é€šå¸¸è¡¨ç°è‰¯å¥½ã€‚å¦‚æœå¯èƒ½çš„è¯ï¼Œåœ¨ä½ çš„æ¨¡å¼ä¸­åŒ…å«æŸç§å­—é¢é‡å¯èƒ½ä¼šä½¿æœç´¢æ˜¾è‘—åŠ å¿«ã€‚ä¾‹å¦‚ï¼Œåœ¨æ­£åˆ™è¡¨è¾¾å¼ \w+@\w+ ä¸­ï¼Œå¼•æ“ä¼šæŸ¥æ‰¾ @ çš„å‡ºç°ï¼Œç„¶åå°è¯•åå‘åŒ¹é… \w+ æ¥æ‰¾åˆ°èµ·å§‹ä½ç½®ã€‚

##### Avoid re-compiling regexes, especially in a loop

------

åœ¨å¾ªç¯ä¸­ç¼–è¯‘ç›¸åŒçš„æ¨¡å¼æ˜¯ä¸€ç§åæ¨¡å¼ï¼Œå› ä¸ºæ­£åˆ™è¡¨è¾¾å¼ç¼–è¯‘é€šå¸¸å¾ˆæ˜‚è´µã€‚ï¼ˆç¼–è¯‘æ—¶é—´å–å†³äºæ¨¡å¼çš„å¤§å°ï¼Œå¯èƒ½ä»å‡ å¾®ç§’åˆ°å‡ æ¯«ç§’ä¸ç­‰ã€‚ï¼‰ä¸ä»…ç¼–è¯‘æœ¬èº«æ˜‚è´µï¼Œè€Œä¸”è¿™è¿˜ä¼šé˜»æ­¢æ­£åˆ™è¡¨è¾¾å¼å¼•æ“å†…éƒ¨é‡ç”¨åˆ†é…çš„ä¼˜åŒ–ã€‚

åœ¨ Rust ä¸­ï¼Œå¦‚æœæ­£åˆ™è¡¨è¾¾å¼åœ¨è¾…åŠ©å‡½æ•°å†…éƒ¨ä½¿ç”¨ï¼Œä¼ é€’å®ƒä»¬å¯èƒ½ä¼šæœ‰äº›éº»çƒ¦ã€‚ç›¸åï¼Œæˆ‘ä»¬å»ºè®®ä½¿ç”¨ `std::sync::LazyLock` æˆ– `once_cell` crateï¼Œå¦‚æœä½ ä¸èƒ½ä½¿ç”¨æ ‡å‡†åº“ã€‚

è¿™ä¸ªç¤ºä¾‹å±•ç¤ºäº†å¦‚ä½•ä½¿ç”¨ `std::sync::LazyLock`ï¼š

```rust
use std::sync::LazyLock;

use regex::Regex;

fn some_helper_function(haystack: &str) -> bool {
    static RE: LazyLock<Regex> = LazyLock::new(|| Regex::new(r"...").unwrap());
    RE.is_match(haystack)
}

fn main() {
    assert!(some_helper_function("abc"));
    assert!(!some_helper_function("ac"));
}
```

å…·ä½“æ¥è¯´ï¼Œåœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæ­£åˆ™è¡¨è¾¾å¼ä¼šåœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨æ—¶è¿›è¡Œç¼–è¯‘ã€‚åœ¨åç»­ä½¿ç”¨ä¸­ï¼Œå®ƒä¼šé‡ç”¨ä¹‹å‰æ„å»ºçš„æ­£åˆ™è¡¨è¾¾å¼ã€‚æ³¨æ„å¦‚ä½•å°†æ­£åˆ™è¡¨è¾¾å¼å®šä¹‰ä¸ºç‰¹å®šå‡½æ•°çš„å±€éƒ¨å˜é‡ã€‚

##### Sharing a regex across threads can resule in contention

----

è™½ç„¶å•ä¸ªæ­£åˆ™è¡¨è¾¾å¼å¯ä»¥åŒæ—¶ä»å¤šä¸ªçº¿ç¨‹è‡ªç”±ä½¿ç”¨ï¼Œä½†å¿…é¡»æ”¯ä»˜ä¸€å®šçš„åŒæ­¥æˆæœ¬ã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œé™¤éæ¯ä¸ªçº¿ç¨‹çš„ä¸»è¦ä»»åŠ¡æ˜¯ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼è¿›è¡Œæœç´¢ï¼Œå¹¶ä¸”å¤§å¤šæ•°æœç´¢éƒ½åœ¨è¾ƒçŸ­çš„å­—ç¬¦ä¸²ä¸­è¿›è¡Œï¼Œå¦åˆ™ä¸ä¼šè§‚å¯Ÿåˆ°è¿™ç§æƒ…å†µã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå…±äº«èµ„æºçš„å†…éƒ¨ç«äº‰å¯èƒ½ä¼šæ¿€å¢ï¼Œå¢åŠ å»¶è¿Ÿï¼Œä»è€Œå¯èƒ½å‡æ…¢æ¯ä¸ªå•ç‹¬çš„æœç´¢ã€‚

å¯ä»¥é€šè¿‡åœ¨å‘é€åˆ°å¦ä¸€ä¸ªçº¿ç¨‹ä¹‹å‰å…‹éš†æ¯ä¸ªæ­£åˆ™è¡¨è¾¾å¼æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚å…‹éš†çš„æ­£åˆ™è¡¨è¾¾å¼ä»ç„¶ä¼šå…±äº«å…¶ç¼–è¯‘çŠ¶æ€çš„ç›¸åŒå†…éƒ¨åªè¯»éƒ¨åˆ†ï¼ˆå®ƒæ˜¯å¼•ç”¨è®¡æ•°çš„ï¼‰ï¼Œä½†æ¯ä¸ªçº¿ç¨‹å°†è·å¾—å¯¹è¿è¡Œæœç´¢æ—¶ä½¿ç”¨çš„å¯å˜ç©ºé—´çš„ä¼˜åŒ–è®¿é—®ã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œè¿™æ ·åšä¸ä¼šå¢åŠ é¢å¤–çš„å†…å­˜æˆæœ¬ã€‚å”¯ä¸€çš„æˆæœ¬æ˜¯éœ€è¦æ˜¾å¼å…‹éš†æ­£åˆ™è¡¨è¾¾å¼æ‰€å¢åŠ çš„ä»£ç å¤æ‚æ€§ã€‚ï¼ˆå¦‚æœä½ åœ¨å¤šä¸ªçº¿ç¨‹ä¹‹é—´å…±äº«åŒä¸€ä¸ªæ­£åˆ™è¡¨è¾¾å¼ï¼Œæ¯ä¸ªçº¿ç¨‹ä»ç„¶ä¼šè·å¾—è‡ªå·±çš„å¯å˜ç©ºé—´ï¼Œä½†è®¿é—®è¯¥ç©ºé—´ä¼šæ›´æ…¢ã€‚ï¼‰

#### Unicode

-----

æœ¬èŠ‚è®¨è®ºäº†è¯¥æ­£åˆ™è¡¨è¾¾å¼åº“å¯¹Unicodeçš„æ”¯æŒæƒ…å†µã€‚åœ¨å±•ç¤ºä¸€äº›ç¤ºä¾‹ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæ€»ç»“ä¸€ä¸‹ç›¸å…³è¦ç‚¹ï¼š

* è¿™ä¸ª crate å‡ ä¹å®Œå…¨å®ç°äº† Unicode æŠ€æœ¯æ ‡å‡† #18 ä¸­è§„å®šçš„â€œåŸºæœ¬ Unicode æ”¯æŒâ€ï¼ˆçº§åˆ« 1ï¼‰ã€‚æ”¯æŒçš„è¯¦ç»†ä¿¡æ¯åœ¨ regex crate ä»“åº“çš„æ ¹ç›®å½•ä¸‹çš„ UNICODE.md æ–‡ä»¶ä¸­æœ‰è¯¦ç»†è¯´æ˜ã€‚å‡ ä¹ä¸æ”¯æŒ Unicode æŠ€æœ¯æ ‡å‡† #18 ä¸­è§„å®šçš„â€œæ‰©å±• Unicode æ”¯æŒâ€ï¼ˆçº§åˆ« 2ï¼‰ã€‚
* é¡¶çº§æ­£åˆ™è¡¨è¾¾å¼åƒè¿­ä»£éå†haystackä¸­çš„æ¯ä¸ªä»£ç ç‚¹ä¸€æ ·è¿è¡Œæœç´¢ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼ŒåŒ¹é…çš„åŸºæœ¬åŸå­æ˜¯ä¸€ä¸ªå•ä¸€çš„ä»£ç ç‚¹ã€‚
* `bytes::Regex` åœ¨æ‰€æœ‰æƒ…å†µä¸‹éƒ½å…è®¸ç¦ç”¨ Unicode æ¨¡å¼ï¼Œå¯¹æ•´ä¸ªæ¨¡å¼æˆ–éƒ¨åˆ†æ¨¡å¼è¿›è¡Œç¦ç”¨ã€‚å½“ Unicode æ¨¡å¼è¢«ç¦ç”¨æ—¶ï¼Œæœç´¢ä¼šåƒéå† haystack ä¸­çš„æ¯ä¸ªå­—èŠ‚ä¸€æ ·è¿›è¡Œã€‚ä¹Ÿå°±æ˜¯è¯´ï¼ŒåŒ¹é…çš„åŸºæœ¬å•å…ƒæ˜¯ä¸€ä¸ªå­—èŠ‚ã€‚ï¼ˆé¡¶çº§ Regex ä¹Ÿå…è®¸ç¦ç”¨ Unicodeï¼Œä»è€Œåƒé€å­—èŠ‚åŒ¹é…ä¸€æ ·è¿›è¡ŒåŒ¹é…ï¼Œä½†ä»…åœ¨è¿™æ ·åšä¸ä¼šå…è®¸åŒ¹é…æ— æ•ˆçš„ UTF-8 æ—¶ã€‚ï¼‰
* å½“Unicodeæ¨¡å¼å¯ç”¨ï¼ˆé»˜è®¤æƒ…å†µä¸‹ï¼‰æ—¶ï¼Œ`.`å°†åŒ¹é…ä¸€ä¸ªå®Œæ•´çš„Unicodeæ ‡é‡å€¼ï¼Œå³ä½¿å®ƒä½¿ç”¨å¤šä¸ªå­—èŠ‚è¿›è¡Œç¼–ç ã€‚å½“Unicodeæ¨¡å¼ç¦ç”¨ï¼ˆä¾‹å¦‚ï¼Œ(?-u:.ï¼‰ï¼‰æ—¶ï¼Œ`.`å°†å§‹ç»ˆåŒ¹é…ä¸€ä¸ªå­—èŠ‚ã€‚
* å­—ç¬¦ç±» `\w`, `\d` å’Œ `\s` é»˜è®¤æ˜¯ Unicode æ„ŸçŸ¥çš„ã€‚ä½¿ç”¨` (?-u:\w)`, `(?-u:\d) `å’Œ `(?-u:\s)` å¯ä»¥è·å–å®ƒä»¬çš„ ASCII ä»…å®šä¹‰ã€‚
* åŒæ ·ï¼Œ`\b` å’Œ `\B` ä½¿ç”¨ Unicode å®šä¹‰çš„â€œå•è¯â€å­—ç¬¦ã€‚è¦è·å–ä»…é™ ASCII çš„å•è¯è¾¹ç•Œï¼Œå¯ä»¥ä½¿ç”¨ `(?-u:\b)` å’Œ `(?-u:\B)`ã€‚è¿™ä¹Ÿé€‚ç”¨äºç‰¹æ®Šçš„å•è¯è¾¹ç•Œæ–­è¨€ã€‚ï¼ˆå³ `\b{start}`ï¼Œ`\b{end}`ï¼Œ`\b{start-half}`ï¼Œ`\b{end-half}`ã€‚ï¼‰
* åœ¨å¤šè¡Œæ¨¡å¼ä¸‹ï¼Œ`^ `å’Œ` $` ä¸æ˜¯ Unicode æ„ŸçŸ¥çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒä»¬åªè¯†åˆ«` \n`ï¼ˆå‡è®¾æœªå¯ç”¨ CRLF æ¨¡å¼ï¼‰ï¼Œè€Œä¸è¯†åˆ« Unicode å®šä¹‰çš„å…¶ä»–ä»»ä½•è¡Œç»ˆæ­¢ç¬¦ã€‚
* ä¸åŒºåˆ†å¤§å°å†™çš„æœç´¢æ˜¯Unicodeæ„ŸçŸ¥çš„ï¼Œå¹¶ä½¿ç”¨ç®€å•çš„å¤§å°å†™æŠ˜å ã€‚
* Unicodeé€šç”¨ç±»åˆ«ã€è„šæœ¬å’Œè®¸å¤šå¸ƒå°”å±æ€§å¯ä»¥é€šè¿‡é»˜è®¤çš„\p{å±æ€§åç§°}è¯­æ³•è®¿é—®ã€‚
* åœ¨æ‰€æœ‰æƒ…å†µä¸‹ï¼ŒåŒ¹é…éƒ½æ˜¯ä½¿ç”¨å­—èŠ‚åç§»é‡æŠ¥å‘Šçš„ã€‚æ›´ç²¾ç¡®åœ°è¯´ï¼Œæ˜¯ä½¿ç”¨UTF-8ä»£ç å•å…ƒåç§»é‡ã€‚è¿™å…è®¸å¯¹haystackè¿›è¡Œå¸¸æ•°æ—¶é—´çš„ç´¢å¼•å’Œåˆ‡ç‰‡ã€‚

æ¨¡å¼æœ¬èº«ä»…è¢«è§£é‡Šä¸ºUnicodeæ ‡é‡å€¼çš„åºåˆ—ã€‚è¿™æ„å‘³ç€ä½ å¯ä»¥åœ¨ä½ çš„æ¨¡å¼ä¸­ç›´æ¥ä½¿ç”¨Unicodeå­—ç¬¦ï¼š

```rust
use regex::Regex;

let re = Regex::new(r"(?i)Î”+").unwrap();
let m = re.find("Î”Î´Î”").unwrap();
assert_eq!((0, 6), (m.start(), m.end()));
// alternatively:
assert_eq!(0..6, m.range());
```

å¦‚ä¸Šæ‰€è¿°ï¼ŒUnicodeé€šç”¨ç±»åˆ«ã€è„šæœ¬ã€è„šæœ¬æ‰©å±•ã€ç‰ˆæœ¬ä»¥åŠä¸€äº›å¸ƒå°”å±æ€§éƒ½å¯ä»¥ä½œä¸ºå­—ç¬¦ç±»ä½¿ç”¨ã€‚ä¾‹å¦‚ï¼Œä½ å¯ä»¥åŒ¹é…ä¸€ä¸²æ•°å­—ã€å¸Œè…Šå­—æ¯æˆ– Cherokee å­—æ¯ï¼š

```rust
use regex::Regex;

let re = Regex::new(r"[\pN\p{Greek}\p{Cherokee}]+").unwrap();
let m = re.find("abcÎ”á Î²â… á´Î³Î´â…¡xyz").unwrap();
assert_eq!(3..23, m.range());
```

##### Opt out of Unicode support

-------

`bytes::Regex`ç±»å‹å¯ä»¥æœç´¢`&[u8]`haystackã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œhaystacks é€šå¸¸åƒä¸» `Regex` ç±»å‹ä¸€æ ·è¢«å½“ä½œ UTF-8 å¤„ç†ã€‚ç„¶è€Œï¼Œå¯ä»¥é€šè¿‡å…³é—­`u`æ ‡å¿—æ¥ç¦ç”¨æ­¤è¡Œä¸ºï¼Œå³ä½¿è¿™æ ·åšå¯èƒ½ä¼šå¯¼è‡´åŒ¹é…æ— æ•ˆçš„UTF-8ã€‚ä¾‹å¦‚ï¼Œå½“å…³é—­`u`æ ‡å¿—æ—¶ï¼Œ`.`å°†åŒ¹é…ä»»ä½•å­—èŠ‚è€Œä¸æ˜¯ä»»ä½•Unicodeæ ‡é‡å€¼ã€‚

ç¦ç”¨ `u` æ ‡å¿—ä¹Ÿå¯ä»¥ä½¿ç”¨æ ‡å‡†çš„ `&str` åŸºäºçš„ Regex ç±»å‹ï¼Œä½†ä»…åœ¨ç»´æŠ¤ UTF-8 ä¸å˜æ€§çš„æƒ…å†µä¸‹å…è®¸ã€‚ä¾‹å¦‚ï¼Œ`(?-u:\w)` æ˜¯ä¸€ä¸ªä»…åŒ…å« ASCII å­—ç¬¦çš„ \w å­—ç¬¦ç±»ï¼Œå¹¶ä¸”åœ¨ `&str` åŸºäºçš„ Regex ä¸­æ˜¯åˆæ³•çš„ï¼Œä½† `(?-u:\W)`å°†å°è¯•åŒ¹é…ä¸åœ¨` (?-u:\w) `ä¸­çš„ä»»ä½•å­—èŠ‚ï¼Œè¿™åè¿‡æ¥åŒ…æ‹¬æ— æ•ˆçš„ UTF-8 å­—èŠ‚ã€‚åŒæ ·ï¼Œ`(?-u:\xFF)`å°†å°è¯•åŒ¹é…åŸå§‹å­—èŠ‚ `\xFF`ï¼ˆè€Œä¸æ˜¯ U+00FFï¼‰ï¼Œè¿™æ˜¯æ— æ•ˆçš„ UTF-8ï¼Œå› æ­¤åœ¨ `&str` åŸºäºçš„æ­£åˆ™è¡¨è¾¾å¼ä¸­æ˜¯éæ³•çš„ã€‚

æœ€åï¼Œç”±äºUnicodeæ”¯æŒéœ€è¦æ‰“åŒ…å¤§å‹Unicodeæ•°æ®è¡¨ï¼Œè¯¥crateæä¾›äº†æ§åˆ¶å°å¼€å…³æ¥ç¦ç”¨è¿™äº›æ•°æ®è¡¨çš„ç¼–è¯‘ï¼Œè¿™åœ¨ç¼©å°äºŒè¿›åˆ¶æ–‡ä»¶å¤§å°å’Œå‡å°‘ç¼–è¯‘æ—¶é—´æ–¹é¢å¯èƒ½å¾ˆæœ‰ç”¨ã€‚æœ‰å…³å¦‚ä½•å®ç°è¿™ä¸€ç‚¹çš„è¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜…crateåŠŸèƒ½éƒ¨åˆ†ã€‚

#### Syntax

-----

æœ¬åº“æ”¯æŒçš„è¯­æ³•å¦‚ä¸‹ã€‚

æ³¨æ„ï¼Œæ­£åˆ™è¡¨è¾¾å¼è§£æå™¨å’ŒæŠ½è±¡è¯­æ³•åœ¨å•ç‹¬çš„ crate `regex-syntax` ä¸­æš´éœ²ã€‚

##### Matching one character

```tcl
.             é™¤äº†æ¢è¡Œç¬¦ï¼ˆåŒ…æ‹¬å¸¦æœ‰ s æ ‡å¿—çš„æ¢è¡Œç¬¦ï¼‰
[0-9]         ä»»ä½• ASCII æ•°å­—
\d            æ•°å­— (\p{Nd})
\D            éæ•°å­—
\pX           ç”±ä¸€ä¸ªå­—æ¯åç§°æ ‡è¯†çš„Unicodeå­—ç¬¦ç±»
\p{Greek}     Unicodeå­—ç¬¦ç±»ï¼ˆé€šç”¨ç±»åˆ«æˆ–è„šæœ¬ï¼‰
\PX           ç”±ä¸€ä¸ªå­—æ¯åç§°æ ‡è¯†çš„å¦å®šUnicodeå­—ç¬¦ç±»
\P{Greek}     å¦å®šçš„Unicodeå­—ç¬¦ç±»ï¼ˆé€šç”¨ç±»åˆ«æˆ–è„šæœ¬ï¼‰
```

##### Character classes

-----



[åŸåœ°å€][https://docs.rs/regex/latest/regex/ ]

---------

#### å•è¯

- `verbose`:
  -  `adj.` å†—é•¿çš„ï¼Œå•°å—¦çš„
- `routine`: 
  - `n.` å¸¸è§„ï¼Œ æ— èŠ
  - `adj.` å¸¸è§„çš„ï¼Œæ— èŠçš„
- `subsequent`ï¼š
  - `adj.`éšåçš„ï¼Œåæ¥çš„
- `wildcard`:
  - `n.`é€šé…ç¬¦
- `tweak`
  - `adj.`ç¨å¾®è°ƒæ•´ï¼Œæ‹§ï¼Œæ‰¯
- `polymorphic`
  - `adj.`å¤šæ€çš„
- `insignificant`
  - `adj.`å¾®ä¸è¶³é“çš„ï¼›æ— è¶³è½»é‡çš„ï¼›æ— æ„ä¹‰çš„
- `comprehend`
  - `vt.`ç†è§£ï¼Œé¢†æ‚Ÿï¼ŒåŒ…å«
- `simultaneously`
  - `adv.`åŒæ—¶åœ°ï¼ŒåŒæ­¥åœ°
- `overlap`
  - `vt.`ä¸...é‡å ï¼›æœ‰é‡å 
  - `n.`é‡å éƒ¨åˆ†
- `concern`
  - `n.`å…³å¿ƒï¼Œæ‹…å¿ƒ
  - `vt.`ä½¿æ‹…å¿ƒï¼Œæ¶‰åŠ
- `contention`
  - 
