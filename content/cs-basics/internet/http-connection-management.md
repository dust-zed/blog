+++
date = '2025-11-03T15:18:19+08:00'
draft = true
title = 'HTTP连接管理'
categories = ['cs-basics']
tags = ['HTTP', 'Network', 'Performance']
description = "深入解析 HTTP 连接管理演进：从短连接、Keep-Alive 到管道化与域名分片，以及预热技术。"
slug = "http-connection-management"
+++

### HTTP 连接管理深度解析

## 一、为什么需要连接管理？

### 1.1 TCP 连接的成本

```
建立一个 TCP 连接需要：

时间成本:
┌─────────────────────────────────────┐
│ 三次握手                             │
│ 客户端 ─── SYN ────────> 服务器      │
│        <── SYN-ACK ──── 服务器      │
│ 客户端 ─── ACK ────────> 服务器      │
│                                     │
│ 耗时 = 1.5 × RTT                    │
│ (RTT = Round Trip Time 往返时间)    │
└─────────────────────────────────────┘

实际例子：
─────────────────────────────────────
场景: 北京用户访问上海服务器
RTT = 40ms

建立连接: 40ms × 1.5 = 60ms
TLS 握手: 40ms × 2 = 80ms (HTTPS)
────────────────────────────
总开销: 140ms

还没开始传输数据,就耗费了 140ms!


资源成本:
├─ 服务器需要为每个连接分配:
│  ├─ 内存 (接收/发送缓冲区)
│  ├─ 文件描述符
│  └─ CPU 时间 (维护连接状态)
│
└─ 服务器能同时处理的连接数有限
   (受内存、文件描述符限制)
```

### 1.2 早期的 HTTP/1.0 问题

```
HTTP/1.0 默认行为：短连接（Short-lived Connection）

访问一个简单网页：
─────────────────────────────────────
HTML 页面包含:
├─ index.html
├─ style.css
├─ script.js
├─ logo.png
└─ background.jpg

HTTP/1.0 的处理方式:
─────────────────────────────────────

┌─ 请求 index.html ─┐
│ ① 建立TCP连接     │ 60ms
│ ② 发送请求        │ 20ms
│ ③ 接收响应        │ 30ms
│ ④ 关闭连接        │ 20ms
└──────────────────┘ 总计: 130ms

┌─ 请求 style.css ──┐
│ ① 建立TCP连接     │ 60ms (重新建立!)
│ ② 发送请求        │ 20ms
│ ③ 接收响应        │ 30ms
│ ④ 关闭连接        │ 20ms
└──────────────────┘ 总计: 130ms

┌─ 请求 script.js ──┐
│ ① 建立TCP连接     │ 60ms (又重新建立!)
│ ② 发送请求        │ 20ms
│ ③ 接收响应        │ 30ms
│ ④ 关闭连接        │ 20ms
└──────────────────┘ 总计: 130ms

... 每个资源都要重新建立连接!

5个资源 × 130ms = 650ms
其中 5 × 60ms = 300ms 都浪费在建立连接上!

问题总结：
每个请求都要建立新连接
大量时间浪费在握手上
服务器频繁创建/销毁连接，负载高
页面加载慢
```

---

## 二、HTTP/1.1 持久连接（Keep-Alive）

```
核心思想：连接复用

HTTP/1.1 默认行为：长连接（Persistent Connection）

同样的场景：
─────────────────────────────────────

┌─ 建立一次TCP连接 ─┐
│                   │ 60ms (只建立一次!)
└───────────────────┘

在同一个连接上:
├─ 请求 index.html  │ 50ms
├─ 请求 style.css   │ 50ms
├─ 请求 script.js   │ 50ms
├─ 请求 logo.png    │ 50ms
└─ 请求 background.jpg │ 50ms

┌─ 关闭连接 ────────┐
│                   │ 20ms
└───────────────────┘

总计: 60 + 5×50 + 20 = 330ms

对比 HTTP/1.0: 650ms
性能提升: 约 50%!


关键特性：
✓ 连接保持打开状态
✓ 多个请求共用一个连接
✓ 减少握手开销
✓ 降低服务器负载
```

### 2.2 Keep-Alive 的实现

```
HTTP 头部控制：

HTTP/1.0 （需要显式声明）：
─────────────────────────────────────
请求:
GET / HTTP/1.0
Connection: Keep-Alive

响应:
HTTP/1.0 200 OK
Connection: Keep-Alive
Keep-Alive: timeout=5, max=100

说明:
- timeout=5: 连接空闲5秒后关闭
- max=100: 这个连接最多处理100个请求

HTTP/1.1 （默认开启）
─────────────────────────────────────
请求:
GET / HTTP/1.1
Host: example.com
(不需要 Connection: Keep-Alive,默认就是)

响应:
HTTP/1.1 200 OK
(默认保持连接)

如果想关闭:
HTTP/1.1 200 OK
Connection: close  ← 明确告诉客户端要关闭
```

### 2.3 连接生命周期

```
完整的连接生命周期：

时间轴
───────────────────────────────────────

t0: 建立连接
    客户端 ─── TCP 三次握手 ──> 服务器
    
t1: 发送第一个请求
    ─── GET /index.html ───>
    <── HTTP/1.1 200 OK ───
    
t2: 连接空闲
    (什么都不传输)
    
t3: 发送第二个请求
    ─── GET /style.css ───>
    <── HTTP/1.1 200 OK ───
    
t4: 连接空闲
    
t5: 发送第三个请求
    ─── GET /script.js ───>
    <── HTTP/1.1 200 OK ───
    
t6: 连接空闲 (超过 timeout)
    
t7: 连接关闭
    ─── TCP 四次挥手 ───
    
关键时间点:
├─ t0-t1: 连接建立后立即使用
├─ t2, t4, t6: 空闲期
│  - 如果空闲时间 > timeout,服务器主动关闭
│  - 节省服务器资源
├─ t7: 连接关闭
│  - 客户端或服务器都可以发起
└─ 如果请求数达到 max,也会关闭
```

---

## 三、HTTP 管道化（Pipelining）

### 3.1 管道化原理

```
持久连接的改进：HTTP 管道化

传统持久连接 (串行):
─────────────────────────────────────
客户端                        服务器
  |                             |
  |─── 请求1 ─────────────────>|
  |                             | 处理
  |<── 响应1 ───────────────────|
  |                             |
  |─── 请求2 ─────────────────>|
  |                             | 处理
  |<── 响应2 ───────────────────|
  |                             |
  
特点: 必须等前一个响应返回才能发下一个请求


管道化 (并行发送):
─────────────────────────────────────
客户端                        服务器
  |                             |
  |─── 请求1 ─────────────────>|
  |─── 请求2 ─────────────────>| 处理1
  |─── 请求3 ─────────────────>| 处理2
  |                             | 处理3
  |<── 响应1 ───────────────────|
  |<── 响应2 ───────────────────|
  |<── 响应3 ───────────────────|
  
特点: 不用等响应,连续发送多个请求


性能对比:
─────────────────────────────────────

假设:
- RTT = 100ms
- 每个请求处理 = 50ms
- 发送 3 个请求

传统方式:
请求1: 100ms(往返) + 50ms(处理) = 150ms
请求2: 100ms(往返) + 50ms(处理) = 150ms
请求3: 100ms(往返) + 50ms(处理) = 150ms
总计: 450ms

管道化:
发送3个请求: 100ms(一次往返)
服务器处理: 50ms + 50ms + 50ms = 150ms
接收3个响应: 100ms(一次往返)
总计: 250ms

性能提升: 约 45%!
```

### 3.2 管道化的问题

```
问题 1: 队头阻塞 (Head-of-Line Blocking)
─────────────────────────────────────

场景:
客户端发送: 请求1, 请求2, 请求3
服务器必须按顺序响应: 响应1, 响应2, 响应3

如果请求1处理很慢:
┌────────────────────────────────┐
│ 请求1: 大文件,需要10秒         │
│ 请求2: 小接口,只需0.1秒        │ ← 被阻塞!
│ 请求3: 小接口,只需0.1秒        │ ← 被阻塞!
└────────────────────────────────┘

时间线:
t0-t10: 处理请求1,发送响应1
t10-t10.1: 处理请求2,发送响应2  ← 必须等请求1完成
t10.1-t10.2: 处理请求3,发送响应3

请求2、3虽然很快,但被请求1阻塞了10秒!


问题 2: 响应顺序限制
─────────────────────────────────────
服务器必须按请求顺序返回响应
即使请求3先处理完,也要等请求1、2返回后才能发送

实际场景:
请求1: 复杂数据库查询,5秒
请求2: 简单API,0.5秒
请求3: 缓存命中,0.1秒

处理完成顺序: 3 → 2 → 1
但返回顺序必须: 1 → 2 → 3
请求3虽然0.1秒就完成,但要等5秒才能返回!


问题 3: 实现复杂
─────────────────────────────────────
├─ 客户端需要维护请求队列
├─ 服务器需要按序返回响应
├─ 错误处理复杂
│  (某个请求失败怎么办?)
└─ 中间代理不一定支持


问题 4: 浏览器支持差
─────────────────────────────────────
大多数浏览器默认禁用管道化!
├─ Chrome: 不支持
├─ Firefox: 默认关闭
├─ Safari: 不支持
└─ 只有极少数场景启用

原因:
- 队头阻塞问题严重
- 中间代理可能不支持
- 收益不明显
```

### 3.3 为什么管道化没有普及？

```
理论上的优势:
✓ 减少往返次数
✓ 提升带宽利用率
✓ 降低延迟

实际中的问题:
❌ 队头阻塞无法解决
❌ 中间代理不支持
❌ 实现复杂,容易出错
❌ 错误恢复困难
❌ 收益有限

结果:
HTTP/1.1 管道化基本没人用
→ 浏览器开启了其他优化方式
→ 最终被 HTTP/2 取代
```

---

## 四、并发连接 （Concurrent Connections）

### 4.1 浏览器的并发策略

```
既然管道化不可用，浏览器的解决方案：
同时打开多个TCP连接！

浏览器并发连接数限制：
─────────────────────────────────────

同一个域名:
├─ Chrome: 6个并发连接
├─ Firefox: 6个并发连接
├─ Safari: 6个并发连接
├─ Edge: 6个并发连接
└─ IE: 6个并发连接 (IE11+)


实际工作方式:
─────────────────────────────────────

场景: 页面需要加载 20 个资源

┌─ 连接1 ─┐  ┌─ 连接2 ─┐  ┌─ 连接3 ─┐
│ 资源1   │  │ 资源2   │  │ 资源3   │
│ 资源7   │  │ 资源8   │  │ 资源9   │
│ 资源13  │  │ 资源14  │  │ 资源15  │
│ 资源19  │  │ 资源20  │  │         │
└─────────┘  └─────────┘  └─────────┘

┌─ 连接4 ─┐  ┌─ 连接5 ─┐  ┌─ 连接6 ─┐
│ 资源4   │  │ 资源5   │  │ 资源6   │
│ 资源10  │  │ 资源11  │  │ 资源12  │
│ 资源16  │  │ 资源17  │  │ 资源18  │
│         │  │         │  │         │
└─────────┘  └─────────┘  └─────────┘

过程:
1. 同时建立 6 个连接
2. 分配前 6 个资源给这些连接
3. 某个连接完成后,立即加载下一个资源
4. 直到所有资源加载完成


优点:
✓ 避免队头阻塞
✓ 充分利用带宽
✓ 提升加载速度

缺点:
❌ 更多连接 = 更多开销
❌ 服务器压力增大
❌ 仍然受限于连接数
```

### 4.2 域名分片（Domain Sharding）

```
突破并发连接数限制的技巧:
使用多个子域名!

原理:
─────────────────────────────────────
浏览器的限制是"每个域名6个连接"
如果有多个域名,就可以开更多连接!

单域名:
example.com → 最多 6 个并发连接

域名分片:
├─ static1.example.com → 6 个连接
├─ static2.example.com → 6 个连接
├─ static3.example.com → 6 个连接
└─ static4.example.com → 6 个连接

总计: 24 个并发连接!


实际应用:
─────────────────────────────────────

HTML 中的资源分配:
<link rel="stylesheet" href="https://static1.example.com/a.css">
<link rel="stylesheet" href="https://static2.example.com/b.css">
<script src="https://static3.example.com/c.js"></script>
<img src="https://static4.example.com/d.jpg">
<img src="https://static1.example.com/e.jpg">
<img src="https://static2.example.com/f.jpg">

资源分散到不同子域名
→ 突破单域名6连接限制
→ 可以同时下载更多资源


实际效果对比:
─────────────────────────────────────

场景: 加载 24 张图片,每张 100KB

单域名 (6 并发):
批次1: 图1-6   (1秒)
批次2: 图7-12  (1秒)
批次3: 图13-18 (1秒)
批次4: 图19-24 (1秒)
总计: 4秒

4个子域名 (24 并发):
批次1: 图1-24  (1秒)
总计: 1秒

性能提升: 4倍!
```

### 4.3 域名分片的问题

```
问题 1: DNS 查询开销
─────────────────────────────────────
每个子域名都需要 DNS 查询:

static1.example.com → DNS 查询 (20-120ms)
static2.example.com → DNS 查询 (20-120ms)
static3.example.com → DNS 查询 (20-120ms)
static4.example.com → DNS 查询 (20-120ms)

4个域名 × 50ms = 200ms 额外开销


问题 2: TCP 连接开销
─────────────────────────────────────
每个域名都需要建立新连接:

24 个连接 × 60ms (三次握手) = 1.44秒
如果是 HTTPS:
24 个连接 × 140ms (握手+TLS) = 3.36秒!

反而更慢!


问题 3: 服务器压力
─────────────────────────────────────
├─ 更多连接 = 更多内存消耗
├─ 更多连接 = 更多 CPU 消耗
└─ 可能触发服务器连接数限制


问题 4: 不适合 HTTP/2
─────────────────────────────────────
HTTP/2 的多路复用已经解决并发问题
域名分片反而:
❌ 阻止连接复用
❌ 增加开销
❌ 降低性能


最佳实践:
─────────────────────────────────────
HTTP/1.1 时代:
✓ 使用 2-4 个域名分片
✗ 不要超过 4 个 (DNS/连接开销增加)

HTTP/2 时代:
✓ 域名收敛,用一个域名
✓ 充分利用多路复用
✗ 不要用域名分片
```

---

## 五、 连接预热技术

### 5.1 DNS 预解析（DNS Prefetch）

```
原理：
提前解析域名，避免请求时才查询

使用方式:
─────────────────────────────────────

HTML 中:
<head>
  <!-- 预解析第三方域名 -->
  <link rel="dns-prefetch" href="//cdn.example.com">
  <link rel="dns-prefetch" href="//api.example.com">
  <link rel="dns-prefetch" href="//analytics.google.com">
</head>

效果:
浏览器在空闲时就开始 DNS 查询
等真正请求资源时,DNS 已经解析好了


时间节省:
─────────────────────────────────────

不使用 DNS Prefetch:
用户点击链接
  ↓
DNS 查询 (50ms)
  ↓
建立连接 (60ms)
  ↓
请求资源 (100ms)
总计: 210ms

使用 DNS Prefetch:
页面加载时预解析 (后台进行)
用户点击链接
  ↓
(DNS已完成,跳过)
建立连接 (60ms)
  ↓
请求资源 (100ms)
总计: 160ms

节省: 50ms


适用场景:
├─ 页面会跳转到其他域名
├─ 加载第三方资源 (CDN, 分析工具)
├─ 动态加载的域名
└─ 用户可能点击的链接
```

### 5.2 预连接（Preconnect）

```
原理：
提前建 TCP 连接，包括 DNS、TCP、TLS

使用方式:
─────────────────────────────────────

<head>
  <!-- 预连接到关键域名 -->
  <link rel="preconnect" href="https://cdn.example.com">
  <link rel="preconnect" href="https://api.example.com" crossorigin>
</head>

包含的步骤:
1. DNS 解析
2. TCP 三次握手
3. TLS 握手 (HTTPS)


时间节省:
─────────────────────────────────────

不使用 Preconnect:
用户触发请求
  ↓
DNS 查询 (50ms)
  ↓
TCP 握手 (60ms)
  ↓
TLS 握手 (80ms)
  ↓
请求资源 (100ms)
总计: 290ms

使用 Preconnect:
页面加载时预连接 (后台进行)
用户触发请求
  ↓
(DNS+TCP+TLS已完成,跳过)
请求资源 (100ms)
总计: 100ms

节省: 190ms (66%!)


注意事项:
─────────────────────────────────────
⚠️  预连接会占用资源:
├─ 建立的连接会消耗服务器资源
├─ 10秒内不用会自动关闭
└─ 不要滥用,只对关键资源使用

推荐:
✓ 只对确定会用的域名预连接
✓ 最多 2-3 个域名
✗ 不要预连接太多域名
```

### 5.3 预获取 （Prefetch）

```
原理:
在浏览器空闲时,提前下载可能需要的资源

使用方式:
─────────────────────────────────────

<head>
  <!-- 预获取下一页可能用的资源 -->
  <link rel="prefetch" href="/next-page.html">
  <link rel="prefetch" href="/images/hero.jpg">
  <link rel="prefetch" href="/js/chart-library.js">
</head>

特点:
├─ 低优先级
├─ 浏览器空闲时才下载
├─ 不阻塞当前页面加载
└─ 下载后缓存起来


应用场景:
─────────────────────────────────────

场景1: 下一页预加载
当前页: 商品列表
预获取: 商品详情页的资源

场景2: 分步表单
当前: 第1步表单
预获取: 第2步、第3步的 JS/CSS

场景3: 懒加载准备
即将滚动到的图片提前下载


时间线:
─────────────────────────────────────

t0: 用户在页面A
    ├─ 正常加载页面A资源 (高优先级)
    └─ 后台预获取页面B资源 (低优先级)
    
t10: 页面A加载完成
     继续预获取页面B资源
     
t20: 用户点击进入页面B
     ├─ 资源已在缓存中
     └─ 立即显示,无需等待下载!


注意:
─────────────────────────────────────
⚠️  不要预获取太多:
├─ 浪费用户流量
├─ 占用带宽
└─ 可能永远用不上

推荐:
✓ 根据用户行为预测
✓ 只预获取大概率需要的资源
✓ 注意移动端流量
```

### 5.4 预渲染（Prerender）

```
原理:
在后台完整渲染整个页面

使用方式:
─────────────────────────────────────

<head>
  <!-- 预渲染下一个页面 -->
  <link rel="prerender" href="/next-page.html">
</head>

做的事情:
├─ 下载 HTML
├─ 下载所有资源 (CSS, JS, 图片)
├─ 执行 JavaScript
├─ 渲染 DOM
└─ 在后台隐藏的标签页中完成


用户体验:
─────────────────────────────────────

不使用 Prerender:
用户点击链接
  ↓
下载页面 (200ms)
  ↓
下载资源 (500ms)
  ↓
渲染页面 (100ms)
  ↓
显示 (白屏时间: 800ms)

使用 Prerender:
页面已在后台渲染好
用户点击链接
  ↓
立即切换到预渲染页面
  ↓
显示 (白屏时间: 0ms!)


⚠️  非常激进的优化:
─────────────────────────────────────

成本:
├─ 消耗大量带宽
├─ 占用大量内存
├─ 执行所有 JS (可能有副作用)
├─ 可能触发分析统计
└─ 用户可能根本不访问

浏览器限制:
├─ Chrome: 最多 1 个预渲染页面
├─ Firefox: 不支持
└─ 其他浏览器: 支持有限

推荐:
✓ 只用于非常确定的跳转
   (如:搜索结果第一条)
✗ 不要随便使用
✗ 移动端不推荐
```

### 5.5 预加载（Preload）

```
原理:
告诉浏览器这个资源很重要,优先下载

使用方式:
─────────────────────────────────────
<head>
  <!-- 预加载关键资源 -->
  <link rel="preload" href="/fonts/custom.woff2" as="font" crossorigin>
  <link rel="preload" href="/css/critical.css" as="style">
  <link rel="preload" href="/js/main.js" as="script">
  <link rel="preload" href="/images/hero.jpg" as="image">
</head>

as 属性的作用:
─────────────────────────────────────
告诉浏览器资源类型,影响优先级:

├─ as="script": 高优先级
├─ as="style": 高优先级
├─ as="font": 高优先级
├─ as="image": 中优先级
├─ as="video": 低优先级
└─ as="document": 最高优先级


Preload vs Prefetch 对比:
─────────────────────────────────────

Preload (当前页需要):
├─ 高优先级
├─ 立即下载
├─ 必须使用,否则浏览器警告
└─ 用于本页面的关键资源

Prefetch (下一页需要):
├─ 低优先级
├─ 浏览器空闲时下载
├─ 可能不会下载
└─ 用于下一页面的资源


实际应用场景:
─────────────────────────────────────

场景1: 字体预加载 (避免闪烁)
<link rel="preload" href="/fonts/custom.woff2" as="font" crossorigin>

为什么需要:
@font-face 在 CSS 中定义
→ 浏览器先下载 CSS
→ 解析 CSS 发现字体
→ 再下载字体
→ 字体到达后替换文字 (FOUT/FOIT)

使用 preload:
→ HTML 解析时就开始下载字体
→ CSS 到达时字体也快到了
→ 减少文字闪烁


场景2: 关键路径 CSS
<link rel="preload" href="/css/above-fold.css" as="style">
<link rel="stylesheet" href="/css/above-fold.css">

提高首屏 CSS 优先级


场景3: 动态加载的资源
<link rel="preload" href="/js/chat-widget.js" as="script">

<script>
  // 5秒后加载聊天组件
  setTimeout(() => {
    const script = document.createElement('script');
    script.src = '/js/chat-widget.js'; // 已经预加载好了
    document.body.appendChild(script);
  }, 5000);
</script>


场景4: 响应式图片
<link rel="preload" 
      href="/images/hero-large.jpg" 
      as="image" 
      media="(min-width: 1200px)">
<link rel="preload" 
      href="/images/hero-small.jpg" 
      as="image" 
      media="(max-width: 1199px)">

根据屏幕尺寸预加载对应图片


注意事项:
─────────────────────────────────────
⚠️  Preload 是强制性的:
如果预加载了但3秒内没使用,浏览器会警告
→ 不要预加载不需要的资源

⚠️  字体预加载必须加 crossorigin:
<link rel="preload" href="/fonts/font.woff2" as="font" crossorigin>
即使是同源,也要加 crossorigin
否则会下载两次!
```

#### 5.6 预热技术对比总结

```
┌─────────────┬──────────┬──────────┬──────────┬──────────┐
│ 技术         │ 时机      │ 优先级   │ 用途      │ 成本     │
├─────────────┼──────────┼──────────┼──────────┼──────────┤
│ DNS Prefetch│ 空闲时    │ 低       │ DNS查询   │ 最低     │
│             │          │          │ 其他域名  │          │
├─────────────┼──────────┼──────────┼──────────┼──────────┤
│ Preconnect  │ 空闲时    │ 中       │ 建立连接  │ 低       │
│             │          │          │ 关键域名  │          │
├─────────────┼──────────┼──────────┼──────────┼──────────┤
│ Preload     │ 立即      │ 高       │ 当前页面  │ 中       │
│             │          │          │ 关键资源  │          │
├─────────────┼──────────┼──────────┼──────────┼──────────┤
│ Prefetch    │ 空闲时    │ 最低     │ 下一页面  │ 中       │
│             │          │          │ 可能资源  │          │
├─────────────┼──────────┼──────────┼──────────┼──────────┤
│ Prerender   │ 空闲时    │ 最低     │ 完整页面  │ 最高     │
│             │          │          │ 确定跳转  │          │
└─────────────┴──────────┴──────────┴──────────┴──────────┘


使用建议:
─────────────────────────────────────

保守策略 (适合所有网站):
✓ DNS Prefetch: 第三方域名
✓ Preconnect: 1-2个关键域名
✓ Preload: 关键字体、首屏CSS

激进策略 (高性能要求):
✓ 上述全部 +
✓ Prefetch: 高概率下一页
✓ Prerender: 搜索结果第一条

移动端策略 (流量敏感):
✓ DNS Prefetch: 可以用
✓ Preconnect: 谨慎使用
✗ Prefetch: 不推荐
✗ Prerender: 禁止使用
```

---

### 六、HTTP/2 的连接管理

#### 6.1 多路复用（Multiplexing）

```
HTTP/1.1 的问题:
─────────────────────────────────────
即使用持久连接,请求仍然是串行的:

连接1:
请求1 → 响应1 → 请求2 → 响应2 → 请求3 → 响应3
        ↑
    队头阻塞问题


HTTP/2 的解决方案: 多路复用
─────────────────────────────────────

单个 TCP 连接上,多个请求/响应并行:

         TCP 连接
┌──────────────────────────────┐
│                              │
│  Stream 1: ──请求1── 响应1   │
│  Stream 2: ──请求2── 响应2   │
│  Stream 3: ──请求3── 响应3   │
│  Stream 4: ──请求4── 响应4   │
│                              │
└──────────────────────────────┘

所有请求/响应交错传输,互不阻塞!

工作原理:
─────────────────────────────────────

1. 二进制分帧:
   HTTP 消息被拆分成更小的帧

   请求1: 头部帧 + 数据帧1 + 数据帧2
   请求2: 头部帧 + 数据帧
   请求3: 头部帧 + 数据帧1 + 数据帧2 + 数据帧3

2. 帧打标签:
   每个帧都带有 Stream ID

   帧1 [Stream ID=1] 请求1头部
   帧2 [Stream ID=2] 请求2头部
   帧3 [Stream ID=1] 请求1数据
   帧4 [Stream ID=3] 请求3头部
   帧5 [Stream ID=2] 请求2数据
   帧6 [Stream ID=1] 请求1数据
   ...

3. 交错传输:
   TCP 连接上传输所有帧
   
   发送顺序:
   帧1 → 帧2 → 帧3 → 帧4 → 帧5 → 帧6 → ...
   
   混合了多个请求的帧!

4. 接收端重组:
   根据 Stream ID 把帧重新组装
   
   Stream 1: 帧1 + 帧3 + 帧6 → 完整的请求1
   Stream 2: 帧2 + 帧5 → 完整的请求2
   Stream 3: 帧4 → 完整的请求3


实际传输示例:
─────────────────────────────────────

时间线 (单个TCP连接):
t0: [Stream 1 HEADERS] 请求 /index.html
t1: [Stream 2 HEADERS] 请求 /style.css
t2: [Stream 3 HEADERS] 请求 /script.js
t3: [Stream 1 DATA] index.html 的内容 (1/3)
t4: [Stream 2 DATA] style.css 的内容 (完整)
t5: [Stream 1 DATA] index.html 的内容 (2/3)
t6: [Stream 3 DATA] script.js 的内容 (完整)
t7: [Stream 1 DATA] index.html 的内容 (3/3)

注意:
- 所有请求立即发送 (t0-t2)
- 响应交错返回 (t3-t7)
- 小文件可以快速完成 (style.css, script.js)
- 不会被大文件阻塞 (index.html)
```

#### 6.2 优先级与依赖

```
HTTP/2 允许设置请求优先级:

优先级设置:
─────────────────────────────────────

<link rel="stylesheet" href="critical.css">  ← 优先级: 最高
<script src="main.js"></script>              ← 优先级: 高
<img src="hero.jpg">                         ← 优先级: 中
<img src="footer.jpg">                       ← 优先级: 低


依赖关系:
─────────────────────────────────────

Stream 1 (HTML)
  ├─ Stream 2 (CSS) 依赖 Stream 1
  ├─ Stream 3 (JS) 依赖 Stream 1
  └─ Stream 4 (图片) 依赖 Stream 2, 3

依赖树:
          Stream 1 (HTML)
         /      |      \
    Stream 2  Stream 3  Stream 4
     (CSS)     (JS)    (Image)
       |
   Stream 5 (字体)


服务器根据优先级调度:
─────────────────────────────────────

高优先级先发送:
1. Stream 1 (HTML) - 优先级256
2. Stream 2 (CSS) - 优先级256
3. Stream 3 (JS) - 优先级220
4. Stream 4 (图片) - 优先级110
5. Stream 5 (字体) - 优先级100

带宽分配示例:
Stream 1: ████████████ (50%)
Stream 2: ██████ (30%)
Stream 3: ████ (20%)
Stream 4、5: 等前面的完成后再传输


实际效果:
─────────────────────────────────────

HTTP/1.1 (6个并发连接):
所有资源平等对待
→ 关键CSS可能被图片阻塞
→ 首屏渲染延迟

HTTP/2 (单连接+优先级):
关键资源优先传输
→ CSS、JS 先到达
→ 首屏渲染更快
→ 图片慢慢加载
```

#### 6.3 服务器推送（Server Push）

````
原理:
服务器主动推送资源,无需客户端请求

传统流程:
─────────────────────────────────────
客户端                          服务器
  |                                |
  |─── 请求 index.html ──────────>|
  |                                |
  |<── 返回 index.html ────────────|
  |  (包含 <link rel="stylesheet"> |
  |        <script src="...">)     |
  |                                |
  | 解析 HTML,发现需要资源         |
  |                                |
  |─── 请求 style.css ───────────>|
  |<── 返回 style.css ─────────────|
  |                                |
  |─── 请求 script.js ───────────>|
  |<── 返回 script.js ─────────────|

白白浪费了几个往返时间!


HTTP/2 服务器推送:
─────────────────────────────────────
客户端                          服务器
  |                                |
  |─── 请求 index.html ──────────>|
  |                                |
  |                                | 服务器知道HTML里
  |                                | 需要这些资源
  |                                |
  |<── 推送 style.css ─────────────| ← 主动推送
  |<── 推送 script.js ─────────────| ← 主动推送
  |<── 返回 index.html ────────────|
  |                                |
  | 解析 HTML,发现需要资源         |
  | 但它们已经在缓存里了!           |

节省了 2 个往返时间!


配置示例 (Nginx):
─────────────────────────────────────

location = /index.html {
    http2_push /css/style.css;
    http2_push /js/script.js;
    http2_push /images/logo.png;
}

访问 index.html 时,自动推送这些资源


Link 头部方式:
─────────────────────────────────────

HTTP/2 200 OK
Link: </css/style.css>; rel=preload; as=style
Link: </js/script.js>; rel=preload; as=script

服务器看到 Link 头部,自动推送这些资源


实际效果对比:
─────────────────────────────────────

场景: 首次访问网站
资源: index.html (10KB) + style.css (20KB) + script.js (30KB)
RTT: 100ms

不用服务器推送:
t0: 请求 index.html
t100: 收到 index.html,解析,发现需要 CSS/JS
t100: 请求 style.css, script.js
t200: 收到 style.css, script.js
总时间: 200ms

使用服务器推送:
t0: 请求 index.html
t0: 服务器同时推送 style.css, script.js (后台)
t100: 收到 index.html + style.css + script.js
总时间: 100ms

性能提升: 50%!


服务器推送的问题:
─────────────────────────────────────

问题1: 可能推送不需要的资源
用户可能已经缓存了某些资源
→ 推送浪费带宽

问题2: 优先级难以控制
推送的资源可能占用带宽
→ 影响更重要资源的传输

问题3: 实现复杂
服务器需要:
├─ 分析HTML,知道需要什么资源
├─ 判断客户端是否已缓存
└─ 动态决定推送策略

问题4: 浏览器可以拒绝
客户端可以发送 RST_STREAM 拒绝推送
→ 推送的努力白费


实际应用建议:
─────────────────────────────────────

✓ 推送场景:
├─ 首次访问 (没有缓存)
├─ 关键 CSS/JS
└─ 小文件 (<50KB)

✗ 不推送:
├─ 大文件 (图片、视频)
├─ 可能已缓存的资源
└─ 非关键资源

现状:
许多网站不用服务器推送,因为:
├─ 实现复杂
├─ 收益不明显
├─ Preload 头部更灵活
└─ HTTP/3 可能废弃这个特性
````

#### 6.4 HTTP/2 连接管理总结

```
HTTP/2 的核心改进:
─────────────────────────────────────

✓ 单一连接:
  只需一个 TCP 连接
  ├─ 减少连接开销
  ├─ 降低服务器负载
  └─ 避免多连接竞争

✓ 多路复用:
  完全消除队头阻塞 (应用层)
  ├─ 请求/响应并行
  ├─ 小文件不被大文件阻塞
  └─ 充分利用带宽

✓ 优先级:
  关键资源优先传输
  ├─ 更快首屏渲染
  └─ 更好用户体验

✓ 头部压缩:
  HPACK 算法
  ├─ 减少头部冗余
  └─ 降低带宽消耗

✗ 但仍有问题:
  TCP 层队头阻塞
  ├─ TCP 丢包会阻塞整个连接
  └─ 导致 HTTP/3 的诞生


HTTP/1.1 vs HTTP/2 性能对比:
─────────────────────────────────────

测试场景: 100个小文件 (各10KB)

HTTP/1.1 (6并发):
批次1: 6个文件 (200ms)
批次2: 6个文件 (200ms)
...
批次17: 4个文件 (200ms)
总时间: 3.4秒

HTTP/2 (单连接多路复用):
所有文件并行传输
总时间: 1.2秒

性能提升: 64%!
```

#### 6.3 多路复用的理解

```
多路复用 = 数据交错混合传输

本质:
把原本需要串行传输的多个请求
混合在一起,在同一个 TCP 连接上交错发送

避免了耗时请求阻塞后面的快速请求
```

##### 分帧不等于分包

```
HTTP/2 的"帧 (Frame)" ≠ TCP/IP 的"包 (Packet)"

它们在不同层:
┌────────────────────────────────────┐
│ 应用层 (HTTP/2)                     │
│ - HTTP消息分成多个帧 (Frame)        │
│ - 帧大小: 默认16KB,最大16MB         │
└──────────────┬─────────────────────┘
               ↓
┌────────────────────────────────────┐
│ 传输层 (TCP)                        │
│ - TCP把数据分成TCP段 (Segment)      │
│ - 段大小: 通常1460字节 (MSS)        │
└──────────────┬─────────────────────┘
               ↓
┌────────────────────────────────────┐
│ 网络层 (IP)                         │
│ - IP数据包 (Packet)                │
│ - 包大小: 通常1500字节 (MTU)        │
└────────────────────────────────────┘
```

##### 实际的传输过程

```
HTTP/2 发送一个请求:
─────────────────────────────────────

应用层视角 (HTTP/2):
请求被拆分成帧:
├─ HEADERS 帧 (512 字节)
├─ DATA 帧 1 (16KB)
├─ DATA 帧 2 (16KB)
└─ DATA 帧 3 (8KB)

这些帧会被送到 TCP 层


TCP 层视角:
TCP 不关心 HTTP/2 的帧,它看到的是:
40.5KB 的连续数据流

TCP 按照 MSS 分段:
├─ TCP 段1 (1460 字节)
├─ TCP 段2 (1460 字节)
├─ TCP 段3 (1460 字节)
├─ ...
└─ TCP 段28 (1008 字节)

共 28 个 TCP 段


关键点:
HTTP/2 的分帧发生在应用层
TCP 的分段发生在传输层
它们是独立的!

HTTP/2 的帧再小,也不会增加 TCP 段的数量
TCP 段数量由数据总量决定,不是帧数量!
```

##### 多路复用说明

```
HTTP/1.1 传输 3 个小文件:
─────────────────────────────────────

文件1: 10KB
文件2: 5KB
文件3: 8KB

方式1: 串行传输 (持久连接)
┌─────────────────────────────────────────┐
│ TCP连接                                  │
├─────────────────────────────────────────┤
│ [文件1: 10KB]                           │ ← t0-t100
│ [文件2: 5KB]                            │ ← t100-t150
│ [文件3: 8KB]                            │ ← t150-t230
└─────────────────────────────────────────┘

TCP 段数量:
(10+5+8)KB / 1.46KB ≈ 16 个 TCP 段
传输时间: 230ms (串行,有等待)


HTTP/2 传输相同 3 个文件:
─────────────────────────────────────────

方式2: 多路复用
┌─────────────────────────────────────────┐
│ TCP连接                                  │
├─────────────────────────────────────────┤
│ [文1-1][文2-1][文3-1][文1-2][文2-2]...  │ ← t0-t100
│  帧交错传输                              │
└─────────────────────────────────────────┘

TCP 段数量:
(10+5+8)KB / 1.46KB ≈ 16 个 TCP 段
(完全相同!)

传输时间: 100ms (并行,无等待)


重点:
TCP 段数量没有增加!
但传输时间减少了!
```

